<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>JavaScript | ZHPER 的笔记</title><meta name="author" content="zhper"><meta name="copyright" content="zhper"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据类型原始数据类型（简单数据类型）Undefined、Null、Bollean、Number、String、Symbol、BigInt 引用类型（复杂数据类型）Object 其中 Symbol和 BigInt 是 ES6 新增的数据类型    Symbol  每个从 Symbol() 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。 1">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript">
<meta property="og:url" content="https://zhper.vercel.app/2023/02/08/js/index.html">
<meta property="og:site_name" content="ZHPER 的笔记">
<meta property="og:description" content="数据类型原始数据类型（简单数据类型）Undefined、Null、Bollean、Number、String、Symbol、BigInt 引用类型（复杂数据类型）Object 其中 Symbol和 BigInt 是 ES6 新增的数据类型    Symbol  每个从 Symbol() 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。 1">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhper.vercel.app/assets/js.jpg">
<meta property="article:published_time" content="2023-02-07T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-09T15:25:40.488Z">
<meta property="article:author" content="zhper">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhper.vercel.app/assets/js.jpg"><link rel="shortcut icon" href="/assets/favicon/%E4%BF%9D%E5%85%BB%E6%89%8B%E5%86%8C.png"><link rel="canonical" href="https://zhper.vercel.app/2023/02/08/js/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-09 23:25:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ZHPER 的笔记"><span class="site-name">ZHPER 的笔记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JavaScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-02-07T16:00:00.000Z" title="Created 2023-02-08 00:00:00">2023-02-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-03-09T15:25:40.488Z" title="Updated 2023-03-09 23:25:40">2023-03-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="原始数据类型（简单数据类型）"><a href="#原始数据类型（简单数据类型）" class="headerlink" title="原始数据类型（简单数据类型）"></a>原始数据类型（简单数据类型）</h2><p><code>Undefined</code>、<code>Null</code>、<code>Bollean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>、<code>BigInt</code></p>
<h2 id="引用类型（复杂数据类型）"><a href="#引用类型（复杂数据类型）" class="headerlink" title="引用类型（复杂数据类型）"></a>引用类型（复杂数据类型）</h2><p><code>Object</code></p>
<p>其中 <code>Symbol</code>和 <code>BigInt</code> 是 ES6 新增的数据类型</p>
<ul>
<li>  <code>Symbol</code></li>
</ul>
<p>每个从 <code>Symbol()</code> 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">sym2 === sym3 <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>BigInt</code></li>
</ul>
<p>表示大于 <code>2^53-1</code> 的整数，这是在 js 中 <code>Number</code> 可以表示的最大数字</p>
<p>可以在一个整数字面量后面加上<code>n</code>的方式定义一个 <code>BigInt</code> ： <code>10n</code>， 也可以直接使用<code>BigInt()</code> 包裹一个数字或者字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theBiggestInt = <span class="number">9007199254740991n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alsoHuge = <span class="title class_">BigInt</span>(<span class="number">9007199254740991</span>)</span><br><span class="line"><span class="comment">// ↪ 9007199254740991n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hugeString = <span class="title class_">BigInt</span>(<span class="string">&#x27;9007199254740991&#x27;</span>)</span><br><span class="line"><span class="comment">// ↪ 9007199254740991n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hugeHex = <span class="title class_">BigInt</span>(<span class="string">&#x27;0x1fffffffffffff&#x27;</span>)</span><br><span class="line"><span class="comment">// ↪ 9007199254740991n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hugeBin = <span class="title class_">BigInt</span>(</span><br><span class="line">	<span class="string">&#x27;0b11111111111111111111111111111111111111111111111111111&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// ↪ 9007199254740991n</span></span><br></pre></td></tr></table></figure>

<h2 id="赋值变动过程"><a href="#赋值变动过程" class="headerlink" title="赋值变动过程"></a>赋值变动过程</h2><ul>
<li>  值类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a = <span class="number">200</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55df6cb63d3346be9ec1f572a1514853~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片 1.png"></p>
<p>值类型的数据直接存储在 <code>栈(stack)</code> 中， 数据简单，空间小，大小固定</p>
<ul>
<li>  引用类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">b.<span class="property">age</span> = <span class="number">30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">age</span>) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56c5c43d1c584ed4b8e4cce8855bab52~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片 2.png"></p>
<p>引用类型的数据存储在 <code>堆（heap）</code> 中， 数据复杂，空间大、大小不固定</p>
<h1 id="检测数据类型"><a href="#检测数据类型" class="headerlink" title="检测数据类型"></a>检测数据类型</h1><ul>
<li>  <strong>typeof</strong> : 能判断所有 值类型、函数，但是不能直接对 <strong>null(空对象)、对象、数组</strong>进行判断， 都返回 <code>object</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>) <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>) <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>) <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)) <span class="comment">// symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2172141653n</span>) <span class="comment">// bigint</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) <span class="comment">// function</span></span><br><span class="line"><span class="comment">// 不能判别</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []) <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;) <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>instanceof</strong>: 能判断对象类型， 运行机制是判断在其 原型链 中能否找到该类型的原型, 检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vortesnail = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vortesnail <span class="keyword">instanceof</span> <span class="title class_">People</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vortesnail <span class="keyword">instanceof</span> <span class="title class_">Student</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>Object.prototype.toString.call()</strong>: 能够判断所有的原始数据类型，同时包括 <strong>Error 对象、Date 对象等</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">2</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>) <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>) <span class="comment">// &quot;[object Math]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  检测数组类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) <span class="comment">//利用 Array的isArray</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// 利用instanceof</span></span><br><span class="line">arr.<span class="property">__proto</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">//利用原型链，实际上 instanceof 原理也是如此</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr) <span class="comment">//利用这个方法</span></span><br><span class="line">arr.<span class="property">constructor</span> === <span class="title class_">Array</span> <span class="comment">//利用构造函数,实例的构造函数属性 constructor 指向构造函数</span></span><br></pre></td></tr></table></figure>

<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><ul>
<li>  浅拷贝</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/1/16ce894a1f1b5c32~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<ul>
<li>  深拷贝</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/1/16ce893a54f6c13d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p>
<h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><h3 id="乞丐版"><a href="#乞丐版" class="headerlink" title="乞丐版"></a>乞丐版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure>

<h3 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h3><p>基于浅拷贝的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> cloneTarget = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">		cloneTarget[key] = target[key]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们利用递归来解决深层的对象</p>
<ul>
<li>  若是原始数据类型，直接返回</li>
<li>  若是引用类型，我们创建一个新对象，将需要克隆的对象的属性递归到这个新对象上</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">let</span> cloneTarget = &#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">			cloneTarget[key] = <span class="title function_">clone</span>(target[key])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cloneTarget</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> target</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于只存在对基本数据类型，这个就够了，但是并没有考虑数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">let</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">			cloneTarget[key] = <span class="title function_">clone</span>(target[key])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cloneTarget</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> target</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>如果我们有下面这种例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">field1</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">field2</span>: <span class="literal">undefined</span>,</span><br><span class="line">	<span class="attr">field3</span>: &#123;</span><br><span class="line">		<span class="attr">child</span>: <span class="string">&#x27;child&#x27;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">field4</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">&#125;</span><br><span class="line">target.<span class="property">target</span> = target</span><br></pre></td></tr></table></figure>

<p>此时<code>target</code>内部：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">field1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">field2</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">field3</span>: &#123; <span class="attr">child</span>: <span class="string">&#x27;child&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">field4</span>: [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span> ],</span><br><span class="line">  <span class="attr">target</span>: [<span class="title class_">Circular</span> *<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230212110721837.png" alt="image-20230212110721837"></p>
<p>如果这时候我们调用上面的拷贝函数，会得到如下结果</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/1/16ce894778498ae4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>因为在其内部无限递归，导致栈溢出</p>
<p>我们使用一组 Map 来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，我们首先去 Map 中找</p>
<ul>
<li>  检查<code>map</code>中有无克隆过的对象</li>
<li>  有 - 直接返回</li>
<li>  没有 - 将当前对象作为<code>key</code>，克隆对象作为<code>value</code>进行存储</li>
<li>  继续克隆</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">let</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> (map.<span class="title function_">get</span>(target)) &#123;</span><br><span class="line">			<span class="keyword">return</span> map.<span class="title function_">get</span>(target)</span><br><span class="line">		&#125;</span><br><span class="line">		map.<span class="title function_">set</span>(target, cloneTarget)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">			cloneTarget[key] = <span class="title function_">clone</span>(target[key], map)</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(target, <span class="string">&#x27;:&#x27;</span>, map.<span class="title function_">get</span>(target))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cloneTarget</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> target</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中需要注意的是，我们将 target 和 cloneTarget 通过链接， 下面对 cloneTarget 的改变是会同步更新的，因为这里也相当于将他们的地址进行链接</p>
<p><strong>最后 cloneTarget 的 target 属性也会指向 cloneTarget 的地址，造成循环引用</strong></p>
<p>对于上面的输出，我们会有下面的过程</p>
<p><img src="C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230212110910532.png" alt="image-20230212110910532"></p>
<h1 id="根据-0-1-0-2-0-3，讲讲-IEEE-754-，如何让其相等？"><a href="#根据-0-1-0-2-0-3，讲讲-IEEE-754-，如何让其相等？" class="headerlink" title="根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？"></a>根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？</h1><h2 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h2><p>JavaScript 的数字是 IEEE-754 标准存储的双精度浮点数类型。双精度浮点数总共有 64 位（bit），第一位用于表示符号，接着十一位用于表示阶码，剩余的五十二位用于表示尾数。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/453cabd88adc477a9f6548fca7e35268~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e446a5d6d9784281b1dfd43096510c7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>同时， 在阶码运算时需要在二进制运算的基础上，手动减去 1023 才是真正表达的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01111111111</span> <span class="comment">// 0</span></span><br><span class="line"><span class="number">10000000000</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">11111111110</span> <span class="comment">// 1023</span></span><br><span class="line"><span class="number">00000000000</span> <span class="comment">// -1023</span></span><br></pre></td></tr></table></figure>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul>
<li>  <strong>进制转换</strong>: 在将 0.1、0.2 转换为二进制时，他们的尾数是无限循环的， 但是最多只能存储 53 位有效数字（包括默认的 1）， 所以会造成进度的损失</li>
<li>  <strong>对阶运算</strong>: 由于指数位数的不太，运算时阶数小的需要根据阶差右移，相加后根据 0 舍 1 入， 尾数位移时可能会发生数丢失的情况，影响精度。</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol>
<li>转换为整数运算</li>
<li>使用 <code>Number.EPSILON</code> 误差范围</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEqual</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(a - b) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEqual</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Number.EPSILON</code> 的实质是一个可以接受的最小误差范围，一般来说为 <code>Math.pow(2, -52)</code> 。</p>
<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><ul>
<li>  每一个<strong>函数</strong>都有一个<code>prototype</code> 属性， 这个属性指向 调用该构造函数而创建的<strong>实例</strong>的原型</li>
<li>  每一个 JavaScript 对象（null 除外），在创建的时候就会与之关联另一个对象，这个对象就是原型，每一个对象都会从原型”继承”属性</li>
</ul>
<p><img src="https://camo.githubusercontent.com/02789d6806b75d34b2017021f58efa3aa7a2ee6be8a0c05fb3293438884b9ec0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065312e706e67" alt="构造函数和实例原型的关系图"></p>
<ul>
<li>  每一个 JavaScript 对象（null）除外，都具有一个 <code>__proto__</code> 属性，这个属性指向该对象的原型</li>
</ul>
<p><img src="https://camo.githubusercontent.com/3dde335faa15d03ffe3b907f6e5c2b5f4d2183caa4c47ac7486794bc407f663c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065322e706e67" alt="实例与实例原型的关系图"></p>
<ul>
<li>  每一个原型都有一个 <code>constructor</code> 属性，指向与之相关联的构造函数</li>
</ul>
<p><img src="https://camo.githubusercontent.com/0aaf005afda83d4e2fdd2bbe523df228b567a091317a2154181771b2706ea2ef/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065332e706e67" alt="实例原型与构造函数的关系图"></p>
<ul>
<li>  当实例读取属性，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就查找原型的原型，直到最顶层</li>
</ul>
<p><img src="https://camo.githubusercontent.com/ad0ee0e2594c1ac471bbb42321963c130f4fe1ef9ec70389c8ced54544d3fd6c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065342e706e67" alt="原型的原型关系图"></p>
<ul>
<li>  <code>Object.prototype</code> 的原型就是 null, 所有可以说 <code>Object.prototype</code> 没有原型</li>
</ul>
<p><img src="https://camo.githubusercontent.com/9a69b0f03116884e80cf566f8542cf014a4dd043fce6ce030d615040461f4e5a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065352e706e67" alt="原型链示意图"></p>
<ul>
<li>  原型链就是 由相互关联的原型组成的链状结构</li>
</ul>
<h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><ul>
<li><p>  JavaScript 分为<strong>函数对象</strong>和<strong>普通对象</strong>，每个对象都有<code>__proto__</code>属性，但是只有函数对象才有<code>prototype</code>属性</p>
</li>
<li><p>  Object、Function 都是 js 内置的<strong>函数</strong>, 类似的还有我们常用到的 Array、RegExp、Date、Boolean、Number、String</p>
</li>
</ul>
<p>于是我们有下图</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a61ca07672a45d3aecf382100cc9719~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<p>理解一下，然后自己能通过代码画出来这个，就没问题了</p>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>将下面四篇文章仔细研读</p>
<ul>
<li>  <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/4">JavaScript 深入之执行上下文栈</a>；</li>
<li>  <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/5">JavaScript 深入之变量对象</a>；</li>
<li>  <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/6">JavaScript 深入之作用域链</a>；</li>
<li>  <a href="https://link.juejin.cn/?target=https://www.ruanyifeng.com/blog/2018/06/javascript-this.html">JavaScript 的 this 原理</a></li>
<li>  <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/8">JavaScript 深入之执行上下文</a>。</li>
</ul>
<p>总结：当 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li><p>  变量对象（Variable object，VO）</p>
</li>
<li><p>  作用域链（Scope chain）</p>
</li>
<li><p>  this</p>
</li>
</ul>
<h1 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h1><ul>
<li><p>  作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。换句话说，作用域决定了代码区块中变量和其他资源的可见性。（全局作用域、函数作用域、块级作用域）</p>
</li>
<li><p>  作用域链：从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。（由多个执行上下文的<strong>变量对象</strong>构成的链表就叫做作用域链，可以同时将 执行上下文 看了再仔细理解）</p>
</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>  是指程序源代码中定义变量的区域</li>
<li>  确定当前执行代码对变量的访问权限</li>
<li>  JavaScript 采用的是词法作用域（也就是 静态作用域）</li>
</ul>
<h2 id="静态作用域-与-动态作用域"><a href="#静态作用域-与-动态作用域" class="headerlink" title="静态作用域 与 动态作用域"></a>静态作用域 与 动态作用域</h2><ul>
<li>  静态作用域</li>
</ul>
<p>函数的作用域在函数定义的时候就已经决定了</p>
<ul>
<li>  动态作用域</li>
</ul>
<p>函数的作用域是在函数调用的时候采决定的</p>
<p>下面有个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> value = <span class="number">2</span></span><br><span class="line">	<span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br></pre></td></tr></table></figure>

<p>结果会是 <code>1</code></p>
<ul>
<li>  静态作用域的分析过程</li>
</ul>
<p>执行 <code>foo</code> 函数，查找函数内部是否有局部变量 <code>value</code> ，如果没有，就根据<strong>书写的位置</strong>，查找上面一层的代码， 即 <code>value = 1</code></p>
<ul>
<li>  动态作用域的分析过程</li>
</ul>
<p>执行 <code>foo</code> 函数， 查找函数内部是否有局部变量 <code>value</code>， 如果没有， 就从调用函数的作用域， 即 <code>bar</code> 函数内部查找 <code>value</code> 变量， 即 <code>value = 2</code></p>
<p>下面有个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> scope</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkscope</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> scope</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkscope</span>()()</span><br></pre></td></tr></table></figure>

<p>两者的结果都是 <code>local scope</code></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><ol>
<li>函数声明</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数表达式</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Function 构造函数 (几乎无人使用)， 这里不做叙述</li>
</ol>
<p>值得注意的是： JavaScript 在任何代码执行之前，都会先读取函数声明，并在执行上下文中生成函数定义，而函数表达式需要等到代码执行到所在位置，才会在执行上下文中生成函数定义</p>
<p>所以上述两段代码中，第一段可以正常运行，称为<strong>函数声明提升</strong></p>
<h2 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h2><ul>
<li>  name 属性</li>
</ul>
<p>将返回函数的名字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">f1.<span class="property">name</span> <span class="comment">//f1</span></span><br></pre></td></tr></table></figure>

<p>如果是通过变量赋值定义的函数， 那么 <code>name</code> 属性将返回变量名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">f2.<span class="property">name</span> <span class="comment">// &quot;f2&quot;</span></span><br></pre></td></tr></table></figure>

<p>但是，如果变量的值是一个具名函数，而不是上面这种匿名函数， <code>name</code>属性返回<code>function</code> 关键字之后的那个函数名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">function</span> <span class="title function_">myName</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">f3.<span class="property">name</span> <span class="comment">// &#x27;myName&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果函数没有名称，会显示为空字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="function">() =&gt;</span> &#123;&#125;.<span class="property">name</span>)</span><br></pre></td></tr></table></figure>

<p>如果是使用 <code>Function</code> 构造函数创建的，则会标识成 <code>anonymous</code>。</p>
<p>如果函数是一个获取函数、设置函数，或者使用了 <code>bind()</code> 进行实例化，那么标识符会在结果前面加上一个前缀：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">bind</span>(<span class="literal">null</span>).<span class="property">name</span>) <span class="comment">// bound foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">years</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">year</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">years</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">set</span> <span class="title function_">year</span>(<span class="params">newYear</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">years</span> = newYear</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> propertyDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;year&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">get</span>.<span class="property">name</span>) <span class="comment">// get year</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">set</span>.<span class="property">name</span>) <span class="comment">// set year</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  length 属性</li>
</ul>
<p>函数的<code>length</code>属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b</span>) &#123;&#125;</span><br><span class="line">f.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了空函数<code>f</code>，它的<code>length</code>属性就是定义时的参数个数。不管调用时输入了多少个参数，<code>length</code>属性始终等于 2。</p>
<ul>
<li>  toString()</li>
</ul>
<p>函数的<code>toString()</code>方法返回一个字符串，内容是函数的源码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">a</span>()</span><br><span class="line">	<span class="title function_">b</span>()</span><br><span class="line">	<span class="title function_">c</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// function f() &#123;</span></span><br><span class="line"><span class="comment">//  a();</span></span><br><span class="line"><span class="comment">//  b();</span></span><br><span class="line"><span class="comment">//  c();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>对于那些原生的函数，<code>toString()</code>方法返回<code>function ()&#123;[native code]&#125;</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">sqrt</span>.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// &quot;function sqrt() &#123; [native code] &#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Math.sqrt()</code>是 JavaScript 引擎提供的原生函数，<code>toString()</code>方法就返回原生代码的提示。</p>
<p>函数内部的注释也可以返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// &quot;function f()&#123;/*</span></span><br><span class="line"><span class="comment">//   这是一个</span></span><br><span class="line"><span class="comment">//   多行注释</span></span><br><span class="line"><span class="comment">// */&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>如果函数定义了两个参数，但是运行时无论提供多少个参数，JavaScript 都不会报错。而省略的参数的值就变为 <code>undefined</code>。</p>
<p>但是没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入 <code>undefined</code>。</p>
<ul>
<li>  同名参数</li>
</ul>
<p>如果有同名的参数，则取最后出现的那个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, a</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>即使后面的<code>a</code>没有值或被省略，也是以其为准。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, a</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>调用函数<code>f()</code>的时候，没有提供第二个参数，<code>a</code>的取值就变成了<code>undefined</code>。这时，如果要获得第一个<code>a</code>的值，可以使用<code>arguments</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, a</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h2><p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">one</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>])</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>正常模式下，<code>arguments</code>对象可以在运行时修改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">	<span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">	<span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系。也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">	<span class="string">&#x27;use strict&#x27;</span> <span class="comment">// 开启严格模式</span></span><br><span class="line">	<span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">	<span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： 箭头函数不存在 arguments 对象</p>
</blockquote>
<ul>
<li>  与数组的关系</li>
</ul>
<p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</p>
<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> args = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	args.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  callee 属性</li>
</ul>
<p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span> === f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = <span class="number">5</span></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">1</span> <span class="comment">// error</span></span><br><span class="line">	<span class="keyword">const</span> x = <span class="number">2</span> <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用参数默认值时，函数不能有同名参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, x, y</span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, x, y = <span class="number">1</span></span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure>

<p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  参数默认值的位置</li>
</ul>
<p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入<code>undefined</code>。</p>
<h2 id="reset-参数"><a href="#reset-参数" class="headerlink" title="reset 参数"></a>reset 参数</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">		sum += val</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>实际上 reset 参数也是用了 扩展运算符</p>
<h2 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul>
<li>  在标准函数中，this 引用的是<strong>把函数当作方法调用的上下文对象</strong> （可变的）</li>
<li>  在箭头函数中，this 引用的是<strong>定义箭头函数的上下文</strong> （固定的）</li>
</ul>
<h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><ul>
<li>  函数的 caller 属性引用的是调用当前函数的函数，如果是在全局作用域中国调用，则该属性为 null。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">B</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(B.<span class="property">caller</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">A</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ƒ A() &#123;</span></span><br><span class="line"><span class="comment">//     B()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><ul>
<li>  当函数如果是<strong>作为构造函数调用</strong>，那么在该函数中的 new.target 指向该构造函数；如果函数没有使用 new 关键字，那么 new.target 的值变为 undefined。我们可以使用该值来判断函数是否作为构造函数调用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&#x27;People must be instantiated using &quot;new&quot;&#x27;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;People instantiated using &quot;new&quot;&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>参考博客： <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/9">JavaScript 深入之闭包</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">//error</span></span><br><span class="line">我们无法获得函数内部的局部变量</span><br></pre></td></tr></table></figure>

<p>但我们可以通过在函数内部定义一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> z = <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">z</span>()) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>闭包就是上面的<code>c</code> 函数, 闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>MDN 对闭包的定义为：</p>
<blockquote>
<p>闭包是指那些能够访问自由变量的函数</p>
</blockquote>
<p>那什么是自由变量呢？</p>
<blockquote>
<p>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。</p>
</blockquote>
<p>由此，我们可以看出闭包共有两部分组成：</p>
<blockquote>
<p>闭包 = 函数 + 函数能够访问的自由变量</p>
</blockquote>
<p>也可以简单理解为 定义在函数内部的函数</p>
<p>ECMAScript 中，闭包指的是：</p>
<ol>
<li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>
<li>从实践角度：以下函数才算是闭包：<ol>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
</li>
</ol>
<p>在某个内部函数的执行上下文创建时，会将父级函数的<strong>活动对象</strong>加到内部函数的 <code>[[scope]]</code> 中，形成作用域链，所以即使父级函数的执行上下文销毁（即执行上下文栈弹出父级函数的执行上下文），但是因为其<strong>活动对象</strong>还是实际存储在内存中可被内部函数访问到的，从而实现了闭包。</p>
<h2 id="call、apply、bind-手写"><a href="#call、apply、bind-手写" class="headerlink" title="call、apply、bind 手写"></a>call、apply、bind 手写</h2><ul>
<li>  call</li>
</ul>
<blockquote>
<p><strong><code>call()</code></strong> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>.<span class="title function_">call</span>(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  如果我们使用 call 并指定了第一个参数，那么 this 将会绑定到该对象上</p>
</li>
<li><p>  如果没指定，那么 this 将会绑定为全局对象，在严格模式下，this 的值将会是 undefined</p>
</li>
<li><p>  手写</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property">proptotype</span>.<span class="title function_">mycall</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        thorw <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Type error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="variable language_">window</span> <span class="comment">//如果没传入，就让他指向window</span></span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 将被调用的方法设置为 context 的属性</span></span><br><span class="line">  	<span class="comment">// this 即为我们要调用的方法</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">let</span> result = constext.<span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  apply</li>
</ul>
<blockquote>
<p><code>apply()</code> 方法调用一个具有给定 <code>this</code> 值的函数，以及以一个数组（或一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">apply</span>(thisArg)</span><br><span class="line"><span class="title function_">apply</span>(thisArg, argsArray)</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 该方法的语法和作用与 <code>call()</code>方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是<strong>一个参数列表</strong>，而 <code>apply()</code> 方法接受的是<strong>一个包含多个参数的数组</strong>。</p>
<ul>
<li>  手写</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property">proptotype</span>.<span class="title function_">mycall</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        thorw <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Type error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="variable language_">window</span> <span class="comment">//如果没传入，就让他指向window</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//这里判断下是否传入了参数数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  bind</li>
</ul>
<p><strong><code>bind()</code></strong> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> = <span class="keyword">function</span>.<span class="title function_">bind</span>(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>

<p>参考博客： <a href="https://link.juejin.cn/?target=https://github.com/sisterAn/JavaScript-Algorithms/issues/81">解析 bind 原理，并手写 bind 实现</a>。</p>
<ul>
<li>  手写</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Funciton</span>.<span class="property">proptotype</span>.<span class="title function_">bind</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        thorw <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取参数</span></span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//记录调用的函数</span></span><br><span class="line">    fn = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">//需要返回一个函数</span></span><br><span class="line">    <span class="comment">//需要注意的是，如果将bind返回的函数视为构造函数，即使用new，那我们提供的 this 的值应当被忽略，从而指向实例,我们使用 instanceof 来判断</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>( <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context, args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h3><p>《JavaScript 高级程序设计（第 4 版）》中指出：「ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如 <code>[[Enumerable]]</code>。」</p>
<p>属性分为两种： <strong>数据属性</strong> 和 <strong>访问器属性</strong></p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性由 4 个特性来描述它们的行为</p>
<ul>
<li>  <code>[[Configurable]]</code>：表示属性是否可以通过 <code>delete</code> 删除、是否可以修改该属性的特性，以及是否可以将该数据属性修改为访问器属性。默认值为 <code>true</code>。</li>
</ul>
<blockquote>
<p>注意：</p>
<ol>
<li>严格模式下，如果该特性为 <code>false</code> 但是仍然使用 <code>delete</code> 方法删除属性，将会抛出错误。</li>
<li>一个属性被定义为不可配置后，将无法再变回可配置。</li>
<li>此处即下面所说的默认值，指的是通过字面量形式指定属性的值时，该特性的默认值；如果通过 <code>Object.defineProperty()</code> 方法添加新的属性，那么该属性的特性默认值为 <code>false</code>。</li>
</ol>
</blockquote>
<ul>
<li>  <code>[[Enumerable]]</code>：表示属性是否可枚举。具体的，<code>[[Enumerable]</code> 特性表示该属性是否可以通过 <code>for-in</code> 循环返回。默认值为 <code>true</code>。</li>
<li>  <code>[[Writable]]</code>：表示属性的值是否可以被修改。默认值为 <code>true</code>。</li>
</ul>
<blockquote>
<p>注意：严格模式下修改只读属性将会抛出错误。</p>
</blockquote>
<ul>
<li>  <code>[[Value]]</code>：表示属性实际的值。默认值为 <code>undefined</code>。</li>
</ul>
<p>如果想要修改属性的数据特性，必须使用 <code>Object.defineProperty()</code> 或 <code>Object.defineProperties()</code> 方法。<code>Object.defineProperty()</code> 接收 3 个参数：对象、属性名称和描述特性的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// Yucohny</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">value</span>: <span class="string">&#x27;Yucoh&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// Yucoh</span></span><br></pre></td></tr></table></figure>

<p>上面提到，如果使用 <code>Object.defineProperty()</code> 方法添加新属性，那么新属性的特性默认值为 <code>false</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">value</span>: <span class="number">20</span>,</span><br><span class="line">&#125;)</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">19</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>)</span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，尽管我们尝试修改 <code>age</code> 为 <code>19</code>，但是由于 <code>age</code> 属性通过 <code>Object.defineProperty()</code> 指定时并未指定 <code>[[Writable]]</code> 特性的值，因此 <code>[[Writable]]</code> 特性取默认值 <code>false</code>，即不可修改。</p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>在一个对象中，如果在某种情况下，我们不希望可以通过对象点属性名的方法直接修改属性值，我们<strong>希望可以通过一次“过滤”之后</strong>，如果传入的值符合要求，才能改变对象属性的值，因此，这就是访问器的作用。</p>
<p>访问器属性包含下列 4 个特性：</p>
<ul>
<li>  <code>[[Configurable]]</code>：表示属性是否可以通过 <code>delete</code> 删除并重新定义，是否可以修改它的特性，以及是否可以把它修改为数据属性。默认值为 <code>false</code>。</li>
<li>  <code>[[Enumerable]]</code>：表示属性是否可以通过 <code>for-in</code> 循环返回。默认值为 <code>false</code>。</li>
<li>  <code>[[Get]]</code>：获取函数，在读取属性时调用，默认值为 <code>undefined</code>。</li>
<li>  <code>[[Set]]</code>：设置函数，在写入属性是调用，默认值为 <code>undefined</code>。</li>
</ul>
<p>访问器属性是不能直接定义的，必须使用 <code>Object.defineProperty()</code> 或 <code>Object.defineProperties()</code> 定义，下面是一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    <span class="attr">year_</span>: <span class="number">2017</span>, <span class="comment">// year_ 中的下划线用来表示该属性并不希望在对象方法的外部被访问</span></span><br><span class="line">    <span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">year_</span> = newValue</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2017</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.<span class="property">year</span> = <span class="number">2018</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">edition</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>访问器属性的典型使用场景便是和上面一样，即设置一个属性值会导致一些其他变化发生。</p>
<p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只定义设置函数的属性是不能读取的，非严格模式下读取会返回 <code>undefined</code>，严格模式下会抛出错误。</p>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p><code>Object.defineProperties()</code> 方法可以一次性定义多个属性的特性。该方法接收两个参数：对象和一个描述符对象，描述符对象的属性与要添加或修改的属性一一对应，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book, &#123;</span><br><span class="line">	<span class="attr">year_</span>: &#123;</span><br><span class="line">		<span class="attr">value</span>: <span class="number">2017</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">edition</span>: &#123;</span><br><span class="line">		<span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>使用 <code>Object.getOwnPropertyDescriptor()</code> 方法可以获取指定属性的特性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于数据属性和访问器属性分别包含对应的特性作为属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">value</span>: <span class="string">&#x27;Yucoh&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   value: &#x27;Yucoh&#x27;,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>ES 2017 新增了 <code>Object.getOwnPropertyDescriptors()</code> 方法，并接收一个对象作为参数，该方法将会在每个属性上调用 <code>Object.getOwnPropertyDescriptor()</code> 并在一个新对象中返回它们：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">	<span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj))</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   name: &#123;</span></span><br><span class="line"><span class="comment">//     value: &#x27;Yucohny&#x27;,</span></span><br><span class="line"><span class="comment">//     writable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   age: &#123;</span></span><br><span class="line"><span class="comment">//     get: [Function: get],</span></span><br><span class="line"><span class="comment">//     set: undefined,</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     configurable: false</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h3><h5 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h5><p>在给对象添加变量的时候，经常会出现属性名与变量名一致的情况，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>: name,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 <code>ReferenceError</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	name,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h5><p>如果想要使用变量值为属性，那么必须先声明对象，然后使用中括号语法来添加属性。即，不能在对象字面量中直接动态命名属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line">person[name] = <span class="number">19</span></span><br></pre></td></tr></table></figure>

<p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为表达式而不是字符串来求值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeUniqueKey</span>(<span class="params">key</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>_&#123;count++&#125;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	[<span class="title function_">makeUniqueKey</span>(nameKey)]: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">	[<span class="title function_">makeUniqueKey</span>(ageKey)]: <span class="number">19</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>其本身是一个普通的函数，但有着自己的特征和用法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Vehicle</code>就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。</p>
<p>构造函数的特点有两个。</p>
<ul>
<li>  函数体内部使用了<code>this</code>关键字，代表了所要生成的对象实例。</li>
<li>  生成对象的时候，必须使用<code>new</code>命令</li>
</ul>
<h3 id="无-new-命令调用构造函数"><a href="#无-new-命令调用构造函数" class="headerlink" title="无 new 命令调用构造函数"></a>无 new 命令调用构造函数</h3><p>在没有<code>new</code> 命令的情况下调用构造函数，会使得该构造函数变成普通函数，同时函数内部的<code>this</code>将会指向全局对象</p>
<p>所以我们必须保证构造函数与<code>new</code>命令一起使用</p>
<ol>
<li>构造函数开启严格模式</li>
</ol>
<p>严格模式下，没有<code>new</code>命令调用构造函数将会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="title class_">Vehicle</span>()</span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;price&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过判断构造函数中的 <code>this</code> 是否是它的实例</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Vehicle</span>()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="title class_">Vehicle</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v.<span class="property">price</span>) <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>同样的，我们也可以使用 <code>new.target</code>来进行判断</li>
</ol>
<p>如果是通过 <code>new</code>命令调用，那么 <code>new.target</code>将会指向当前函数，否则为<code>undefined</code></p>
<h3 id="手写-new"><a href="#手写-new" class="headerlink" title="手写 new"></a>手写 new</h3><ol>
<li>首先创一个新的空对象。</li>
<li>根据原型链，设置空对象的 <code>__proto__</code> 为构造函数的 <code>prototype</code> 。</li>
<li>构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</li>
<li>判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">new</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">    obj.<span class="property">__proto__</span> = context.<span class="property">proptotype</span></span><br><span class="line">    <span class="keyword">const</span> res = context.<span class="title function_">apply</span>(obj, [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;Object&#x27;</span> ? res || obj : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>类有两种方式定义： 类声明和类表达式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125; 类声明</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">class</span>&#123;&#125;  类表达式</span><br></pre></td></tr></table></figure>

<ul>
<li>  类声明不会提升</li>
<li>  默认情况下，类中的代码都启用了<strong>严格模式</strong></li>
</ul>
<p>类表达式的名称是可选的, 可以通过<code>name</code>属性获取类表达式的名称，但是不能在类作用域外部访问类表达式的名称（这里的 VehicleName）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> <span class="title class_">VehicleName</span> &#123;</span><br><span class="line">	<span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vehicle</span>.<span class="property">name</span>, <span class="title class_">VehicleName</span>.<span class="property">name</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>()</span><br><span class="line"></span><br><span class="line">v.<span class="title function_">identify</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vehicle</span>.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">VehicleName</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// VehicleName VehicleName</span></span><br><span class="line"><span class="comment">// VehicleName</span></span><br><span class="line"><span class="comment">// ReferenceError: ObjName is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>该关键字用于在类中创建类的构造函数， 当使用 <code>new</code> 命令创建新的实例，会调用<code>constructor</code></p>
<p>当使用 <code>new</code> 命令通过类实例化对象时，可以传入参数，对应的参数将被传入类构造函数中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">flag</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Vehicle&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vehicle</span></span><br></pre></td></tr></table></figure>

<p>如果没有使用<code>new</code>， 将会报错</p>
<blockquote>
<p>类构造函数和构造函数</p>
<p>没有使用 new 执行，构造函数会正常执行，只是其中的<code>this</code>指向会出现问题</p>
</blockquote>
<p>类也具有 <code>prototype</code>属性，且这个原型具有<code>constructor</code>属性指向类本身</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vehicle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Vehicle</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="实例属性与方法"><a href="#实例属性与方法" class="headerlink" title="实例属性与方法"></a>实例属性与方法</h3><p>我们可以在构造函数内部添加实例属性与方法，<code>this</code>指向为新创建的实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasPrototypeProperty = <span class="keyword">function</span> (<span class="params">obj, property</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> !obj.<span class="title function_">hasOwnProperty</span>(property) &amp;&amp; property <span class="keyword">in</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是判断该属性是否在实例的原型上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>(<span class="string">&#x27;Yucohny&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(v, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>实例属性的新写法：</p>
<p>实例属性现在除了可以定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类内部的最顶层。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">	_count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting the current value!&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_count</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">_count</span>++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h3><p>在类块中定义的方法为原型方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasPrototypeProperty = <span class="keyword">function</span> (<span class="params">obj, property</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> !obj.<span class="title function_">hasOwnProperty</span>(property) &amp;&amp; property <span class="keyword">in</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">	<span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>(<span class="string">&#x27;Yucohny&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v.<span class="title function_">getName</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vehicle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">getName</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(v, <span class="string">&#x27;getName&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Yucohny</span></span><br><span class="line"><span class="comment">// Yucohny</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="静态方法与静态属性"><a href="#静态方法与静态属性" class="headerlink" title="静态方法与静态属性"></a>静态方法与静态属性</h3><p>在其前面添加 <code>static</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> prop = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vehicle</span>.<span class="title function_">print</span>()</span><br><span class="line"><span class="title class_">Vehicle</span>.<span class="property">prop</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//hello</span></span><br></pre></td></tr></table></figure>

<h3 id="getter-amp-setter"><a href="#getter-amp-setter" class="headerlink" title="getter &amp; setter"></a>getter &amp; setter</h3><p>在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">prop</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">set</span> <span class="title function_">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter: &#x27;</span> + value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br><span class="line"></span><br><span class="line">inst.<span class="property">prop</span> = <span class="number">123</span></span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.<span class="property">prop</span></span><br><span class="line"><span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h3><p>ES6 类通过 <code>extends</code> 关键字实现继承。一个类可以继承任何拥有构造器属性与原型的对象，因此一个类不仅可以继承一个类，也可以继承普通的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Person</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  super</li>
</ul>
<p>子类可以通过 <code>super</code> 关键字引用父类。但是要注意，这个关键字只能在子类构造函数、实例方法与静态方法内部使用。在子类构造函数中，<code>super()</code> 可以直接调用父类构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Vehicle&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">super</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vehicle</span></span><br></pre></td></tr></table></figure>

<p><code>super</code> 的一些注意事项：</p>
<ul>
<li>  <code>super</code> 只能在子类构造函数、实例方法与静态方法内部使用；</li>
<li>  不能单独引用 <code>super</code> 关键字，要么用它调用构造函数，要么用它引用静态方法；</li>
<li>  调用 <code>super()</code> 会调用父类构造函数，并将返回的实例赋值给 <code>this</code> 子类实例；</li>
</ul>
<blockquote>
<p>因此，如果在子类中显式定义了构造函数，则要么必须在其中调用 <code>super()</code>，要么必须在其中返回一个对象。</p>
</blockquote>
<ul>
<li>  如果没有在子类中定义类构造函数，那么在实例化子类时会自动调用 <code>super()</code>，并将自动传入所有传给子类构造函数的参数；</li>
<li>  在子类构造函数中，不能在调用 <code>super()</code> 之前引用 <code>this</code>。</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类指的是可供其他类继承，但是本事并不会被实例化。JavaScript 中没有专门支持抽象类的语法，但是可以通过 <code>new.target</code> 实现。</p>
<p><code>new.target</code> 保存了通过 <code>new</code> 关键字调用的类或者函数，可以通过在实例化时检测 <code>new.target</code> 是不是抽象类来阻止抽象类的实例化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Vehicle = class &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        if (new.target === Vehicle) &#123;</span><br><span class="line">            throw new Error(&#x27;This class cannot be directly instantiated&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const v = new Vehicle()</span><br><span class="line"></span><br><span class="line">// Error: This class cannot be directly instantiated</span><br></pre></td></tr></table></figure>

<p>由于原型方法在调用类构造函数前就已经存在，因此可以通过抽象类检查子类是否定义了某个方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Vehicle</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;This class cannot be directly instantiated&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getName</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Inheriting class must define getName()&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Inheriting class must define getName()</span></span><br></pre></td></tr></table></figure>

<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>js 是一个单线程语言，意味着他只有一个调用栈，同一时刻只能做一件事</p>
<p>如果我们所有的程序都是同步的，那么很有可能造成调用栈的阻塞，所以我们使用异步回调</p>
<p>js 同一时刻只能做一件事，但是浏览器给我们提供了其他的东西： Web APIs, 你可以对应地创建一些线程，但你不能直接访问，只能通过某些方式进行调用，浏览器对这种调用进行响应</p>
<h2 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h2><ul>
<li>  同步任务</li>
</ul>
<p>指直接在主线程上排队执行的任务</p>
<p>同步任务的执行，按照代码顺序和调用顺序，直接进入调用栈中并执行，执行结束后就移除调用栈。</p>
<ul>
<li>  异步任务</li>
</ul>
<p>指不进入主线程，进入任务队列的任务</p>
<p>异步任务的执行，首先它依旧会进入调用栈中，然后发起调用，然后解释器会将其<strong>响应回调任务</strong>放入一个<strong>任务队列</strong>，紧接着调用栈会将这个任务移除。当主线程清空后，即所有同步任务结束后，解释器会读取任务队列，并依次将<strong>已完成的异步任务</strong>加入调用栈中并执行。</p>
<p>重点就是异步任务<strong>不是直接</strong>进入任务队列的。</p>
<h2 id="任务队列与事件循环"><a href="#任务队列与事件循环" class="headerlink" title="任务队列与事件循环"></a>任务队列与事件循环</h2><ul>
<li>  任务队列</li>
</ul>
<p>WebAPIs 不能直接进行你的调用栈中， 所以引入了 callback queue(task queue) 回调队列（任务队列）， webaips 结束后就把回调函数送入队列中。</p>
<p>主线程首先会将调用栈中的同步任务执行完成，当同步任务<strong>清空</strong>时，就会从队首检查任务队列中的异步任务，放入调用栈中执行，执行结束后，主线程将重复此过程，直到所有的任务执行结束。这是早期的<strong>事件循环</strong></p>
<p>一个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">cb</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cb&#x27;</span>) <span class="comment">// cb 即 callback</span></span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Bye&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e15fc609aa84eac973c5b8ff163c11c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="屏幕录制 2021-07-19 15.01.09.gif"></p>
<p>我们有如下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">cb</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;there&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;JS&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>对于第二行地定时器，我们将它的第二个参数设置为 0， 实际上，我们设置了定时器，他确实在 webapi 中 马上就进入了回调队列中，但是我们必须要等到 stack 中为空，才能将对调队列中的函数放进 stack 中，所以 setTimeout 设置为 0， 就是想让代码在 栈底执行，或者是为了等到栈空之后再执行</p>
<p>所以说，我们给 setTimeout 设置地时间，实际上并不是指多久之后执行，而是最快要多久之后执行，因为我们不仅要在 callback queue 中排队，也要等到栈空之后才能进入 stack</p>
<ul>
<li>  宏任务与微任务</li>
</ul>
<p>后面又引入了宏任务与微任务，他们都是异步任务，但是执行时机有所不同</p>
<p>进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。如果在执行宏任务的同时又产生了微任务，这个微任务会被立即添加到微任务队列中，这就是<strong>事件循环</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdcea13361a1ec~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p>宏任务：DOM 渲染后触发，如 <code>setTimeout</code> 、<code>setInterval</code> 、<code>DOM 事件</code> 、<code>script</code> 。</p>
<p>微任务：DOM 渲染前触发，如 <code>Promise.then</code> 、<code>MutationObserver</code> 、Node 环境下的 <code>process.nextTick</code> 。</p>
<ul>
<li><p>  事件循环时 JavaScript 的执行机制</p>
</li>
<li><p>  推荐文章： <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903512845860872">这一次，彻底弄懂 JavaScript 执行机制</a>。</p>
</li>
<li><p>  如果意犹未尽，不如再读下这篇非常详细带有大量动图的文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6969028296893792286#comment">做一些动图，学习一下 EventLoop</a>。</p>
</li>
<li><p>  想了解事件循环和页面渲染之间关系的又可以再阅读这篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904165462769678">深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）</a>。</p>
</li>
</ul>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><p>可以指定一个函数在 至少 多少 毫秒 后执行（由于时间循环的存在，这个时间可能不会准时），他会返回一个编号，可以利用该编号清除这个定时器</p>
<p><code>setTimeout()</code> 通常接收两个参数，第一个参数一个函数或者一段字符串形式的代码，第二个参数是要推迟的时间。第二个参数如果省略，则默认为 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&#x27;console.log(2)&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>setTimeout()</code> 中的回调函数具有参数，可以直接跟在 <code>setTimeout()</code> 后面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(</span><br><span class="line">	<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(a + b)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="number">1000</span>,</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	<span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><p>与 <code>setTimeout</code> 用法一直，不过他是指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p>
<p>它指定的是 开始执行 的最小间隔，并不考虑每次任务的执行时间， 所有，如果我们指定 <code>setInterval</code> 的时间间隔为 <code>1000</code>， 而每次执行需要 5ms， 那么第一次执行结束后 95ms ，第二次循环就会开始， 亦然，如果每次执行需要 105ms， 那么第二次的任务在第一次执行结束就会立即开始</p>
<h3 id="清除定时器"><a href="#清除定时器" class="headerlink" title="清除定时器"></a>清除定时器</h3><p>利用两者返回的编号，我们使用<code>clearTimeout()</code> 和 <code>clearInterval()</code> 函数，就可以取消对应的定时器。</p>
<h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h2><p>指的是在事件被触发若干秒后再执行回调，如果在这若干秒内触发相同事件，则<strong>重新计时。</strong></p>
<ul>
<li>  搜索框搜索输入</li>
<li>  文本编辑器的实时保存</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;ipt&quot;</span> <span class="attr">onkeyup</span>=<span class="string">&quot;buttonChange()&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">let</span> timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">function</span> <span class="title function_">buttonChange</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="keyword">const</span> ipt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ipt&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">			<span class="keyword">if</span> (timer !== <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">				<span class="built_in">clearTimeout</span>(timer)</span></span><br><span class="line"><span class="language-javascript">			&#125;</span></span><br><span class="line"><span class="language-javascript">			timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">				<span class="variable language_">console</span>.<span class="title function_">log</span>(ipt.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">			&#125;, <span class="number">2000</span>)</span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>建议看看这个： <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/22">JavaScript 专题之跟着 underscore 学防抖 </a></p>
<h2 id="防抖-throttle"><a href="#防抖-throttle" class="headerlink" title="防抖 throttle"></a>防抖 throttle</h2><p>指的是在一个单位时间内，只能触发一次事件。如果在这个单位时间内多次触发，则<strong>仅有</strong>一次生效。不要打断</p>
<ul>
<li>  高频事件（快速点击，鼠标滑动，resize 事件）</li>
<li>  下拉加载</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">		<span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px; background-color: red;&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">id</span>=<span class="string">&quot;div&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">onclick</span>=<span class="string">&quot;onClick()&quot;</span></span></span><br><span class="line"><span class="tag">	/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">let</span> timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">function</span> <span class="title function_">onClick</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">			<span class="keyword">if</span> (timer !== <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">				<span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">			&#125;</span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;zzz&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">			timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">				timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">			&#125;, <span class="number">2000</span>)</span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>从语义上来说，<code>Promise</code> 是一个容器，里面保存着某个未来才会结束的事件的结果。</p>
<p>从语法上来说，<code>Promise</code> 是一个对象，它可以获取异步操作的消息。</p>
<p><code>Promise</code> 对象有以下两个特点：</p>
<ol>
<li>无法通过外界对 <code>Promise</code> 对象造成影响。<code>Promise</code> 对象代表一个异步操作，有 3 种状态：进行中 <code>pending</code>、已成功 <code>fulfilled</code>（也称为 <code>resolved</code>） 和已失败 <code>rejected</code>。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
</ol>
<blockquote>
<p>有一个地方值得注意：对于事件而言，在错过事件发生之后再去监听，将不会得到结果；而 <code>Promise</code> 对象改变后再去添加回调函数，我们仍然是能够得到改变后的状态的。</p>
</blockquote>
<ol start="2">
<li>一旦状态改变就不会再变，并且任何时候都可以得到这个结果。<code>Promise</code> 对象的状态改变只有两种可能：<code>pending</code> 变为 <code>fulfilled</code>，<code>pending</code> 变为 <code>rejected</code>。只要这两种情况发生，状态就不会再变。这时就称为已定型 <code>resolved</code>（但是很多时候都默认 <code>resolved</code> 特指 <code>fulfilled</code>）。</li>
</ol>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><p><code>Promise</code> 对象是一个构造函数，用于生成 <code>Promise</code> 实例。</p>
<p><code>Promise</code> 构造函数接收一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 与 <code>reject</code>。</p>
<p><code>resolve</code> 和 <code>reject</code> 是两个函数，由 JavaScript 引擎提供，不需要自己部署。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a><strong>resolve()</strong></h3><p><code>resolve()</code> 函数的作用是，将 <code>Promise</code> 对象的状态从 <code>pending</code> 变为 <code>resolved</code>。<code>resolve()</code> 函数在异步操作成功时调用，并 <strong>将异步操作的结果，作为参数传递出去</strong>。</p>
<h3 id="reject"><a href="#reject" class="headerlink" title="reject()"></a><strong>reject()</strong></h3><p><code>reject()</code> 函数的作用是，将 <code>Promise</code> 对象的状态从 <code>pending</code> 变为 <code>rejected</code>。<code>reject</code>() 函数在异步操作失败时调用，并 <strong>将异步操作报出的错误，作为参数传递出去</strong>。</p>
<p>如果执行 <code>resolve()</code> 或者 <code>reject()</code> 后还有命令需要执行，那么会继续执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>但是从语义上而言，执行 <code>resolve()</code> 或 <code>reject()</code> 参数后，<code>Promise</code> 本身的使命就已经完成了，后续命令应该添加至 <code>then</code> 方法中。</p>
<p>为了避免上面示例这样的情况，我们可以在 <code>resolve()</code> 或 <code>reject()</code> 执行前添加 <code>return</code> 命令：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>  即 上面两个函数决定了返回的 Promise 对象的状态，函数传递的值就是这个 Promise 的值</li>
</ul>
<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p><code>then</code> 方法定义在构造函数的原型对象上，因此为每一个实例对象所共享。</p>
<p><code>then</code> 方法的作用是为 <code>Promise</code> 实例 <strong>添加状态改变时的回调函数</strong>。</p>
<p><code>then</code> 方法可以接收两个<strong>回调函数</strong>作为参数。</p>
<p>第一个回调函数是 <code>Promise</code> 对象的状态变为 <code>resolved</code> 时调用。</p>
<p>第二个回调函数是 <code>Promise</code> 对象的状态变为 <code>rejected</code> 时调用。</p>
<p>这两个函数都是可选的，不一定要提供，它们都接收 <code>Promise</code> 对象传出的值作为参数。</p>
<p><code>Promise</code> 本身是同步执行，但是其回调 <code>then</code> 方法是异步执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><code>then</code> 方法返回的是一个新的 <code>Promise</code> 实例，因此可以采用链式写法，即 <code>then</code> 方法后面再调用另一个 <code>then</code> 方法。这样做将会将前一个 <code>then</code> 方法<strong>返回值</strong>传入这个新的 <code>then</code> 方法作为参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line">		<span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line">		<span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">	&#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  在 <code>.then</code> 和 <code>.catch</code> 中 <code>return</code> 一个 <code>error</code> 对象并不会抛出错误，也不会被后续的 <code>cathc </code>捕获，它相当于返回了一个 <code>Promise.resolve(new Error(xxx))</code> ，状态为 <code>reslove</code> ， 值为这个错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then: &#x27;</span>, res)</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch: &#x27;</span>, err)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;then: &quot; &quot;Error: error!!!&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以使用下面的方式来抛出错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>))</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>  总结： <code>.then</code> 方法会返回一个新的<code>Promise</code> 对象，这个对象的状态由它的返回值决定，对象的值就是返回值，当然如果它返回的是一个<code>new Promise</code> ，那么就是由这个<code>Promise</code>来决定</li>
</ul>
<h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><ul>
<li><p>  <code>Promise.prototype.catch()</code> 方法等同于 <code>.then(null, reject)</code> 或者 <code>.then(undefined, reject)</code>，用于指定发生错误时的回调函数。</p>
</li>
<li><p>  有了 <code>catch()</code> 方法的存在，因此一般不在 <code>then</code> 方法中定义 <code>rejected</code> 状态的回调函数，而应该总是使用 <code>catch</code> 方法。</p>
</li>
<li><p>  与传统 <code>try/catch</code> 代码块不同的是，如果没有使用 <code>catch</code> 方法指定错误处理的回调函数，<code>Promise</code> 对象抛出的错误不会传递到外层代码，即不会有任何反应。但是浏览器会打印出对应的输出，但是并不会终止脚本的运行。</p>
</li>
<li><p>  <code>catch</code> 函数也会返回一个 promise, promise 的值由它的返回值决定</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="string">&#x27;success2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then1: &#x27;</span>, res)</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then2: &#x27;</span>, res)</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch: &#x27;</span>, err)</span><br><span class="line">	&#125;)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then3: &#x27;</span>, res)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;catch: &quot;</span> <span class="string">&quot;error&quot;</span></span><br><span class="line"><span class="string">&quot;then3: &quot;</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p><code>.then</code> 和 <code>.catch</code> 的参数期望是函数，如果传入的不是函数，将会发生值透穿</p>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>finally()</code> 方法用于指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作。</p>
<p><code>finally()</code> 方法的回调函数不接受任何参数，这意味着没有办法知道状态到底是 <code>fulfilled</code> 还是 <code>rejected</code>。这表明，<code>finally()</code> 方法里面的操作，应该是与状态无关的，不依赖于 <code>Promise</code> 的执行结果。</p>
<p><code>finally()</code> 方法可以看作是 <code>then()</code> 方法的语法糖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">// 语句</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">	<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">// 相同的语句</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">// 相同的语句</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>  <strong>链式调用</strong>后面的内容需要等前一个调用执行完才会执行。</p>
</li>
<li><p>  <code>.finally</code> 最终返回的默认是上一次的 Promise 的对象值，除非它直接抛出一个异常，则返回异常的 Promise 对象</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally2&#x27;</span>)</span><br><span class="line">  	<span class="keyword">return</span> <span class="string">&#x27;我是finally2返回的值&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally2后面的then函数&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="string">&#x27;finally2&#x27;</span></span><br><span class="line"><span class="string">&#x27;finally&#x27;</span></span><br><span class="line"><span class="string">&#x27;finally2后面的then函数&#x27;</span> <span class="string">&#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ol>
<li><code>Promise</code>的状态一经改变就不能再改变。(见 3.1)</li>
<li><code>.then</code>和<code>.catch</code>都会返回一个新的<code>Promise</code>。(上面的 👆1.4 证明了)</li>
<li><code>catch</code>不管被连接到哪里，都能捕获上层未捕捉过的错误。(见 3.2)</li>
<li>在<code>Promise</code>中，返回任意一个非 <code>promise</code> 的值都会被包裹成 <code>promise</code> 对象，例如<code>return 2</code>会被包装为<code>return Promise.resolve(2)</code>。</li>
<li><code>Promise</code> 的 <code>.then</code> 或者 <code>.catch</code> 可以被调用多次, 但如果<code>Promise</code>内部的状态一经改变，并且有了一个值，那么后续每次调用<code>.then</code>或者<code>.catch</code>的时候都会直接拿到该值。(见 3.5)</li>
<li><code>.then</code> 或者 <code>.catch</code> 中 <code>return</code> 一个 <code>error</code> 对象并不会抛出错误，所以不会被后续的 <code>.catch</code> 捕获。(见 3.6)</li>
<li><code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。(见 3.7)</li>
<li><code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传。(见 3.8)</li>
<li><code>.then</code>方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为<code>catch</code>是<code>.then</code>第二个参数的简便写法。(见 3.9)</li>
<li><code>.finally</code>方法也是返回一个<code>Promise</code>，他在<code>Promise</code>结束的时候，无论结果为<code>resolved</code>还是<code>rejected</code>，都会执行里面的回调函数。</li>
</ol>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><code>Promise.all()</code> 方法用于将多个 <code>Promise</code> 实例包装成一个新的 <code>Promise</code> 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3])</span><br></pre></td></tr></table></figure>

<p><code>Promise.all()</code> 接收具有 <code>Iterator</code> 接口的对象（最典型的就是数组）作为参数，数组元素期望为 <code>Promise</code> 对象的实例；如果不是，就会对该元素调用 <code>Promise.resolve()</code> 方法，将参数转为 <code>Promise</code> 实例，再进一步处理。</p>
<p>返回的状态由传入参数的状态决定，分为两种情况：</p>
<ol>
<li>只有当传入的 <code>Promise</code> 实例都是 <code>fulfilled</code> 状态，得到的新 <code>Promise</code> 实例才是 <code>fulfilled</code> 状态。并且 <code>Promise</code> 实例参数的返回值会组成一个数组，传递给新的 <code>Promise</code> 实例的回调函数。</li>
<li>当传入的 <code>Promise</code> 实例存在 <code>rejected</code> 状态，则得到的结果就是 <code>rejected</code> 状态。并且第一个 <code>rejected</code> 状态的实例的返回值会传递给新的 <code>Promise</code> 实例的回调函数。</li>
</ol>
<p>结合 <code>Promise.all()</code> 的含义，可以手写出 <code>PromiseAll()</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">PromiseAll</span> = (<span class="params">iterator</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> promises = <span class="title class_">Array</span>.<span class="title function_">from</span>(iterator)</span><br><span class="line">	<span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">	<span class="keyword">let</span> data = []</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> promises) &#123;</span><br><span class="line">			promises[i]</span><br><span class="line">				.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">					data[i] = res</span><br><span class="line">					<span class="keyword">if</span> (++index === promises.<span class="property">length</span>) &#123;</span><br><span class="line">						<span class="title function_">resolve</span>(data)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">				.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">					<span class="title function_">reject</span>(err)</span><br><span class="line">				&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Promise.all()</code> 的应用场景很容易设想：并发了多个网络请求时，需要等到全部返回成功后再进行接下来的操作。</p>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><code>Promise.race()</code> 方法同样是将多个 <code>Promise</code> 实例包装成一个新的 <code>Promise</code> 实例。<code>Promise.race()</code> 的参数处理与 <code>Promise.all()</code> 相同，但是新 <code>Promise</code> 实例的状态规则与 <code>Promise.all()</code> 不同：</p>
<p>如果 <code>Promise</code> 实例参数有一个实例的状态发生改变，则新的 <code>Promise</code> 实例的状态也跟着改变，并且率先改变状态的参数的返回值作为新的 <code>Promise</code> 实例回调函数参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runAsync</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">r</span>(x, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span>))</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runReject</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span></span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">rej</span>(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span> * x)</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">runReject</span>(<span class="number">0</span>), <span class="title function_">runAsync</span>(<span class="number">1</span>), <span class="title function_">runAsync</span>(<span class="number">2</span>), <span class="title function_">runAsync</span>(<span class="number">3</span>)])</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, res))</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure>

<p>遇到错误的话，也是一样的，在这道题中，<code>runReject(0)</code>最先执行完，所以进入了<code>catch()</code>中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">;(<span class="string">&#x27;Error: 0&#x27;</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li>  <code>Promise.all()</code>的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。</li>
<li>  <code>.race()</code>的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。</li>
<li>  <code>Promise.all().then()</code>结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致。</li>
<li>  <code>all和race</code>传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被<code>then</code>的第二个参数或者后面的<code>catch</code>捕获；但并不会影响数组中其它的异步任务的执行</li>
</ul>
<h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h3><p><code>Promise.allSettled()</code> 方法同样是将多个 <code>Promise</code> 实例包装成一个新的 <code>Promise</code> 实例。<code>Promise.allSettled()</code> 的参数处理与 <code>Promise.all()</code> 相同，但是新 <code>Promise</code> 实例的状态规则与 <code>Promise.all()</code> 不同：</p>
<p>当参数数组的 <code>Promise</code> 对象状态全部发生改变（无论是 <code>fulfilled</code> 还是 <code>rejected</code>）后，新的 <code>Promise</code> 对象状态发生改变，为 <code>fullfilled</code>，并且将参数数组作为新的 <code>Promise</code> 实例回调函数参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([resolved, rejected])</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">promises</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(promises))</span><br><span class="line"></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#123; status: &#x27;fulfilled&#x27;, value: 1 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p>可以通过 <code>Array.prototype.filter()</code> 方式筛选出状态分别为 <code>fulfilled</code> 与 <code>rejected</code> 的 <code>Promise</code> 对象，并且返回错误原因：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">work</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> promises = [</span><br><span class="line">		<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">		<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">2</span>),</span><br><span class="line">		<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>),</span><br><span class="line">		<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">4</span>),</span><br><span class="line">	]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> fulfilleds = results.<span class="title function_">filter</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> rejecteds = results</span><br><span class="line">		.<span class="title function_">filter</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>)</span><br><span class="line">		.<span class="title function_">map</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> p.<span class="property">reason</span>)</span><br><span class="line"></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(fulfilleds)</span><br><span class="line"></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(rejecteds)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">work</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#123; status: &#x27;fulfilled&#x27;, value: 1 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; status: &#x27;fulfilled&#x27;, value: 3 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"><span class="comment">// [ 2, 4 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h3><p><code>Promise.any()</code> 方法同样是将多个 <code>Promise</code> 实例包装成一个新的 <code>Promise</code> 实例。<code>Promise.any()</code> 的参数处理与 <code>Promise.all()</code> 相同，但是新 <code>Promise</code> 实例的状态规则与 <code>Promise.all()</code> 不同：</p>
<p>如果 <code>Promise</code> 实例参数有一个实例的状态变为 <code>fulfilled</code>，则新的 <code>Promise</code> 实例的状态也变为 <code>fulfilled</code>；如果所有 <code>Promise</code> 实例参数都变为 <code>rejected</code>，则新的 <code>Promise</code> 实例的状态才会变为 <code>rejected</code>。</p>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p><code>Promise.resolve()</code> 用于将现有对象转化为 <code>Promise</code> 对象，分为下列四种情况：</p>
<ol>
<li>参数是一个 <code>Promise</code> 实例</li>
</ol>
<p>不做修改，直接返回该实例。</p>
<p>如果参数是一个原始值，或者是一个不具有 <code>then</code> 方法的对象，那么 <code>Promise.resolve</code> 方法返回一个新的 <code>Promise</code> 对象，状态为 <code>resolved</code>，并且值就为该参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不带有参数</li>
</ol>
<p>直接返回一个 <code>resolved</code> 状态的 <code>Promise</code> 对象，值为 <code>undefined</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p><code>Promise.reject()</code> 方法也返回一个新的 <code>Promise</code> 实例，状态为 <code>rejected</code>。</p>
<p><code>Promise.reject()</code> 方法的参数会原封不动作为 <code>reject</code> 的理由变成后续方法的参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">1</span>).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h2><p>ECMAScript2017 中添加了<code>async functions</code>和<code>await</code>。</p>
<ul>
<li>  async</li>
</ul>
<p><code>async</code>关键字是将一个同步函数变成一个异步函数，并将返回值变为<code>Promise</code>。</p>
<p><code>async</code> 函数返回的 <code>Promise</code> 对象的状态由以下两点决定：</p>
<ol>
<li>如果异步函数内执行 <code>throw</code> 抛出错误语句，那么状态为 <code>rejected</code>；</li>
<li>否则状态为 <code>fulfilled</code>。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P1</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P2</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">P1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">P2</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123; 1 &#125;</span></span><br><span class="line"><span class="comment">// Promise &#123;</span></span><br><span class="line"><span class="comment">//   &lt;rejected&gt; Error: 2</span></span><br><span class="line"><span class="comment">//       at P2 (E:\code\js-demo\index.js:6:11)</span></span><br><span class="line"><span class="comment">//       at Object.&lt;anonymous&gt; (E:\code\js-demo\index.js:12:12)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>async</code> 函数返回的 <code>Promise</code> 对象的值由以下几点决定：</p>
<ol>
<li>如果执行了 <code>throw</code> 抛出错误语句，那么 <code>Promise</code> 对象的值为 <code>Error</code> 对象的值。</li>
<li>否则，如果存在 <code>return</code> 语句，那么 <code>return</code> 的内容就是 <code>Promise</code> 对象的值。</li>
<li>否则，如果不存在 <code>return</code> 语句，那么 <code>Promise</code> 对象的值为 <code>undefined</code>。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P1</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P2</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P3</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">P1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">P2</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title function_">P3</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123; 1 &#125;</span></span><br><span class="line"><span class="comment">// Promise &#123; undefined &#125;</span></span><br><span class="line"><span class="comment">// Promise &#123;</span></span><br><span class="line"><span class="comment">//   &lt;rejected&gt; Error: 2</span></span><br><span class="line"><span class="comment">//       at P2 (E:\code\js-demo\index.js:6:11)</span></span><br><span class="line"><span class="comment">//       at Object.&lt;anonymous&gt; (E:\code\js-demo\index.js:12:12)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>既然 <code>async</code> 函数返回的是 <code>Promise</code> 对象，那么可以在调用 <code>async</code> 函数后追加 <code>then</code> 等其他语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncPrint</span>(<span class="params">value</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">asyncPrint</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v + <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  await</li>
</ul>
<p><code>await</code> 命令用于等待一个 <code>Promise</code> 对象执行完毕。<code>await</code> 命令要注意下列两点：</p>
<ol>
<li><code>await</code> 命令只能用于 <code>async</code> 函数中。</li>
<li><code>await</code> 命令一般跟 <code>Promise</code> 对象，如果不是 <code>Promise</code> 对象，那么就会将命令后面的值直接返回。</li>
</ol>
<p>如果 <code>async</code> 函数执行到了 <code>await</code> 语句，那么就会直接返回一个 <code>Promise</code> 对象，该 <code>Promise</code> 对象状态为 <code>pending</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;Demo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">P</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(promise)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123; &lt;pending&gt; &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>await</code> 命令后的 <code>Promise</code> 对象状态改变为 <code>fulfilled</code>，那么 <code>async</code> 函数将继续执行后面的语句，并且返回的 <code>Promise</code> 实例对象值与上一小节所述一致：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">P</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(promise)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(promise)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123; &lt;pending&gt; &#125;</span></span><br><span class="line"><span class="comment">// Promise &#123; 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果该 <code>await</code> 命令后的 <code>Promise</code> 对象状态改变为 <code>rejected</code>，那么整个 <code>async</code> 函数执行结束，并且将 <code>async</code> 函数返回的 <code>Promise</code> 对象的状态改变为 <code>rejected</code>，值为 <code>await</code> 命令后面的 <code>Promise</code> 对象执行 <code>reject()</code> 的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">P</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(promise)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(promise)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123; &lt;pending&gt; &#125;</span></span><br><span class="line"><span class="comment">// Promise &#123; &lt;rejected&gt; 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>可以理解为： 紧跟着 await 后面的语句相当于放到了 new Promise 中，下一行及之后的语句相当于放在了 Promise.then 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="comment">// 原来代码</span></span><br><span class="line">  <span class="comment">// await async2();</span></span><br><span class="line">  <span class="comment">// console.log(&quot;async1 end&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转换后代码</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">async</span> start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br></pre></td></tr></table></figure>

<ul>
<li>  如果 await 后面的表达式是一个 Promise， 它的返回值就是 Promise 的解决值</li>
<li>  如果是一个非 Promise，它的返回值就是表达式本身的值</li>
<li>  如果 await 右侧的 Promise 被拒绝，await 会抛出拒绝的原因，并且将不再执行后续代码</li>
</ul>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>即 文档对象模型</p>
<h2 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h2><p><img src="https://www.runoob.com/images/pic_htmltree.gif" alt="DOM HTML tree"></p>
<ul>
<li>  文档： document，一个页面就是一个文档</li>
<li>  元素： element， 页面中所以的标签都是元素</li>
<li>  节点： node， 网页中所有的内容都是节点（标签，属性，文本，注释等）</li>
</ul>
<p>每个节点都至少有三个基本属性</p>
<ul>
<li>  nodeType</li>
</ul>
<p>返回节点类型的常数值，常用的有 1（元素）、2（属性）、3（文本）</p>
<ul>
<li>  nodeName</li>
</ul>
<p>返回节点的名称</p>
<ul>
<li>  nodeValue</li>
</ul>
<p>返回或者设置当前节点的值，格式为字符串</p>
<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><ol>
<li><p>根据 id <code>document.getElementById()</code></p>
</li>
<li><p>根据 tag <code>document.getElementByTagName()</code> 返回伪数组</p>
</li>
<li><p>根据 class <code>document.getElementByTagName() </code> 返回伪数组</p>
</li>
<li><p>利用选择器</p>
<ol>
<li><code>document.querySelector(#id .class tag)</code> 返回匹配到的第一个元素</li>
<li><code>document.querySeletorAll(#id .class tag)</code> 返回伪数组</li>
</ol>
</li>
</ol>
<ul>
<li>  获取 body <code>document.body</code></li>
<li>  获取 html <code>document.documentElement</code></li>
</ul>
<h3 id="利用节点层次获取属性"><a href="#利用节点层次获取属性" class="headerlink" title="利用节点层次获取属性"></a>利用节点层次获取属性</h3><p><strong>父级节点</strong></p>
<ul>
<li>  <code>node.parentNode</code> 获得离元素最近的父级节点，找不到就为 null</li>
</ul>
<p><strong>子级节点</strong></p>
<ul>
<li><p>  <code>node.childNodes</code> 获取包含换行、空格等文本节点在内的节点，可以通过<code>nodeType</code>进一步获取</p>
</li>
<li><p>  <code>node.children</code> 获取所有的<strong>子级元素</strong>节点</p>
</li>
<li><p>  <code>node.firstChild</code> 获取第一个子节点，注意包括了文本等节点</p>
</li>
<li><p>  <code>node.firstElementChild</code> 获取第一个子元素节点</p>
</li>
<li><p>  <code>node.lastElementChild</code> 获取最后一个子元素节点</p>
</li>
</ul>
<p><strong>兄弟节点</strong></p>
<ul>
<li>  <code>node.nextSibling</code> 下一个节点， 包含了文本等节点</li>
<li>  <code>node.previousSibling</code> 上一个节点， 包含了文本等节点</li>
<li>  <code>node.nextElementSibling</code> 下一个兄弟元素节点</li>
<li>  <code>node.previousElementSibling</code> 上一个兄弟元素节点</li>
</ul>
<h2 id="操作-DOM"><a href="#操作-DOM" class="headerlink" title="操作 DOM"></a>操作 DOM</h2><h3 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a><strong>操作元素</strong></h3><p><strong>改变元素内容</strong></p>
<ul>
<li><p>  <code>element.innerText</code> 不识别 html 标签（如<div></div>等），会去除空格和换行</p>
</li>
<li><p><code>element.innerHTML</code> 识别 html 标签 ， 保留空格和换行 *<br>  都是可读写</p>
</li>
</ul>
<p><strong>操作常见元素</strong></p>
<ul>
<li>  src , href, alt , title , id</li>
</ul>
<p><strong>表单属性操作</strong></p>
<ul>
<li>  type、 value、checked、selected、disabled(禁用)</li>
</ul>
<p><strong>样式属性操作</strong></p>
<ul>
<li>  <code>element.style</code> 是行内样式， 样式较少，功能简单</li>
<li><code>element.className</code><br>  如果原来元素有类名，直接赋值会覆盖掉<br>  通过并列写不会覆盖 <code>element.className=原来的  新添的</code></li>
</ul>
<p><strong>创建节点</strong></p>
<ul>
<li>  <code>document.creatElement(tag)</code></li>
</ul>
<p><strong>添加节点</strong></p>
<ul>
<li>  <code>node.appendChild(节点)</code> 添加到父级子元素的末尾</li>
<li>  <code>node.insertBefore(child, 指定元素)</code> 添加到指定元素的前面</li>
</ul>
<p><strong>删除节点</strong></p>
<ul>
<li>  <code>node.removeChild(child)</code></li>
</ul>
<p><strong>复制节点</strong></p>
<ul>
<li><p><code>node.cloneNode()</code></p>
<p>  如果括号为空或者<code>false</code>，只复制标签</p>
<p>  如果为 true, 标签和内容都会复制</p>
</li>
</ul>
<h3 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h3><p><strong>获取属性</strong></p>
<ul>
<li>  <code>element.属性</code> 一般用于获取内置的 id class 等</li>
<li>  <code>element.getAttribute(属性)</code> 一般用于获取自定义属性，但是什么样的属性都能获取</li>
</ul>
<p><strong>设置属性</strong></p>
<ul>
<li>  <code>element.属性</code> = ‘值’</li>
<li>  <code>element.setAttribute(属性，值)</code></li>
<li>  用法规则与上面相同</li>
</ul>
<p><strong>移出属性</strong></p>
<ul>
<li>  <code>removeAttribute(属性)</code></li>
<li>  什么都能移出</li>
</ul>
<h3 id="H5-自定义属性"><a href="#H5-自定义属性" class="headerlink" title="H5 自定义属性"></a>H5 自定义属性</h3><ul>
<li>  规定自定义属性以 <code>data-</code> 开头作为属性名并且赋值</li>
<li>  使用 <code>element.dataset</code> 获取自定义属性集合,获取到的自定义属性是不带<code>data-</code>的</li>
<li>  使用 <code>element.dataset.自定义属性(不带data-)</code> 或者 <code>element.dataset[&#39;自定义属性&#39;]</code> 进行进一步获取或者进行赋值</li>
<li>  只能获取到 <code>data-</code>开头的自定义属性</li>
<li>如果自定义属性有多个<code>-</code> 采用驼峰命名<ul>
<li>  <code>data-list-name</code> -&gt; <code>element.dataset.listName</code></li>
</ul>
</li>
</ul>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>即 浏览器对象模型</p>
<ul>
<li>  与浏览器窗口进行交互</li>
<li>  顶级对象是 <code>window</code></li>
</ul>
<h2 id="浏览器进程问题"><a href="#浏览器进程问题" class="headerlink" title="浏览器进程问题"></a>浏览器进程问题</h2><p>浏览器是多进程的，浏览器的每一个 tab 标签都代表一个独立的进程（也不一定，因为多个空白 tab 标签会合并成一个进程），浏览器内核（浏览器渲染进程）属于浏览器多进程中的一种。</p>
<p>浏览器每个进程有多个线程，主要有以下线程</p>
<p>1）GUI 渲染线程</p>
<p>负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。</p>
<p>GUI 渲染进程 和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。</p>
<p>2）JS 引擎线程</p>
<p>单线程工作，负责解析运行 JavaScript 脚本。</p>
<p>和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。</p>
<p>3）事件触发线程</p>
<p>当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。</p>
<p>4）定时器触发线程</p>
<p>浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。 开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。</p>
<p>5）http 请求线程</p>
<p>http 请求的时候会开启一条请求线程。 请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。</p>
<h2 id="window-对象常用事件"><a href="#window-对象常用事件" class="headerlink" title="window 对象常用事件"></a>window 对象常用事件</h2><p><strong>load 事件和 onload 属性</strong></p>
<ul>
<li>  <code>load</code>事件发生在文档在浏览器窗口加载完毕时。<code>window.onload</code>属性可以指定这个事件的回调函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">var</span> elt = elements[i]</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>URL 统一资源定位符（uniform resource locator）</strong></p>
<p>是互联网上标准资源的地址</p>
<p>语法： <code>protool://host[:port]/path/[?query]#fragment</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如 http://www.itcast.cn/index.html?name=andy&amp;age=18#link</span><br><span class="line">_ protool 通信协议 http 等</span><br><span class="line">_ host 主机（域名） www.baidu.com</span><br><span class="line">_ port 端口号，可选，省略是使用迷人端口</span><br><span class="line">_ path 路径 一般用来表示主机上的一个目录或文件地址</span><br><span class="line">_ query 参数， 以键值对的形式，通过&amp;符分开</span><br><span class="line">_ fragment 片段 #后面内容 常见于链接， 锚点</span><br></pre></td></tr></table></figure>

<p><strong>location 对象</strong></p>
<p>window 提供一个 location 属性用于获取或设置窗体的 URL, 并且可以用于解析 URL,返回一个对象</p>
<p><strong>属性</strong></p>
<ol>
<li>location.href 获取或设置整个 URL</li>
<li>location.host 返回主机（域名）</li>
<li>location.port 返回端口号 未写则返回空字符串</li>
<li>location.pathname 返回路径</li>
<li>location.search 返回参数</li>
<li>location.hash 返回片段 #后面内容 常见于链接， 锚点</li>
</ol>
<p><strong>方法</strong></p>
<ol>
<li>location.assign() 可以重定向页面，记录历史</li>
<li>location.replace() 替换当前页面，因为不记录历史，不能后退页面</li>
<li>location.reload() 重新加载页面， 参数为 true 为强制刷新</li>
</ol>
<p><strong>navigator 对象</strong></p>
<ul>
<li>  包含了有关浏览器的信息，常用 userAgent，返回由客户机发送服务器的 user-agent 头部的值，判断用户是在哪个终端（pc,移动）打开页面，实现跳转</li>
</ul>
<p><strong>history 对象</strong></p>
<p><strong>方法</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> back() 后退</span><br><span class="line"><span class="bullet">2.</span> forward() 前进</span><br><span class="line"><span class="bullet">3.</span> go(参数) 前进后退功能， 参数为 1 前进一个页面 -1 就后退一个页面</span><br></pre></td></tr></table></figure>

<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><strong>相关概念</strong></h2><ul>
<li><p>  <strong>静态语言</strong>：<strong>在使用之前</strong>就需要确认其变量书记类型的编程语言</p>
</li>
<li><p>  <strong>动态语言</strong>： <strong>运行过程中</strong>需要检查数据类型的编程语言</p>
</li>
<li><p>  <strong>弱类型语言</strong>： 支持<strong>隐式类型转换</strong>（可以偷偷的转换数据类型）的编程语言</p>
</li>
<li><p>  <strong>强类型语言</strong>： 不支持隐式类型转换的编程语言</p>
</li>
</ul>
<p><code>JavaScript</code>的数据类型一共有 8 种</p>
<p><code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Number</code>、<code>BigInt</code>、<code>String</code>、<code>Symbol</code> 和 <code>Object</code>。</p>
<p>前 7 种称为原始类型（简单数据类型），最后一个对象类型称为引用类型（复杂数据类型）。原始类型与引用类型之间的一个差别就是在<strong>内存中存放的位置</strong>不一样。</p>
<h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><p>JS 的内存模型可以认为包含了从上到下三个空间： 代码空间、栈空间、堆空间</p>
<p>代码空间存储可执行代码；堆空间存储了<strong>引用类型的数据</strong>；栈空间存储了<strong>原始类型的数据</strong>和引用类型数据的<strong>引用地址</strong></p>
<h2 id="为什么需要堆空间"><a href="#为什么需要堆空间" class="headerlink" title="为什么需要堆空间"></a>为什么需要堆空间</h2><p>JavaScript 需要使用 栈空间维护程序执行期间的上下文状态，如果所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而影响到整个程序的执行效率</p>
<p>所以，一般来说， 栈空间主要存放原始类型的小数据，同时存放引用类型的地址； 因为堆空间很大，同时它的操作更加复杂，而引用类型的数据占用的空间都比较大，所以它的数据放在堆中</p>
<h2 id="什么是垃圾回收机制"><a href="#什么是垃圾回收机制" class="headerlink" title="什么是垃圾回收机制"></a>什么是垃圾回收机制</h2><p>即 <code>GC</code> -&gt; <code>Garbage Collection</code></p>
<p>程序工作过程中会产生很多 <code>垃圾</code>，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 <code>GC</code> 就是负责回收垃圾的</p>
<h2 id="垃圾的产生"><a href="#垃圾的产生" class="headerlink" title="垃圾的产生"></a>垃圾的产生</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;zzz&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">text = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>上面代码首先我们声明了一个变量 <code>test</code>，它引用了对象 <code>&#123;name: &#39;isboyjc&#39;&#125;</code>，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，那么之前的对象引用关系就没有了，如下图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a428ca00cb164eeab16e8cbbb603e7d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p>没有了引用关系，也就是无用的对象，这个时候假如任由它搁置，一个两个还好，多了的话内存也会受不了，所以就需要被清理（回收）</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><ul>
<li>  <strong>自动回收</strong>： 内存中的垃圾数据由垃圾回收器进行释放，并不需要手动通过代码来释放。如 JavaScript、Java、Python 等语⾔</li>
<li>  <strong>手动回收</strong>： 何时分配内存、销毁内存都是由代码控制的，C++ 中，如果某段数据已经不再需要了，但是又没有主动调用 <code>free</code> 函数来销毁，那么这种情况就被称为<strong>内存泄漏</strong>。</li>
</ul>
<h3 id="栈空间的数据回收方式"><a href="#栈空间的数据回收方式" class="headerlink" title="栈空间的数据回收方式"></a>栈空间的数据回收方式</h3><p>在栈空间中有一个记录当前执行状态的指针，称为 ESP。当某一个执行上下文结束的时候，JS 就会将 ESP 移动到下一个执行上下文，整个下移操作就是销毁了上一个执行上下文的过程。</p>
<p>这样上一个执行上下文虽然保存在栈空间当中，但是已经是无效内存了。而当有的数据要保存进来时，这一块内容就会覆盖掉。</p>
<h3 id="堆空间的数据回收方式"><a href="#堆空间的数据回收方式" class="headerlink" title="堆空间的数据回收方式"></a>堆空间的数据回收方式</h3><p>在栈空间中，旧的执行上下文被移除后，仅仅是从栈空间中被移除了。但是如果这一段执行上下文含有堆空间的地址，那么对应堆空间的内存是不会被直接销毁的。而如果想要回收堆中的垃圾数据，就需要使用 JS 中的垃圾回收器。</p>
<p>**标记清除算法 Mark-Sweep **</p>
<p>整个标记清除算法大致过程就像下面这样</p>
<ul>
<li>  垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0</li>
<li>  然后从各个根对象开始遍历，把不是垃圾的节点改成 1</li>
<li>  清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间</li>
<li>  最后，把所有内存中对象标记修改为 0，等待下一轮垃圾回收</li>
</ul>
<p>优点 ：简单</p>
<p>缺点：</p>
<ul>
<li><p>  <strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块</p>
</li>
<li><p>  <strong>分配速度慢</strong>，因为即便是使用 <code>First-fit</code> 策略，其操作仍是一个 <code>O(n)</code> 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p><strong>标记整理算法 Mark-Compact</strong></p>
<p>它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04b0a5a40084e0ba4550500c57f2270~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<h2 id="V8-对-GC-的优化"><a href="#V8-对-GC-的优化" class="headerlink" title="V8 对 GC 的优化"></a>V8 对 GC 的优化</h2><p>JavaScript V8 引擎将堆空间分为 <strong>新生代</strong> 和 <strong>老生代</strong> 两个区域：<strong>新生代中存放的是生存时间短的对象；老生代中存放的是生存时间久的对象</strong>。</p>
<p>新生区通常只支持 1~8M 的容量，而老生区支持的容量更大。V8 引擎分别使用 <strong>副垃圾回收器</strong> 和 <strong>主垃圾回收器</strong> 分别负责新生代与老生代的垃圾回收。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abae5b06648a40d2aaa453b5d8a83939~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<h3 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h3><p>副垃圾回收器负责的新生代使用 <strong>Scavenge 算法</strong> 来处理。Scavenge 算法又叫做 <strong>基于 copy 的垃圾回收算法</strong>。<strong>Scavenge</strong> 算法的主要思想如下：</p>
<ol>
<li>把新生代空间对半划分为两个区域：<strong>对象区域</strong> 与 <strong>空闲区域</strong>。</li>
<li>新加入的对象存放至对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</li>
<li>在垃圾回收过程中，首先按照共同的执行流程对活动对象与非活动对象进行标记。标记结束后，清理非活动对象，同时将活动对象复制到空闲区域。执行结束后，将复制到空闲区域的活动对象有序排列。因此在这个过程中，已经完成了内存整理的操作，复制后空闲区域就没有内存碎片了。</li>
<li>完成复制后，对象区域与空闲区域进行翻转：原来的对象区域变成空闲区域，原来的空闲区域变成对象区域。</li>
</ol>
<p>经过这一系列步骤后，副垃圾回收器就完成了对新生区的一次垃圾回收</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<ul>
<li>  <strong>对象晋升策略</strong>： 经过两次新生代垃圾回收依然还存活的对象，将会被移动到老生区中</li>
<li>  如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中</li>
</ul>
<h3 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h3><p>使用 <strong>标记-整理算法</strong> 进行垃圾回收</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04b0a5a40084e0ba4550500c57f2270~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<h3 id="全停顿-Stop-The-World"><a href="#全停顿-Stop-The-World" class="headerlink" title="全停顿 Stop-The-World"></a>全停顿 Stop-The-World</h3><p>JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为叫做 <strong>全停顿 Stop-The-World</strong>。</p>
<p>在新生代的垃圾回收中，因其空间较小，且活动对象较少，所以全停顿的影响不大，但老生代就不一样。为了降低老生代的垃圾回收而造成的卡顿，V8 引擎使用了 <strong>增量标记 Incremental Marking 算法</strong>：将标记过程分为一个个的子标记过程，同时让垃圾回收标记与 JavaScript 应用逻辑交替进行，直到标记阶段完成。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e16d93c2c8414d3ab7eac55c852c678a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行。这样用户就不容易感受到页面的卡顿了。</p>
<p>增量标记的优缺</p>
<p>优：主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅</p>
<p>缺： 但是由于每个小的增量标记之间执行了 <code>JavaScript</code> 代码，堆中的对象指针可能发生了变化</p>
<h3 id="并行回收-Concurrent"><a href="#并行回收-Concurrent" class="headerlink" title="并行回收 Concurrent"></a>并行回收 Concurrent</h3><p>它指的是主线程在执行 <code>JavaScript</code> 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bae064a3a8e481b8829c9c7aef73a06~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p>辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 <code>JavaScript </code> 时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点，这里我们不再细说</p>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>AJAX 指 <strong>异步 JavaScript 与 XML （Asynchronous JavaScript And XML）</strong>。</p>
<p>尽管 X 在 Ajax 中代表 XML，但由于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/JSON">JSON</a>的许多优势，比如更加轻量以及作为 Javascript 的一部分，目前 JSON 的使用比 XML 更加普遍。JSON 和 XML 都被用于在 Ajax 模型中打包信息。</p>
<p>AJAX 是一个技术统称，是一个概念模型，并不特指某一技术，<code>XMLHttpRequest</code> 是实现 AJAX 的一种常见方式。</p>
<p>AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。不使用 AJAX 的传统网页如果需要更新内容，必须重载整个页面。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li><strong>创建 XMLHttpRequest 对象</strong></li>
</ol>
<p>所有现代浏览器均内建 <code>XMLHttpRequest</code> 对象，只需要像创建实例对象一样去创建 <code>XMLHttpRequest</code> 实例即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>发送请求</li>
</ol>
<p>将请求发送到服务器，可以使用 <code>XMLHttpRequest</code> 实例的 <code>open()</code> 与 <code>send()</code> 方法：</p>
<ul>
<li>  <code>XMLHttpRequest.prototype.open()</code></li>
</ul>
<p><code>open()</code> 方法接收三个参数：</p>
<p>（1）HTTP 请求方法。可以是 <code>GET</code>、<code>POST</code> 以及其他服务器支持的方法，但是要注意，这些方法需要保证大写。</p>
<p>（2）目的地的 URL。由于 <a target="_blank" rel="noopener" href="https://blog.yucohny.vercel.app/computer-network/same-origin-policy">同源策略</a> 的限制，默认不能向非同源进行请求。</p>
<p>（3）第三个参数是可选参数，设置该请求是否是异步请求。如果为 <code>true</code>（默认值），即开启异步。</p>
<ul>
<li>  <code>XMLHttpRequest.prototype.send()</code></li>
</ul>
<p><code>send()</code> 方法可以接收一个可选参数，即想要发送给服务器的且服务器可以解析的表单数据。</p>
<ol start="3">
<li>设置请求头</li>
</ol>
<p>可以通过 <code>setRequestHeader()</code> 方法设置请求头：</p>
<p>如果想要发送 <code>POST</code> 数据，那么需要在请求头中设置 <code>Content-Type</code> 字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>处理服务器响应</li>
</ol>
<p>可以在 <code>XMLHttpRequest</code> 实例的 <code>onreadystatechange</code> 属性设置当请求状态改变时的回调函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>响应函数会在 <code>XMLHttpRequest</code> 实例对象属性 <code>readyState</code> 发生变化时调用。<code>readyState</code> 的具体值与含义如下：</p>
<ul>
<li>  <code>0</code>：请求未初始化；</li>
<li>  <code>1</code>：已建立服务器连接；</li>
<li>  <code>2</code>：请求已接受；</li>
<li>  <code>3</code>：正在处理请求；</li>
<li>  <code>4</code>：请求已完成。</li>
</ul>
<p>除此之外，可以通过 <code>XMLHttpRequest</code> 实例对象 <code>status</code> 属性检查响应码。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">使用xhr发送get请求</span><br><span class="line"></span><br><span class="line">	<span class="number">1.</span> 创建xhr对象</span><br><span class="line">		<span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">	<span class="number">2.</span> 调用xhr.<span class="title function_">open</span>() 函数</span><br><span class="line">		xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>)</span><br><span class="line">	<span class="number">3.</span> 调用xhr.<span class="title function_">send</span>() 函数</span><br><span class="line"></span><br><span class="line">	<span class="number">4.</span> 监听 xhr.<span class="property">onreadystatechange</span> 事件</span><br><span class="line">		xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="comment">//监听xhr对象的请求状态readyState 和 与服务器响应的状态status</span></span><br><span class="line">			<span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span>=== xxx)  &#123;</span><br><span class="line">				<span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">resposeText</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">发送post请求</span><br><span class="line"></span><br><span class="line">	<span class="number">1.</span> 创建xhr对象</span><br><span class="line">		<span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">	<span class="number">2.</span> 调用xhr.<span class="title function_">open</span>() 函数</span><br><span class="line">		xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>)</span><br><span class="line">	<span class="number">3.</span> 设置 <span class="title class_">Content</span>-<span class="title class_">Type</span>属性 （固定写法）</span><br><span class="line">		xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line">	<span class="number">3.</span> 调用xhr.<span class="title function_">send</span>() 函数   同时将数据以 查询字符串 的形式传入</span><br><span class="line">		xhr.<span class="title function_">send</span>(<span class="string">&#x27;bookname=水浒传&amp;author=赎买按&amp;publisher=&#x27;</span>zzz<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">	4. 监听 xhr.onreadystatechange 事件</span></span><br><span class="line"><span class="string">		xhr.onreadystatechange = function() &#123;</span></span><br><span class="line"><span class="string">			//监听xhr对象的请求状态readyState 和 与服务器响应的状态status</span></span><br><span class="line"><span class="string">			if(xhr.readyState === 4 &amp;&amp; xhr.status=== xxx)  &#123;</span></span><br><span class="line"><span class="string">				console.log(xhr.resposeText)</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br></pre></td></tr></table></figure>

<p>具体的，可以使用 <code>XMLHttpRequest</code> 实例对象 <code>responseTest</code> 或者 <code>responseXML</code> 获取响应数据：</p>
<ul>
<li>  <code>responseText</code>：服务器以文本字符的形式返回，可以据此获得字符串形式的响应数据并直接使用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">innerHTML</span> = request.<span class="property">responseText</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>responseXML</code>：服务器以 <code>XMLDocument</code> 对象的形式返回，之后可以使用 JavaScript 进行更深的处理：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xmlDocument = xmlhttp.<span class="property">responseXML</span></span><br><span class="line"><span class="keyword">const</span> x = xmlDocument.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;ARTIST&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> txt = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; x.<span class="property">length</span>; i++) &#123;</span><br><span class="line">	txt = txt + x[i].<span class="property">childNodes</span>[<span class="number">0</span>].<span class="property">nodeValue</span> + <span class="string">&#x27;&lt;br&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">innerHTML</span> = txt</span><br></pre></td></tr></table></figure>

<p>xhr level2 新特性 1. 可以设置 http 请求的时限</p>
<p>​ 新增 timeout 属性，设置 http 请求时限<br>​ xhr.timeout = 3000 单位是 ms<br>​ 其对应事件<br>​ xhr.ontimeout = function(event) {}</p>
<ol start="2">
<li><p>使用 FormData 对象管理表单数据</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> let fa = new FormData()</span><br><span class="line">  		 fd.append(&#x27;zz&#x27;,&#x27;zz&#x27;)</span><br><span class="line"> 		  fa.append(&#x27;pp&#x27;,&#x27;pp&#x27;)</span><br><span class="line">  		  let xhr = new XMLHttpRequest()</span><br><span class="line">    		  xhr.open(&#x27;POST&#x27;,&#x27;url&#x27;)</span><br><span class="line">   		 xhr.send(fd)</span><br><span class="line"></span><br><span class="line">也可以获取网页表单的值</span><br><span class="line">	let form = document.querySelector(&quot;#form1&quot;) 获取表单元素</span><br><span class="line">  	let fd = new FormData(form)</span><br><span class="line">  		直接传入该元素就能自动填充</span><br></pre></td></tr></table></figure></li>
<li><p>可以上传文件</p>
<ol>
<li>定义 UI 结构<input type='file'></li>
<li>验证是否选择了文件<br>获取选择的文件列表<br>let files = document.querySelector(‘#file1’).files</li>
<li>向 FormData 中传入文件<br>let fd = new FormData()<br>fd.append(‘name’, files[0])</li>
<li>使用 xhr 发起上传文件的请求<br>上传文件需要使用 post<br>xhr.send(fd)</li>
</ol>
</li>
<li><p>可以获得数据传输的进度信息<br>监听 xhr.upload.onprogress</p>
<p> xhr.upload.onprogress = function(e) {<br> e.lengthComputable 是一个布尔值，表示当前上传资源是否具有可计算的长度<br> if(e.lengthComputable) {<br> e.loaded 已传输字节<br> e.total 需要传输的字节<br> let percentComplete = Math.cell( (e.loaded / e.total) * 100)<br> }<br> }</p>
<p> xhr.upload.onload 传输完成的函数</p>
</li>
</ol>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="EventTarget-接口"><a href="#EventTarget-接口" class="headerlink" title="EventTarget 接口"></a>EventTarget 接口</h2><p>DOM 节点的事件操作都定义在 <code>EventTarget</code> 中。所有节点对象，以及其他一些需要事件通信的浏览器内置对象继承自 <code>EventTarget</code> 的原型，从而可以调用事件接口。</p>
<p>事件接口主要提供三个实例方法：</p>
<ul>
<li>  <code>addEventListener()</code>：绑定事件的监听函数；</li>
<li>  <code>removeEventListener()</code>：移除事件的监听函数；</li>
<li>  <code>dispatchEvent()</code>：触发事件</li>
</ul>
<h3 id="EventTarget-prototype-addEventListener"><a href="#EventTarget-prototype-addEventListener" class="headerlink" title="EventTarget.prototype.addEventListener()"></a>EventTarget.prototype.addEventListener()</h3><p><code>addEventListener()</code> 方法用于在当前节点或对象上定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。</p>
<p>该方法可以接收三个参数：</p>
<ul>
<li>  <code>type</code>：字符串形式的事件名称；</li>
<li>  <code>listener</code>：监听函数，即事件发生时的回调函数；</li>
</ul>
<p>第二个参数除了可以直接传入函数作为监听函数外，也可以是一个具有 <code>handleEvent()</code> 方法的对象，效果与监听函数一样。当事件发生时，会调用该对象的 <code>handleEvent()</code> 方法。</p>
<p>监听函数内部的 <code>this</code> 指向了触发事件的对象。</p>
<ul>
<li>  <code>useCapture</code>：布尔值，可选参数，默认为 <code>false</code>，表示监听函数将在冒泡阶段被触发。如果值为 <code>true</code>，表示监听函数将在捕获阶段触发。</li>
</ul>
<p>如下面一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, print, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码便是在 id 为 <code>btn</code> 的节点上绑定了 <code>click</code> 事件，当事件被触发时，会在冒泡阶段打印触发节点的信息。</p>
<p>第三个参数除了是布尔值，还可以是一个监听器配置对象。该对象具有以下属性：</p>
<ul>
<li>  <code>capture</code>：布尔值，如果缺省该属性，则默认为 <code>false</code>。<code>capture</code> 属性与 <code>useCapture</code> 一致。</li>
<li>  <code>once</code>：布尔值，如果缺省该属性，则默认为 <code>false</code>。如果该属性为 <code>true</code>，则表示该监听函数执行一次就会自动移除，后面将不再监听该事件。</li>
<li>  <code>passive</code>：布尔值，如果确实该属性，则默认为 <code>false</code>。如果该属性为 <code>true</code>，则表示禁止监听函数调用 <code>preventDefault()</code> 方法。如果 <code>passive</code> 为 <code>true</code> 并且调用 <code>preventDefault()</code> 方法，浏览器将忽略该请求，并在控制台输出一条警告。</li>
<li>  <code>signal</code>：该属性为一个 <code>AbortSignal</code> 对象，用于在需要时发出信号，移除监听函数。</li>
</ul>
<p><code>addEventListener()</code> 方法可以为同一个对象同一个事件添加多个 <strong>不同的监听函数</strong>。这些函数按照顺序先添加先触发，顺序触发。如果为同一个对象同一个事件添加多个相同的监听函数，那么当事件发生时只会触发一次。</p>
<h3 id="EventTarget-prototype-removeEventListener"><a href="#EventTarget-prototype-removeEventListener" class="headerlink" title="EventTarget.prototype.removeEventListener()"></a>EventTarget.prototype.removeEventListener()</h3><p><code>removeEventListener()</code> 方法用于移除 <code>addEventListener()</code> 方法添加的事件监听函数，同样没有返回值。</p>
<p>如果想要移除监听事件，需要让 <code>removeEventListener()</code> 的每一个参数，与 <code>addEventListener()</code> 完全一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, print, <span class="literal">false</span>)</span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, print, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h3 id="EventTarget-prototype-dispatchEvent"><a href="#EventTarget-prototype-dispatchEvent" class="headerlink" title="EventTarget.prototype.dispatchEvent()"></a>EventTarget.prototype.dispatchEvent()</h3><p><code>dispatchEvent()</code> 方法用于在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了 <code>preventDefault()</code>，则返回值为 <code>false</code>，否则为 <code>true</code>。</p>
<p><code>dispatchEvent()</code> 方法的参数是一个 <a target="_blank" rel="noopener" href="https://blog.yucohny.vercel.app/javascript/event"><code>Event</code></a> 对象的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, print, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>如果 <code>dispatchEvent()</code> 方法参数为空，或者不是一个有效的事件对象，将报错。</p>
<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><h3 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h3><p>一个事件发生后，会在子元素与父元素之间传播。这种传播顺序分为三个阶段：</p>
<ul>
<li>  捕获阶段：从顶层对象（浏览器中即为 <code>window</code> 对象）传导至目标结点；</li>
<li>  目标阶段：事件在目标节点上触发；</li>
<li>  冒泡阶段：从目标结点传导回顶层对象。</li>
</ul>
<h3 id="事件的代理（委托）"><a href="#事件的代理（委托）" class="headerlink" title="事件的代理（委托）"></a>事件的代理（委托）</h3><p>由于事件会在冒泡阶段向上传播到父节点，所以可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做 <strong>事件的代理</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">// work</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>事件的代理好处是，只需要在父节点定义一个监听函数，就可以处理多个子节点的事件，而不用在每个子节点上设置监听函数。并且，如果以后继续添加子节点，父节点的监听函数依然有效。</p>
<p>如果希望事件传播到某个节点为止之后不再传播，可以使用事件对象的 <code>stopPropagation()</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件传播到 p 元素后，就不再向下传播了</span></span><br><span class="line">p.<span class="title function_">addEventListener</span>(</span><br><span class="line">	<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">	<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">		event.<span class="title function_">stopPropagation</span>()</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件冒泡到 p 元素后，就不再向上冒泡了</span></span><br><span class="line">p.<span class="title function_">addEventListener</span>(</span><br><span class="line">	<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">	<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">		event.<span class="title function_">stopPropagation</span>()</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>stopPropagation()</code> 方法只会阻止事件的传播，并不会阻止该事件触发当前节点其他相同事件的监听函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">	event.<span class="title function_">stopPropagation</span>()</span><br><span class="line">	<span class="comment">// 会输出</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">	<span class="comment">// 会输出</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>事件发生以后，会产生 <code>Event</code> 实例对象作为参数传递给事件监听函数。</p>
<p><code>Event</code> 本身就是一个构造函数，可以用来生成新的实例。</p>
<p><code>Event</code> 构造函数接收两个参数：</p>
<ul>
<li>  <code>type</code>：事件的名称；</li>
<li>options：一个对象，表示事件对象的配置。该对象主要有下面两个属性：<ul>
<li>  <code>bubbles</code>：布尔值，可选，默认为 <code>false</code>，表示该事件是否会执行冒泡阶段。<code>Event</code> 构造函数生成的事件实例会在捕获阶段触发。</li>
<li>  <code>cancelable</code>：布尔值，可选，默认为 <code>false</code>，表示事件是否可以通过 <code>Event.preventDefault()</code> 取消。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fu = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fu.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, callback)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">dispatchEvent</span>(event)</span><br></pre></td></tr></table></figure>

<p>首先在父节点上绑定了冒泡阶段会触发的点击事件，但是由于儿子节点触发的点击事件不会进入冒泡阶段，因此父结点上设置的点击监听事件不会触发。如果 div 的事件监听变成捕获阶段触发（<code>&#39;click&#39;, callback, true</code>），儿子节点的事件就会触发, 或者这样<code>new Event(&#39;click&#39;, &#123;bubbles: true&#125;)</code></p>
<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a><strong>实例属性</strong></h3><p><strong>bubbles</strong></p>
<p><code>bubbles</code> 属性为布尔值，表示该事件是否会执行冒泡阶段。该属性只读，除非显式在构造函数中显式指定 <code>bubbles: true</code>，否则默认为 <code>true</code>。</p>
<p><strong>eventPhase</strong></p>
<p><code>eventPhase</code> 属性为整数常量，表示事件当前所处阶段。该属性只读。</p>
<p><code>eventPhase</code> 值为以下四种中的一种：</p>
<ul>
<li>  <code>0</code>：事件没有发生；</li>
<li>  <code>1</code>：事件处于捕获阶段；</li>
<li>  <code>2</code>：事件处于目标阶段，即目标节点；</li>
<li>  <code>3</code>：事件处于冒泡阶段。</li>
</ul>
<p><strong>cancelable</strong></p>
<p><code>cancelable</code> 为布尔值，表示事件是否可以取消。该属性只读，除非显式在构造函数中显式指定 <code>cancelable: true</code>，否则默认为 <code>true</code>。</p>
<p><strong>cancelBubble</strong></p>
<p><code>cancelBubble</code> 为布尔值，如果设为 <code>true</code>，相当于执行 <code>Event.stopPropagation()</code>，即阻止事件的传播。</p>
<p><strong>defaultPrevented</strong></p>
<p><code>defaultPrevented</code> 为布尔值，表示该事件是否调用过 <code>Event.preventDefault</code> 方法。该属性只读。</p>
<p><strong>target 与 currentTarget</strong></p>
<p>事件发生后，会在捕获阶段与冒泡阶段经过多个 DOM 节点。因此，任何事件都有两个与事件相关的节点，一个是事件的原始触发节点 <code>target</code>，另一个是事件当前正在通过的节点 <code>currentTarget</code>。</p>
<p><code>target</code> 通常是 <code>currentTarget</code> 的后代节点。</p>
<p>由于监听函数只有事件经过时才会触发，所以 <code>currentTarget</code> 总是等同于监听函数内部的 <code>this</code>。</p>
<p><strong>type</strong></p>
<p><code>type</code> 属性为字符串，表示事件类型。该属性只读。</p>
<p><strong>timeStamp</strong></p>
<p><code>timeStamp</code> 属性为网页加载成功至事件触发的毫秒时间间隔。</p>
<p><code>timeStamp</code> 可能是整数，也可能是小数，取决于浏览器的设置。</p>
<p><strong>isTrusted</strong></p>
<p><code>isTrusted</code> 属性为布尔值，表示该事件是否由用户行为产生：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">isTrusted</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><strong>preventDefault</strong>()</p>
<p><code>preventDefault()</code> 方法用于取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了。</p>
<p>该方法生效的前提是事件实例的 <code>cancelable</code> 为 <code>true</code>，如果为 <code>false</code>，那么调用该方法没有任何效果。</p>
<p>该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，需要使用 <code>stopPropagation()</code> 或 <code>stopImmediatePropagation()</code> 方法。</p>
<p><strong>stopPropagation</strong>()</p>
<p><code>stopPropagation()</code> 方法阻止事件继续传播或冒泡，即防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p>
<p><strong>stopImmediatePropagation</strong>()</p>
<p><code>stopImmediatePropagation()</code> 方法阻止同一个事件的所有监听函数被调用。</p>
<p><strong>composedPath</strong>()</p>
<p><code>composedPath()</code> 返回一个数组，数组成员依次是事件冒泡从下往上会经过的所有节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id=&#x27;div&#x27;&gt;</span></span><br><span class="line"><span class="comment">//     &lt;button id=&#x27;btn&#x27;&gt;</span></span><br><span class="line"><span class="comment">// 	       Click</span></span><br><span class="line"><span class="comment">// 	   &lt;/button&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="title function_">composedPath</span>())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) [button#btn, div#div, body, html, document, Window]</span></span><br></pre></td></tr></table></figure>

<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>ES6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体来讲，我们可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用；在对目标对象的各种操作直接影响目标对象之前，可以在代理对象中对这些操作加以控制。</p>
<h2 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h2><p>即除了作为一个抽象的目标对象，没有其他的特别功能，在默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象</p>
<p>代理是使用 Proxy 构造函数创建的。这个构造函数接收两个<strong>必要</strong>参数：目标对象和处理程序对象。对于空代理的处理程序对象，我们只需要传递一个简单的对象字面量即可。</p>
<p>空代理对象上执行的操作都会应用到目标对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>) <span class="comment">// target</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>) <span class="comment">// target</span></span><br><span class="line"></span><br><span class="line">target.<span class="property">one</span> = <span class="string">&#x27;one&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">one</span>) <span class="comment">// one</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">one</span>) <span class="comment">// one</span></span><br><span class="line"></span><br><span class="line">proxy.<span class="property">two</span> = <span class="string">&#x27;two&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">two</span>) <span class="comment">// two</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">two</span>) <span class="comment">// two</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;id&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;id&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  Proxy.prototype 为 undefined， 所有不能使用 instanceof 操作符</li>
</ul>
<h2 id="捕获器"><a href="#捕获器" class="headerlink" title="捕获器"></a>捕获器</h2><p>捕获器就是在处理程序对象中定义的“基本操作的拦截器”。</p>
<p>每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改对应的行为。</p>
<p>如同下面的例子，我们定义了一个 get() 捕获器，那么在代理对象中执行 get() 操作时，就会触发定义的 get() 捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器，在目标对象上执行这些操作仍然会产生正常的行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> trap = &#123;</span><br><span class="line">	<span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;this action is modified by proxy&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, trap)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>) <span class="comment">// target</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>) <span class="comment">// this action is modified by proxy</span></span><br></pre></td></tr></table></figure>

<p>​</p>
<h2 id="捕获器的参数与-Reflect-对象"><a href="#捕获器的参数与-Reflect-对象" class="headerlink" title="捕获器的参数与 Reflect 对象"></a>捕获器的参数与 Reflect 对象</h2><p><strong>参数</strong></p>
<p>使用捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。不同的捕获器可能存在不同的参数，get() 中存在三个参数：依次为目标对象、要查询的属性和代理对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> trap = &#123;</span><br><span class="line">	<span class="title function_">get</span>(<span class="params">targetObj, property, proxyObj</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(target === targetObj)</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(property)</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy === proxyObj)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, trap)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">id</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// id</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>Reflect</strong><br>所有捕获器都可以基于上面的这三个参数来重建原始参数，但是更多的捕获器函数并不都像上面的例子这么简单，因此，总是手写是不实际的。而事实上，开发者不需要手动重建原始行为，而是可以通过调用封装了原始行为的全局 Reflect 对象上的同名方法来重建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> trap = &#123;</span><br><span class="line">	<span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，也可以这样定义：</span></span><br><span class="line"><span class="comment">// const trap = &#123;</span></span><br><span class="line"><span class="comment">//     get: Reflect.get</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, trap)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>) <span class="comment">// target</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>) <span class="comment">// target</span></span><br></pre></td></tr></table></figure>

<p><code>Reflect</code> 对象共有 13 个静态方法，下面介绍两种</p>
<ol>
<li>Reflect.get(target, name, receiver)</li>
</ol>
<p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;bar&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;baz&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="attr">bar</span>: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;baz&#x27;</span>, myReceiverObject) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Reflect.set(target, name, value, receiver)</li>
</ol>
<p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  set bar(value) &#123;</span><br><span class="line">    return this.foo = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.foo // 1</span><br><span class="line"></span><br><span class="line">Reflect.set(myObject, &#x27;foo&#x27;, 2);</span><br><span class="line">myObject.foo // 2</span><br><span class="line"></span><br><span class="line">Reflect.set(myObject, &#x27;bar&#x27;, 3)</span><br><span class="line">myObject.foo // 3</span><br></pre></td></tr></table></figure>

<p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="number">4</span>,</span><br><span class="line">	<span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">foo</span> = value)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;bar&#x27;</span>, <span class="number">1</span>, myReceiverObject)</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 4</span></span><br><span class="line">myReceiverObject.<span class="property">foo</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>模块模式的思想是：将代码逻辑分成独立模块，按照各自的内容进行封装，每个模块自行决定向外暴露什么内容，同时自行引入执行其他模块。</p>
<p>在 ES6 发布模块规范之前，不同的模块系统具有各自的模块语法，同时具有单独的模块工具将自己的模块语法与 JavaScript Runtime 连接。</p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS 规范创建了 <strong>服务端的模块约定</strong>。尽管 CommonJS 也可用于定义在浏览器中使用的模块依赖，但是 CommonJS 模块语法<strong>不能在浏览器中直接运行</strong>。</p>
<blockquote>
<p>Node.js 使用了轻微修改版本的 CommonJS 规范。</p>
</blockquote>
<p>CommonJS 规范使用 <code>require()</code> 方法导入模块依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="built_in">require</span>(<span class="string">&#x27;./demo&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>CommonJS 规范使用 <code>module.exports</code> 对象暴露公共 API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别地，如果想要暴露一个具体值，那么可以直接赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;Yucohny&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 CommonJS 中，模块第一次加载后会进行缓存，后续加载将会取得缓存的模块。同时，CommonJS 模块的加载顺序由依赖关系决定。</p>
<p>在 CommonJS 中，模块加载是模块系统执行的同步操作，因此 <code>require()</code> 方法可以以编程式嵌入在模块代码中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">	<span class="keyword">const</span> demo = <span class="built_in">require</span>(<span class="string">&#x27;./demo&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p><strong>异步模块定义 Asynchronous Module Definition AMD</strong> 的模块系统以浏览器为目标执行环境，因此需要考虑网络延迟问题。</p>
<p>AMD 的一般策略是让模块声明自己的依赖，而运行在浏览器中的模块系统会按需获取依赖，并在依赖加载完成后立即执行依赖它们的模块。</p>
<p>AMD 规范的核心是使用函数包装模块定义，这样做有几点优势：</p>
<ol>
<li>由于函数作用域的存在，<strong>不会声明全局变量</strong>；</li>
<li><strong>允许加载器库控制何时加载模块</strong>。</li>
<li>由于包装函数内部的所有模块代码使用的都是原生 JavaScript 结构，因此更加易于模块代码的移植。</li>
</ol>
<p>AMD 支持 <code>require</code> 与 <code>exports</code> 对象，通过它们可以在 AMD 模块工厂函数内部定义 CommonJS 风格的模块。但 AMD 加载器会将它们识别为 AMD 结构，而不是模块定义。</p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="模块标签"><a href="#模块标签" class="headerlink" title="模块标签"></a>模块标签</h3><p>带有 <code>type=&quot;module&quot;</code> 属性的 <code>&lt;script&gt;</code> 标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行。</p>
<p>模块可以直接嵌入在网页中，也可以作为外部文件引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;MODULEURL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>与 <code>&lt;script defer&gt;</code> 加载的脚本一样，引入的模块会立即下载模块文件，但执行会延迟至文档解析完成。</p>
<p>值得注意的是，嵌入的模块代码不能使用 <code>import</code> 加载到其他模块；只有通过外部文件加载的模块代码才可以使用 <code>import</code> 加载，因此，嵌入模块只时候作为入口模块。</p>
<h3 id="模块行为"><a href="#模块行为" class="headerlink" title="模块行为"></a>模块行为</h3><p>ES6 新增的模块功能借用了 CommonJS 与 AMD 的许多优秀特性，包括：</p>
<ol>
<li>模块代码只在加载后执行；</li>
<li>模块只能加载一次；</li>
<li>模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互；</li>
<li>……</li>
</ol>
<p>同时，ES6 的模块系统也增加了一些新行为：</p>
<ol>
<li>ES6 模块默认在严格模式下执行；</li>
<li>ES6 模块不共享全局命名空间；</li>
<li>ES6 模块顶级 <code>this</code> 的值是 <code>undefined</code>，而常规脚本中是 <code>window</code>；</li>
<li>……</li>
</ol>
<p>浏览器运行时在知道应该把某个文件当成模块时，会有条件地按照 ES6 模块的行为添加限制。与 <code>&lt;script type=&quot;module&quot;&gt;</code> 关联或者通过 <code>import</code> 语句加载的 JavaScript 文件会被认定为模块。</p>
<h3 id="模块导出"><a href="#模块导出" class="headerlink" title="模块导出"></a>模块导出</h3><p>ES6 模块通过 <code>export</code> 关键字实现两种导出方式：命名导出与默认导出。不同的导出方式对应了不同的导入方式。</p>
<p><strong>命名导出（按需导出）</strong></p>
<p><code>export</code> 关键字用于声明一个值为命名导出。要注意的是，导出语句不能嵌套于某个块中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> xxx <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">export</span> xxx <span class="comment">// 不允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要将某个变量导出，可以使用行内命名导出，或者变量声明于导出不在同一行。</p>
<p>行内命名导出，指的是变量声明与变量导出写于同一行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是也可以不在同一行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name &#125;</span><br></pre></td></tr></table></figure>

<p>如果想要在导出时为变量提供别名，那可以且仅能通过 <code>export</code> 表达式中大括号的 <code>as</code> 标识符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> myName &#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认导出</strong></p>
<p><strong>默认导出 Default Export</strong> 将模块直接视为被导出的值。</p>
<p>默认导出使用 <code>default</code> 关键字将一个变量的值声明为默认导出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = &quot;Yucohny&quot;</span><br><span class="line">export default name</span><br></pre></td></tr></table></figure>

<p>要注意的是，一个模块只能有一个默认导出，重复的默认导出会出现 <code>SyntaxError</code> 错误。</p>
<p>由于 <code>default</code> 是默认导出关键字，因此如果在命名语法中出现 <code>default</code> 关键字，那么会将其视为默认导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Yucohny&quot;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name</span><br></pre></td></tr></table></figure>

<p>命名导出与默认导出不会产生冲突，因此可以在同一个模块中同时定义这两种导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">20</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> <span class="keyword">default</span>, age &#125;</span><br></pre></td></tr></table></figure>

<h3 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h3><p>模块使用 <code>import</code> 关键字导入其他模块导出的值。与 <code>export</code> 一样，<code>import</code> 语句不能出现在块中。</p>
<p><code>import</code> 后面跟导入的模块路径，这个路径必须是直接给出，不能是动态计算的结果，比如不支持字符串拼接。</p>
<p>命名导出可以使用 <code>*</code> 批量获取并赋值给保存导出对象的别名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">20</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> demo <span class="keyword">from</span> <span class="string">&#x27;./demo.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo.<span class="property">age</span>)</span><br></pre></td></tr></table></figure>

<p>如果想要指定部分导入，那么直接将需要导入的属性指定于 <code>import</code> 语句中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, age <span class="keyword">as</span> myAge &#125; <span class="keyword">from</span> <span class="string">&#x27;./demo.js&#x27;</span></span><br></pre></td></tr></table></figure>

<p>默认导出可以使用 <code>default</code> 关键字并提供 <strong>别名</strong> 实现导入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> myAge &#125; <span class="keyword">from</span> <span class="string">&#x27;./demo.js&#x27;</span></span><br></pre></td></tr></table></figure>

<p>也可以不使用 <code>default</code> 关键字与大括号，但是此时导入的变量名就固定为导出时的变量名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> age <span class="keyword">from</span> <span class="string">&#x27;./demo.js&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果模块同时使用了命名导出与默认导出，那么可以在 <code>import</code> 语句中同时获得它们：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">20</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> <span class="keyword">default</span>, age &#125;</span><br><span class="line"><span class="keyword">import</span> name, &#123; age <span class="keyword">as</span> myAge &#125; <span class="keyword">from</span> <span class="string">&#x27;./demo.js&#x27;</span></span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="/assets/js.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="/assets/compute.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/08/webpack/" title="Webpack"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Webpack</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zhper</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhper" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content"><center>主域名：<br><a href="https://zhper.vercel.app/"><b><font color="#5ea6e5">zhper.vercel.app</font></b></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-text">原始数据类型（简单数据类型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-text">引用类型（复杂数据类型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%8F%98%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">赋值变动过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">检测数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝与浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">手写深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9E%E4%B8%90%E7%89%88"><span class="toc-text">乞丐版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%89%88"><span class="toc-text">基础版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-text">循环引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE-0-1-0-2-0-3%EF%BC%8C%E8%AE%B2%E8%AE%B2-IEEE-754-%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E5%85%B6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-text">根据 0.1+0.2 ! &#x3D;&#x3D; 0.3，讲讲 IEEE 754 ，如何让其相等？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IEEE-754"><span class="toc-text">IEEE 754</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-text">原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3"><span class="toc-text">解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原型和原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5"><span class="toc-text">深入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">执行上下文</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">作用域与作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%B8%8E-%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">静态作用域 与 动态作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">函数的声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-text">属性与方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-text">参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arguments-%E5%AF%B9%E8%B1%A1"><span class="toc-text">arguments 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reset-%E5%8F%82%E6%95%B0"><span class="toc-text">reset 参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8"><span class="toc-text">函数内部</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#caller"><span class="toc-text">caller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-target"><span class="toc-text">new.target</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call%E3%80%81apply%E3%80%81bind-%E6%89%8B%E5%86%99"><span class="toc-text">call、apply、bind 手写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">箭头函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">属性的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7"><span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-text">访问器属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="toc-text">定义多个属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">读取属性的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-text">增强的对象语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%80%BC%E7%AE%80%E5%86%99"><span class="toc-text">属性值简写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-text">可计算属性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E5%91%BD%E4%BB%A4"><span class="toc-text">new 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0-new-%E5%91%BD%E4%BB%A4%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">无 new 命令调用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%86%99-new"><span class="toc-text">手写 new</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor-NaN"><span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-text">实例属性与方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">原型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-text">静态方法与静态属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getter-amp-setter"><span class="toc-text">getter &amp; setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-extends"><span class="toc-text">继承 extends</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-text">异步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">单线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-text">同步任务和异步任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">任务队列与事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout"><span class="toc-text">setTimeout()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setInterval"><span class="toc-text">setInterval()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">清除定时器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96-debounce"><span class="toc-text">防抖 debounce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96-throttle"><span class="toc-text">防抖 throttle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resolve"><span class="toc-text">resolve()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reject"><span class="toc-text">reject()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-prototype-then"><span class="toc-text">Promise.prototype.then()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-prototype-catch"><span class="toc-text">Promise.prototype.catch()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-prototype-finally"><span class="toc-text">Promise.prototype.finally()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-all"><span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-race"><span class="toc-text">Promise.race()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-allSettled"><span class="toc-text">Promise.allSettled()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-any"><span class="toc-text">Promise.any()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-resolve"><span class="toc-text">Promise.resolve()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-reject"><span class="toc-text">Promise.reject()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-amp-await"><span class="toc-text">async &amp; await</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DOM"><span class="toc-text">DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-%E6%A0%91"><span class="toc-text">DOM 树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="toc-text">获取元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%8A%82%E7%82%B9%E5%B1%82%E6%AC%A1%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7"><span class="toc-text">利用节点层次获取属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C-DOM"><span class="toc-text">操作 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0"><span class="toc-text">操作元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%B1%9E%E6%80%A7"><span class="toc-text">操作属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="toc-text">H5 自定义属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BOM"><span class="toc-text">BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-text">浏览器进程问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#window-%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6"><span class="toc-text">window 对象常用事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">内存空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="toc-text">为什么需要堆空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">什么是垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-text">垃圾的产生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%94%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">栈空间的数据回收方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%94%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">堆空间的数据回收方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V8-%E5%AF%B9-GC-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">V8 对 GC 的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">副垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">主垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%81%9C%E9%A1%BF-Stop-The-World"><span class="toc-text">全停顿 Stop-The-World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6-Concurrent"><span class="toc-text">并行回收 Concurrent</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AJAX"><span class="toc-text">AJAX</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">基本使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EventTarget-%E6%8E%A5%E5%8F%A3"><span class="toc-text">EventTarget 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EventTarget-prototype-addEventListener"><span class="toc-text">EventTarget.prototype.addEventListener()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventTarget-prototype-removeEventListener"><span class="toc-text">EventTarget.prototype.removeEventListener()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventTarget-prototype-dispatchEvent"><span class="toc-text">EventTarget.prototype.dispatchEvent()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-text">事件模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="toc-text">事件的传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%90%86%EF%BC%88%E5%A7%94%E6%89%98%EF%BC%89"><span class="toc-text">事件的代理（委托）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">事件对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-text">实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-text">实例方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%A9%BA%E4%BB%A3%E7%90%86"><span class="toc-text">创建空代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%99%A8"><span class="toc-text">捕获器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%99%A8%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8E-Reflect-%E5%AF%B9%E8%B1%A1"><span class="toc-text">捕获器的参数与 Reflect 对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommonJS"><span class="toc-text">CommonJS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMD"><span class="toc-text">AMD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6"><span class="toc-text">ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E6%A0%87%E7%AD%BE"><span class="toc-text">模块标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E8%A1%8C%E4%B8%BA"><span class="toc-text">模块行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%87%BA"><span class="toc-text">模块导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5"><span class="toc-text">模块导入</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/08/css/" title="CSS"><img src="/assets/css.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS"/></a><div class="content"><a class="title" href="/2023/02/08/css/" title="CSS">CSS</a><time datetime="2023-02-07T16:00:00.000Z" title="Created 2023-02-08 00:00:00">2023-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/08/html/" title="HTML"><img src="/assets/html.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTML"/></a><div class="content"><a class="title" href="/2023/02/08/html/" title="HTML">HTML</a><time datetime="2023-02-07T16:00:00.000Z" title="Created 2023-02-08 00:00:00">2023-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/08/ts/" title="TypeScript"><img src="/assets/ts.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript"/></a><div class="content"><a class="title" href="/2023/02/08/ts/" title="TypeScript">TypeScript</a><time datetime="2023-02-07T16:00:00.000Z" title="Created 2023-02-08 00:00:00">2023-02-08</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgb(118, 123, 126,0.1)"><div id="footer-wrap"><div class="copyright">&copy;2023 By zhper</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>