<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>计算机网络 | ZHPER 的笔记</title><meta name="author" content="zhper"><meta name="copyright" content="zhper"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTTPHTTP 协议全称为 Hyper Text Transfer Protocol，即超文本传输协议。HTTP 协议主要用于客户端与服务端之间的通信，浏览器就是最常见的 HTTP 客户端。 HTTP 请求客户端向服务器发送的信息称为 请求报文，结构从上到下包括 请求行、请求头、请求体 请求行用于说明需要做什么， 包含三个部分–方法、资源路径、HTTP 版本    方法： 通过方法指定对请求资源">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://zhper.vercel.app/2023/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="ZHPER 的笔记">
<meta property="og:description" content="HTTPHTTP 协议全称为 Hyper Text Transfer Protocol，即超文本传输协议。HTTP 协议主要用于客户端与服务端之间的通信，浏览器就是最常见的 HTTP 客户端。 HTTP 请求客户端向服务器发送的信息称为 请求报文，结构从上到下包括 请求行、请求头、请求体 请求行用于说明需要做什么， 包含三个部分–方法、资源路径、HTTP 版本    方法： 通过方法指定对请求资源">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhper.vercel.app/assets/compute.jpg">
<meta property="article:published_time" content="2023-02-07T16:00:00.000Z">
<meta property="article:modified_time" content="2023-02-07T16:00:00.000Z">
<meta property="article:author" content="zhper">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhper.vercel.app/assets/compute.jpg"><link rel="shortcut icon" href="/assets/favicon/%E4%BF%9D%E5%85%BB%E6%89%8B%E5%86%8C.png"><link rel="canonical" href="https://zhper.vercel.app/2023/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-08 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ZHPER 的笔记"><span class="site-name">ZHPER 的笔记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-02-07T16:00:00.000Z" title="Created 2023-02-08 00:00:00">2023-02-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-02-07T16:00:00.000Z" title="Updated 2023-02-08 00:00:00">2023-02-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP 协议全称为 Hyper Text Transfer Protocol，即超文本传输协议。HTTP 协议主要用于客户端与服务端之间的通信，浏览器就是最常见的 HTTP 客户端。</p>
<h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><p>客户端向服务器发送的信息称为 请求报文，结构从上到下包括 请求行、请求头、请求体</p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>用于说明需要做什么， 包含三个部分–方法、资源路径、HTTP 版本</p>
<ul>
<li>  方法： 通过方法指定对请求资源进行怎样的操作做什么样的操作（比如查询、修改等）。常见的方法有：<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 与 <code>HEAD</code>。</li>
<li>  资源路径： 指定请求资源在服务器中的位置。比如 <code>/index.html</code> 表示访问服务器根目录下名字为 <code>index</code> 的 <code>html</code> 文件</li>
<li>  <strong>HTTP 版本</strong>：指定所使用的 HTTP 版本。</li>
</ul>
<p>最常用的两个方法是 <code>GET</code> 和 <code>POST</code></p>
<ul>
<li>  <code>GET</code> 请求参数存放在 URL 中，而 <code>POST</code> 请求参数存储在请求体中。</li>
</ul>
<p>参数放在 URL 中可以直接被看到，则 <code>GET</code> 请求相对 <code>POST</code> 请求更不安全。</p>
<p>各个浏览器对 URL 长度做了限制，比如 IE 浏览器限制 URL 的长度最大为 2KB，这就使得了 <code>GET</code> 请求传输的数据长度有了限制，而 <code>POST</code> 请求传输数据长度无限制。</p>
<ul>
<li>  一般 <code>GET</code> 请求用于获取数据，<code>POST</code> 请求用于新增数据。</li>
</ul>
<p><code>GET</code> 请求用于获取资源，不会对系统资源进行改变。<code>POST</code> 请求用于新增资源，这意味着多次请求将创建多个资源。基于这个特点，<code>GET</code> 请求可被缓存、可保留在浏览器历史记录中、浏览器回退不会产生副作用，而 <code>POST</code> 请求反之。</p>
<p>GET 和 POST 的区别。</p>
<ul>
<li>  从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li>
<li>  从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li>
<li>  从<strong>幂等性</strong>的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)</li>
<li>  从 <strong>TCP</strong> 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</li>
</ul>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>用于向服务器传递一些额外的重要信息，由字段名与字段值组成。常见的请求头包括：</p>
<table>
<thead>
<tr>
<th align="center">请求头</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Host</code></td>
<td align="center">接收请求的域名</td>
</tr>
<tr>
<td align="center"><code>User-Agent</code></td>
<td align="center">客户端软件的名称和版本号等相关信息</td>
</tr>
<tr>
<td align="center"><code>Connection</code></td>
<td align="center">设置发送响应之后 TCP 连接是否继续保持的通信选项</td>
</tr>
<tr>
<td align="center"><code>Cache-Control</code></td>
<td align="center">控制缓存的相关信息</td>
</tr>
<tr>
<td align="center"><code>Referer</code></td>
<td align="center">记录请求的来源（当通过点击超级链接进入下一个页面时，会记录上一个页面的 URL）</td>
</tr>
<tr>
<td align="center"><code>Accept</code></td>
<td align="center">客户端可支持的数据类型， 以 MIME 类型来表示</td>
</tr>
<tr>
<td align="center"><code>Accept-Encoding</code></td>
<td align="center">客户端可支持的编码格式</td>
</tr>
<tr>
<td align="center"><code>Accept-Language</code></td>
<td align="center">客户端可支持的语言</td>
</tr>
<tr>
<td align="center"><code>If-Modified-Since</code></td>
<td align="center">用于判断资源的缓存是否有效（客户端通知服务器，本地缓存的最后变更时间）</td>
</tr>
<tr>
<td align="center"><code>If-None-Match</code></td>
<td align="center">用于判断资源的缓存是否有效</td>
</tr>
<tr>
<td align="center"><code>Range</code></td>
<td align="center">用于断点续传，指定第一个字节的位置和最后一个字节的位置。</td>
</tr>
<tr>
<td align="center"><code>Cookie</code></td>
<td align="center">表示请求者的身份，用于保存状态信息</td>
</tr>
</tbody></table>
<h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>用于传送客户端要发给服务器的数据，比如请求参数。</p>
<p>请求体与请求行和请求头不同，请求行和请求体的数据都是文本形式且格式化的，而请求体可以包含任意的二进制数据，比如文本、图片、视频等等。</p>
<h2 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h2><p>服务端向客户端发送的信息称为 响应报文，结构从上到下包括 响应行、响应头、响应体</p>
<h3 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h3><p>用于说明对请求的处理情况，包括三个部分– HTTP 版本、状态码、消息短语</p>
<ul>
<li>  HTTP 版本</li>
<li>  状态码： 以三位数字形式描述服务器对请求的处理结果， 如 200 表示成功</li>
<li>  消息短语： 以文本呢的形式描述服务器对请求的处理结果，如 OK 表示成功</li>
</ul>
<p>状态码：</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>1XX</code></td>
<td align="center">提示信息，表示请求已被成功接收，继续处理</td>
</tr>
<tr>
<td align="center"><code>2XX</code></td>
<td align="center">成功，表示请求被正常处理完毕</td>
</tr>
<tr>
<td align="center"><code>3XX</code></td>
<td align="center">重定向，资源位置发生变化，表示请求需要附加操作才能完成</td>
</tr>
<tr>
<td align="center"><code>4XX</code></td>
<td align="center">客户端错误，表示服务器无法处理请求</td>
</tr>
<tr>
<td align="center"><code>5XX</code></td>
<td align="center">服务器错误，表示服务器处理请求出错</td>
</tr>
</tbody></table>
<p>一些具体的状态码及含义如下：</p>
<ul>
<li>  <code>200 OK</code>：表示请求被正常处理。</li>
<li>  <code>204 No Content</code>：表示请求被正常处理，但在返回的响应报文中不含响应体内容。</li>
<li>  <code>301 Moved Permanently</code>：永久重定向，表示请求的资源已经被永久转移了，新的 URL 会在响应报文的 <strong>Location</strong> 字段中返回，浏览器将自动获取新的 URL 并发出新的请求。</li>
<li>  <code>302 Found</code>：临时重定向，以后还可能有变化，表示请求的资源已被临时分配了新的 URL，新的 URL 会在响应报文中的 <strong>Location</strong> 字段中返回，浏览器将会自动使用新的 URL 并发出新的请求。</li>
<li>  <code>304 Not Modified</code>：代表之前的缓存可以继续使用。</li>
<li>  <code>400 Bad Request</code>：一个通用差错状态码，表示请求报文中存在语法错误，客户端发生的错误。</li>
<li>  <code>401 Unauthorized</code>：用户未认证。</li>
<li>  <code>403 Forbidden</code>：表示服务器虽然收到了请求，但是拒绝提供服务，常见的原因是为没有访问权限（即用户未授权）。</li>
<li>  <code>404 Not Found</code>：表示请求资源不存在。</li>
<li>  <code>500 Internal Server Error</code>：表示服务器出现错误。</li>
<li>  <code>502 Bad Gateway</code>：通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>  <code>503 Service Unavailable</code>：表示服务器暂时处于超负载或者正在进行停机维护，暂时无法处理请求，可以稍后再试。</li>
</ul>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>响用于向客户端传递一些额外的重要信息，由字段名与字段值组成。常见的响应头包括：</p>
<table>
<thead>
<tr>
<th align="center">响应头</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Date</code></td>
<td align="center">日期时间信息，表示服务器产生并发送响应报文的日期和时间。</td>
</tr>
<tr>
<td align="center"><code>Server</code></td>
<td align="center">表示 HTTP 服务器应用程序的信息，类似于请求报文中的 <code>User-Agent</code></td>
</tr>
<tr>
<td align="center"><code>Location</code></td>
<td align="center">此字段会配合重定向使用，用于提供重定向后新的 URL。</td>
</tr>
<tr>
<td align="center"><code>Connection</code></td>
<td align="center">设置发送响应之后 TCP 连接是否继续保持的通信选项</td>
</tr>
<tr>
<td align="center"><code>Cache-Control</code></td>
<td align="center">控制缓存的相关信息</td>
</tr>
<tr>
<td align="center"><code>Content-Type</code></td>
<td align="center">服务器返回的响应类型</td>
</tr>
<tr>
<td align="center"><code>Content-Length</code></td>
<td align="center">服务器返回的响应长度</td>
</tr>
<tr>
<td align="center"><code>Content-Encoding</code></td>
<td align="center">服务器返回的响应编码</td>
</tr>
<tr>
<td align="center"><code>Content-Language</code></td>
<td align="center">服务器返回的响应语言</td>
</tr>
<tr>
<td align="center"><code>Last-Modified</code></td>
<td align="center">指定响应内容最后的修改时间</td>
</tr>
<tr>
<td align="center"><code>Expires</code></td>
<td align="center">表示资源失效的时间，浏览器会在指定过期时间内使用本地缓存</td>
</tr>
<tr>
<td align="center"><code>Etag</code></td>
<td align="center">用于协商缓存，返回一个摘要值</td>
</tr>
<tr>
<td align="center"><code>Accept-Ranges</code></td>
<td align="center">用于断点续传，指定服务器所支持的内容范围</td>
</tr>
<tr>
<td align="center"><code>Set-Cookie</code></td>
<td align="center">设置状态信息</td>
</tr>
</tbody></table>
<h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>响应体用于传送服务器要发给浏览器的正文。与请求报文的请求体一样，响应体可包含任意的二进制数据。</p>
<h2 id="持久链接"><a href="#持久链接" class="headerlink" title="持久链接"></a>持久链接</h2><p>客户端需要发送许多请求给服务器，如果客户端与服务器的每次请求与想要都经过一个单独的 TCP 连接发送，那么就称为 <strong>非持续连接/短连接</strong>；如果经过相同的 TCP 连接发送，则称为 <strong>持续连接/长连接</strong>。</p>
<p><strong>非持续连接</strong>有以下几个缺点：</p>
<ul>
<li>  每次建立连接都需要单独经历三次握手过程，容易导致总的请求响应时间变长。即使使用并行连接，也容易加重 Web 服务器的负担。</li>
<li>  建立维护多个 TCP 连接容易使得服务器存在严重负担。</li>
</ul>
<p>HTTP/1.1 及之后的版本默认采用持续连接的方式，也可以配置为非持续连接。具体的，可以在请求头的 <code>Connection</code> 字段设置是否使用持久连接：</p>
<ul>
<li>  如果设置为 <code>Connection: Keep-Alive</code> 则表明此连接为持久连接（HTTP/1.1 及之后的版本默认开启）。</li>
<li>  如果设置为 <code>Connection: Close</code> 则表明此连接为非持久连接，每当 TCP 连接成功发送响应数据后，就关闭连接。</li>
</ul>
<p>需要注意，持久连接并不是永久连接，如果在一个可配置的时间间隔后，此连接仍未被使用，那么服务器将会关闭该连接。</p>
<h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h2><p>对于一些短时间内不会产生变化的资源，客户端可以在请求后将服务器响应的数据资源 <strong>缓存</strong> 于客户端本地。当之后想要再次获取这些资源时，可以直接读取本地缓存的数据，不必再重新发送请求。</p>
<p>缓存的目的是 <strong>加快响应速度</strong>。HTTP 缓存的实现依赖于请求头于响应头的一些字段，主要分为 <strong>强缓存</strong> 与 <strong>持久（协商）缓存</strong>。</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>强缓存</strong> 指的是在缓存数据未失效的情况下，将直接使用浏览器的缓存数据，不会再向服务器发送请求。</p>
<p>强缓存主要通过 <code>Cache-Control</code> 与 <code>Expires</code> 字段实现。</p>
<p><code>Cache-Control</code> 是一个相对时间，即多长时间之后过期；<code>Expires</code> 是一个绝对时间，即在某个时间点过期。如果两个字段同时存在，前者的优先级更高。</p>
<p>由于服务器端时间和客户端时间可能存在偏差，因此使用 <code>Expires</code> 可能会存在时间误差，因此一般更推荐使用 <code>Cache-Control</code> 来实现强缓存。</p>
<p>以 <code>Cache-Control</code> 为例，强缓存的具体实现流程如下：</p>
<ol>
<li>当客户端第一次请求服务器资源时，服务器会在响应头中添加 <code>Cache-Control</code> 字段。<code>Cache-Control</code> 可以设置以下内容：</li>
</ol>
<p>（1）<code>max-age=s</code>：表示缓存将于指定秒值后过期。如 <code>max-age=31536000</code> 表示缓存将于 31536000 秒（即 365 天）后过期；</p>
<p>（2）<code>no-store</code>：表示该数据不允许缓存，此字段同时适用于强缓存与协商缓存；</p>
<p>（3）<code>no-cache</code>：表示该数据不允许使用强缓存，只能使用协商缓存。</p>
<p>（4）<code>must-revalidate</code>：表示如果缓存未过期，可以使用缓存；如果缓存已过期，那么需要向服务器验证该缓存是否有效。</p>
<ol start="2">
<li>客户端再次向服务器请求重复资源时，根据请求资源的时间与 <code>Cache-Control</code> 中设置的过期时间大小，计算出该资源是否过期。</li>
</ol>
<p>如果没有过期，并且可以使用缓存，那么就使用缓存，否则重新请求服务器。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><strong>协商缓存</strong> 指的是当第一次请求后，服务器响应头 <code>Cache-Control</code> 字段设置为 <code>no-cache</code> 或者当缓存过期后，客户端再次向服务器请求判断缓存资源是否有效。</p>
<ul>
<li>  如果资源没有更新，那么服务器将会返回 <code>304 Not Modified</code> 表明缓存仍然可用，就不再需要重新发送资源，同时更新缓存有效时间。</li>
<li>  如果资源已更新，那么服务器将会返回 <code>200 OK</code>，并将更新后的资源放在响应体中。</li>
</ul>
<p>协商缓存在 HTTP/1.0 与 HTTP/1.1 的实现方式有所不同。</p>
<ol>
<li> HTTP/1.0 规范</li>
</ol>
<p>在 HTTP/1.0 中，协商缓存主要通过请求头中的 <code>If-Modified-Since</code> 与响应头中的 <code>Last-Modified</code> 字段实现。</p>
<p><code>Last-Modified</code> 字段表示响应资源的最后修改时间，客户端第一次请求资源后，服务器将在响应头中携带此字段。</p>
<p><code>If-Modified-Since</code> 字段是当缓存资源过期时，客户端再次发起请求并将之前接收到的 <code>Last-Modified</code> 值放在请求头 <code>If-Modified-Since</code> 中，服务器接收后，将此时间与被请求资源的实际最后修改时间进行对比：</p>
<ul>
<li>  如果最后修改时间不一致，说明资源已更新，那么服务器返回 <code>200 OK</code> 与已更新的资源；</li>
<li>  如果最后修改时间一致，说明资源未更新，返回 <code>304 Not Modified</code>。</li>
</ul>
<p>HTTP/1.0 规范下的协商缓存存在以下问题：</p>
<ul>
<li>  实现方式基于时间，但是容易因为时间误差而不可靠；</li>
<li>  如果某些文件内容并未修改，只是修改了最后修改时间，那么实际上应该使用缓存但是却无法使用缓存。</li>
</ul>
<ol start="2">
<li>HTTP/1.1 规范</li>
</ol>
<p>在 HTTP/1.1 中，协商缓存主要通过请求头中的 <code>If-None-Match</code> 与响应头中的 <code>ETag</code> 字段实现。</p>
<p><code>ETag</code> 字段表示相应资源的唯一标识，是一个哈希值，客户端第一次请求资源后，服务器将在响应头中携带此字段。</p>
<p><code>If-None-Match</code> 字段是当缓存资源过期时，客户端再次发起请求并将之前接收到的 <code>ETag</code> 值放在请求头 <code>If-None-Match</code> 中，服务器接收后，将此哈希值与被请求资源的当前哈希值进行对比：</p>
<ul>
<li>  如果两者不等，说明资源已更新，那么服务器返回 <code>200 OK</code> 与已更新的资源；</li>
<li>  如果两者相等，说明资源未更新，返回 <code>304 Not Modified</code>。</li>
</ul>
<p>HTTP/1.1 规范下的协商缓存存在的问题是，服务器计算 <code>ETag</code> 哈希值会消耗系统性能。</p>
<p>如果 HTTP 响应头同时存在 <code>ETag</code> 与 <code>Last-Modified</code> 字段，前者优先级更高。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b74c746d1459403382fd0bbc1d96aeca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片 5.png"></p>
<h3 id="三种刷新操作对-http-缓存的影响"><a href="#三种刷新操作对-http-缓存的影响" class="headerlink" title="三种刷新操作对 http 缓存的影响"></a>三种刷新操作对 http 缓存的影响</h3><ul>
<li>  正常操作：地址栏输入 url，跳转链接，前进后退等。</li>
<li>  手动刷新：f5，点击刷新按钮，右键菜单刷新。</li>
<li>  强制刷新：ctrl + f5，shift+command+r。</li>
</ul>
<p><strong>正常操作：强制缓存有效，协商缓存有效。</strong> <strong>手动刷新：强制缓存失效，协商缓存有效。</strong> <strong>强制刷新：强制缓存失效，协商缓存失效。</strong></p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>一些前提知识：</p>
<ul>
<li>  会话</li>
</ul>
<p>会话，指用户登录网站后的一系列动作，比如浏览商品添加到购物车并购买。</p>
<ul>
<li>  无状态的 HTTP 协议</li>
</ul>
<p>在早期，HTTP 协议是无状态的协议。每个 HTTP 请求都要求打开一个 TCP 连接，一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。</p>
<ul>
<li>  会话跟踪</li>
</ul>
<p>会话跟踪是 Web 程序中常用的技术，用于跟踪用户的整个会话。常用的会话跟踪技术有 Cookie 与 Session。Cookie 通过在客户端记录信息确定用户身份，而 Session 通过在服务器端记录信息确定用户身份。</p>
<h3 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h3><p>由于 HTTP 是一种无状态的协议，因此服务器直接从网络连接了解客户端的身份。Cookie 的工作原理就是为客户端们颁发一个通行证，每个客户端都有一个独一无二的通行证（也就是 Cookie）无论哪一个客户端想要访问服务端，都必须携带属于自己的 Cookie，这样服务器就可以通过 Cookie 获知客户端的身份了。</p>
<p>Cookie 本质上是一小段的文本信息。当客户端向服务器发送请求时，如果服务端需要记录该用户的状态，那么在发送响应数据时就可以发送一个属于这个客户端的 Cookie。当客户端接收到响应数据后，会将 Cookie 保存起来；当客户端再次请求该服务器时，会将之前保存下的 Cookie 一同提交给服务器，服务器就可以通过 Cookie 辨认客户端状态用户状态。</p>
<h3 id="查看-Cookie"><a href="#查看-Cookie" class="headerlink" title="查看 Cookie"></a>查看 Cookie</h3><p>我们可以在浏览器的开发者工具中的控制台输入 <code>alert(document.cookie)</code>，以查看该网站的 Cookie。如查看 <code>www.google.com</code> 的 Cookie：</p>
<p><img src="https://blog.yucohny.vercel.app/images/ComputerNetwork/4.png" alt="img"></p>
<p>在弹出的 Cookie 内容中，有一段字段为 <code>SID</code>，就保存了当前客户端的 Google 账号 ID。当客户端将 Cookie 协同其他数据一起发送给服务器时，服务器就可以通过 Cookie 的内容识别出当前客户端的身份。</p>
<h3 id="不可跨域"><a href="#不可跨域" class="headerlink" title="不可跨域"></a>不可跨域</h3><p>许多网站都会使用 Cookie。例如，Google 会向客户端发送 Cookie，Baidu 也会向客户端发送 Cookie。那客户端访问 Google 时会不会也携带上 Baidu 颁发的 Cookie 呢？或者 Google 能不能修改 Baidu 颁发的 Cookie 呢？</p>
<p>答案是否定的。</p>
<p>Cookie 具有不可跨域名性。根据 Cookie 规范，浏览器访问 Google 只会携带 Google 发送的 Cookie，而不会携带 Baidu 发送的 Cookie。同理，Google 也只能操作 Google 发送的 Cookie，而不能操作 Baidu 的 Cookie。</p>
<p>Cookie 由客户端进行管理。客户端保证 Google 只会操作 Google 发送的 Cookie 而不会操作 Baidu 发送的 Cookie，从而保证用户的隐私安全。</p>
<p>客户端通过域名判断一个网站是否能操作另一个网站的 Cookie。Google 与 Baidu 的域名不一样，因此 Google 不能操作 Baidu 的 Cookie。</p>
<p>需要注意的是，即使是同一根域名下的不同二级域名，也无法操作彼此的 Cookie。</p>
<h3 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h3><p>Cookie 的 <code>maxAge</code> 属性决定了 <code>Cookie</code>的有效期，单位为秒。</p>
<p>如果 <code>maxAge</code> 属性为正数，则表示该 Cookie 会在 <code>maxAge</code> 秒之后自动失效。浏览器会将 <code>maxAge</code> 为正数的 Cookie 写入对应的 Cookie 文件中。无论浏览器或者甚至是电脑是否关闭，只要还在 <code>maxAge</code> 秒之前，重新访问服务器时该 Cookie 仍然有效。</p>
<p>如果 <code>maxAge</code> 为负数，则表示该 Cookie 仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该 Cookie 即失效。<code>maxAge</code> 为负数的 Cookie，为临时性 Cookie，不会被写到 Cookie 文件中。<code>maxAge</code> 为负数的 Cookie 信息直接保存在浏览器内存中，因此关闭浏览器该 Cookie 将会消失。Cookie 默认的 <code>maxAge</code> 为 –1。</p>
<p>如果 <code>maxAge</code> 为 0，则表示删除该 Cookie。Cookie 机制没有提供删除 Cookie 的方法，因此通过设置该 Cookie 即时失效实现删除 Cookie 的效果。失效的 Cookie 会被浏览器从 Cookie 文件或者内存中删除。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>HTTP 协议不仅是无状态的，而且是不安全的。</p>
<p>使用 HTTP 协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。如果不希望 Cookie 在 HTTP 等非安全协议中传输，可以设置 Cookie 的 <code>secure</code> 属性为 <code>true</code>，此时客户端只会在 HTTPS 和 SSL 等安全协议中传输此类 Cookie。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 是服务端记录客户端状态的机制。Cookie 保存在客户端中，Session 保存在服务端中。</p>
<p>Session 的核心是，当客户端访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上；客户端再次访问时服务器时，服务器只需要直接从该 Session 中查找客户端的状态即可。</p>
<p>当客户端第一次访问服务器时，服务器会自动创建 Session；在 Session 生成后，只要客户端继续访问，服务器就会更新 Session 的最后访问时间，并维护该 Session。</p>
<h3 id="有效期-1"><a href="#有效期-1" class="headerlink" title="有效期"></a>有效期</h3><p>如果过多的 Session 存储在服务器内存中，那么会对服务器造成压力。为防止内存溢出，服务器会把长时间内没有活跃的 Session 从内存删除。这个时间就是 Session 的超时时间。如果超过了超时时间没访问过服务器，Session 就自动失效了。</p>
<h3 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h3><p>最常见使用 Session 的做法是，客户端在向服务器发送网络请求时，通过 Cookie 携带服务器分配的 SessionID。当服务器处理完对应的内容后，将数据返回给 SessionID 所对应的客户端。</p>
<h3 id="禁用-Cookie-时"><a href="#禁用-Cookie-时" class="headerlink" title="禁用 Cookie 时"></a>禁用 Cookie 时</h3><p>当客户端禁用 Cookie 时，我们便无法继续使用上述方法传递 Session 相关信息。通常有两种不借用 Cookie 的方式传递 Session 相关信息：</p>
<ol>
<li>重写 URL；</li>
<li>隐藏表单字段。</li>
</ol>
<p>重写 URL</p>
<p>重写 URL 的方式是将 Session 相关信息，如 SessionID，直接以参数的形式附加在 URL 上，像这样 <code>www.domain.com/v1/api?sessionID=SESSIONID</code>。</p>
<p>隐藏表单字段</p>
<p>直接将 SessionID 附加在 URL 上存在严重的安全问题，这与直接将私密的 SessionID 暴露在网络中无疑。</p>
<p>隐藏表单字段的方式是通过，将 SessionID 的字段，隐藏在表单的 <code>hidden</code> 子项中，当发起网络请求时，作为参数的一部分一同发送。像下列示例一样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">		<span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">name</span>=<span class="string">&quot;sessionID&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">value</span>=<span class="string">&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng&quot;</span></span></span><br><span class="line"><span class="tag">	/&gt;</span></span><br><span class="line">	/&gt;</span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;handleClick()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Cookie-与-Session-区别"><a href="#Cookie-与-Session-区别" class="headerlink" title="Cookie 与 Session 区别"></a>Cookie 与 Session 区别</h3><ol>
<li>数据存放上</li>
</ol>
<p>Cookie 数据存放于客户端中，Session 数据存放于服务器中。</p>
<ol start="2">
<li>安全性</li>
</ol>
<p>由于私密信息直接通过 Cookie 保存在客户端本地，因此别人可以通过分析存放于本地的 Cookie 来获取隐私信息。</p>
<ol start="3">
<li>数据大小</li>
</ol>
<p>单个 Cookie 保存的数据不能超过 4KB，许多浏览器都限制一个站点最多保存 20 个 Cookie，因此存储的数据容易收到许多限制；而 Session 没有对存储的数据量的限制，并且可以保存更为复杂的数据类型。</p>
<ol start="4">
<li>性能问题</li>
</ol>
<p>Session 在一定时间内保存于服务器，当访问服务器的客户端增多时，大量的 Session 数据会占用服务器的诸多内存；当需要考虑减轻服务器性能压力时，应当考虑使用 Cookie。</p>
<h1 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP/1"></a>HTTP/1</h1><p>主要介绍了 HTTP/1.1 的发展史，然后将介绍发展过程中遇到的各种困难以及最终的解决办法。</p>
<h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>HTTP/0.9 于 1991 年提出，最初主要用于学术交流，并且需求也较为简单：用于在网络之间传递 HTML 超文本的内容，因为成为超文本传输协议。</p>
<p>HTTP/0.9 的实现方式也比较简单，采用了基于请求响应的模式：客户端发出请求，服务端返回数据。</p>
<p>HTTP/0.9 的完整请求流程如下：</p>
<ol>
<li>HTTP 协议基于 TCP 协议，因此客户端需要根据 IP 地址、端口号与服务器建立 TCP 链接。</li>
<li>建立连接后，客户端将发送一个 GET 请求行信息。</li>
</ol>
<blockquote>
<p>HTTP/0.9 没有请求头与请求体，请求行也较为简单：<code>GET /index.html</code>。</p>
</blockquote>
<ol>
<li>服务器接收到请求信息后，将会读取对应的数据，并将这些数据以 ASCII 字符流的方式返回给客户端。</li>
<li>HTML 文档传输完成后，连接断开。</li>
</ol>
<p>当时的需求较为简单，主要是用于传输体积较小的 HTML 文件，因此 HTTP/0.9 的实现具有以下三个特点：</p>
<ol>
<li>因此此时的需求较为简单，因此只需要请求行就可以完整表达客户端的需求，所以没有 HTTP 请求头与请求体。</li>
<li>同样，由于需求简单，服务器也没有响应头，只有响应体，也就响应的数据。</li>
<li>由于传输的数据都是 HTML 格式的文件，因此以 ASCII 字符流传输比较合适。</li>
</ol>
<h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>为了能让客户端与服务器更深入地交流，HTTP/1.0 引入了请求头与响应头。</p>
<p>请求头与响应头都是以键值对的形式保存，在发送 HTTP 请求时，会携带上请求头的信息；同样，服务器在响应数据时，也会返回响应头信息。</p>
<h3 id="请求头与响应头"><a href="#请求头与响应头" class="headerlink" title="请求头与响应头"></a>请求头与响应头</h3><p>HTTP/1.0 的方案是通过请求头与响应头来进行协商。客户端发起 HTTP 请求时，会通过请求头告知服务器它期待返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件，以及文件的具体编码方式。</p>
<p>因而最终发出的请求头内容形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accept: text/html</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-Charset: ISO-8859-1, utf-8</span><br><span class="line">accept-language: zh-CN, zh</span><br></pre></td></tr></table></figure>

<p><code>accept</code> 表示期望服务器返回 HTML 类型的文件。</p>
<p><code>accept-encoding</code> 表示期望服务器使用 <code>gzip</code>、<code>deflate</code> 或者 <code>br</code> 中的一种方式进行压缩。</p>
<p><code>accept-Charset</code> 表示期望服务器使用的文件编码方式是 <code>ISO-8859-1</code> 或 <code>UTF-8</code> 中的一种。</p>
<p><code>accept-language</code> 表示期望服务器返回的内容优先语言是中文。</p>
<p>​ 服务器在接收到客户端发送的请求头信息后，会根据请求头信息来准备响应数据。但是可能存在一些意外情况，比如客户端请求的压缩类型是 <code>gzip</code>，但是服务器并不支持 <code>gzip</code>，仅支持通过 <code>br</code> 方式压缩。那么服务器就会通过响应头的 <code>content-encoding</code> 字段告诉浏览器最终的压缩类型。因此，客户端最终需要根据响应头的信息来处理数据，下面是一段响应头的示例数据信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content-encoding: br</span><br><span class="line">content-type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure>

<p>有了响应头的信息后，浏览器就会使用 <code>br</code> 方式来解压文件，再按照 <code>UTF-8</code> 的编码格式来处理响应数据，最终按照 HTML 的方式解析文件。</p>
<p>HTTP/1.0 除了对多文件类型提供良好的支持外，还依据当时实际的需求引入了许多其他特性，这些特性都是通过请求头与响应头实现的：</p>
<ul>
<li>  有的请求服务器可能无法处理，或者处理出错，那么就需要告诉客户端处理该请求的最终情况。这就引入了 <strong>状态码</strong>。状态码就是通过响应行的方式来告知浏览器的。</li>
<li>  为了减轻服务器的压力，HTTP/1.0 提供了 <strong>缓存 Cache 机制</strong>，用来缓存已经下载过的数据。</li>
<li>  由于服务器需要统计客户端的基础信息，比如 Windows 与 macOS 的用户数量，因此 HTTP/1.0 的请求头还添加了 <strong>用户代理</strong> 的字段。</li>
</ul>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>HTTP/1.1 在 HTTP/1.0 的基础上继续做了大量的更新。同样，我们来看 HTTP/1.0 遇到了哪些问题，以及 HTTP/1.1 的改进方案。</p>
<h3 id="改进持久连接"><a href="#改进持久连接" class="headerlink" title="改进持久连接"></a>改进持久连接</h3><p>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、通过 HTTP 传输数据、断开 TCP 连接三个阶段。</p>
<p>在当时，由于通信的文件比较小，并且每个页面的引用的资源也不算多，因此这种传输形式并不存在大问题。但是随着浏览器的普及，每个页面中的图片文件越来越多，有时候一个页面可能需要包含成百上千个外部引用的资源文件。如果下载每个文件的时候，都需要建立 TCP 连接、传输数据、断开连接这样的步骤，无疑会增加大量无谓的开销。</p>
<p>为了解决这个问题，HTTP/1.1 增加了持久连接的方法：在一个 TCP 连接上可以传输多个 HTTP 请求。只要客户端或者浏览器没有明确断开连接，那么这个 TCP 连接就会一直保持。</p>
<p>HTTP/1.1 持久连接可以有效减少 TCP 建立连接与断开连接的次数，从而减小了客户端与服务端双方的负担，提升了整体 HTTP 请求的有效时长。</p>
<p>持久连接在 HTTP/1.1 中是默认开启的，因此我们不需要专门为了持久连接取 HTTP 请求头设置信息。如果不想要使用持久连接，那么可以在 HTTP 请求头中添加 <code>Connection: close</code>。</p>
<h3 id="提供虚拟主机的支持"><a href="#提供虚拟主机的支持" class="headerlink" title="提供虚拟主机的支持"></a>提供虚拟主机的支持</h3><p>在 HTTP/1.0 中，每个域名绑定了唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，并且要求每个虚拟主机都有自己的单独的域名，而这些单独的域名都公用同一个 IP 地址。</p>
<p>因此，HTTP/1.1 的请求头中增加了 <code>Host</code> 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 <code>Host</code> 字段做不同的处理。</p>
<h3 id="支持动态生成的内容"><a href="#支持动态生成的内容" class="headerlink" title="支持动态生成的内容"></a>支持动态生成的内容</h3><p>在 HTTP/1.0 中，服务器需要在响应头中设置完整的数据大小，如 <code>Content-Length: 1000</code>，这样客户端就可以根据设置的数据大小来接收数据。但是随着技术的不断发展，许多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了客户端并不知道何时会接收完所有的文件数据。</p>
<p>HTTP/1.1 中引入了 Chunk transfer 机制来解决这个问题：服务器会将数据分割为若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p>
<h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><p>HTTP/1.1 为网络效率做了大量优化，最核心的有以下三点：</p>
<ol>
<li>增加了持久连接。</li>
<li>浏览器为每个域名最多同时维护了 6 个 TCP 持久连接。</li>
<li>使用 CDN 实现域名分片机制。</li>
</ol>
<p>尽管 HTTP/1.1 采取了许多优化资源加载速度的策略，也取得了一定更多成果，但是 HTTP/1.1 对于带宽的利用率并不理想，这也是 HTTP/1.1 的一个核心问题。</p>
<p>带宽是每秒最大能发送或接收的字节数。每秒能发送的最大字节数称为上行带宽，每秒能接收的最大字节数称为下行带宽。</p>
<p>HTTP/1.1 对带宽利用率不理想，主要是由以下三个问题导致的：</p>
<ol>
<li>TCP 慢启动</li>
</ol>
<p>一旦一个 TCP 连接建立之后，就进入了数据发送数据阶段。在最开始的时候 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</p>
<p>慢启动本身是 TCP 为了减少网络拥塞的一种策略，是我们没有办法改变的。</p>
<ol start="2">
<li>同时开启多条 TCP 连接，这些连接会竞争固定的带宽</li>
</ol>
<p>如果系统同时建立了多条 TCP 连接，当带宽充足时，每条连接的发送或者接收速度会慢慢向上增加；当带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。</p>
<p>这样就会出现一个问题，有的 TCP 连接下载的是一些关键资源，如 CSS、JS 文件；而又的 TCP 连接下载的是图片、视频等普通资源文件。但是多条 TCP 连接之间并不能协商让哪些关键资源优先下载，这样就可能会影响关键资源的下载速度。</p>
<ol start="3">
<li>HTTP/1.1 队头阻塞</li>
</ol>
<p>当 HTTP/1.1 建立持久连接时，虽然只能共用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前请求没有结束之前，其他的请求只能处于阻塞状态中。这导致我们不能随意在一个管道中发送请求和接受内容。</p>
<p>但是阻塞请求的因素有很多，并且许多都是一些不确定的因素。一旦某一个请求被阻塞，那么后续请求在等待过程中，带宽以及 CPU 都会被白白浪费。</p>
<p>浏览器处理生成页面过程中，是希望能尽早接收到数据，这样就可以对这些数据做出预处理操作。但是队头阻塞使得这些数据并不能并行请求。</p>
<h2 id="HTTP-2-的多路复用"><a href="#HTTP-2-的多路复用" class="headerlink" title="HTTP/2 的多路复用"></a>HTTP/2 的多路复用</h2><p>慢启动与 TCP 连接之间的相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 本身的机制导致的。</p>
<p>虽然 TCP 本身「有问题」，但是我们并不能直接替换 TCP，只是我们依然要想办法规避 TCP 的慢启动与竞争问题。</p>
<p>HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样在整个页面资源的下载过程中只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p>
<p>队头阻塞的原因是，HTTP/1.1 中需要在等待请求完成后才能去请求下一个资源，而 HTTP/2 要实现的目标就是实现资源的并行请求。</p>
<p>所以 HTTP/2 的解决方法可以总结为：一个域名只使用一个 TCP 长连接，并实现资源的并行请求。</p>
<p>更加具体的则是，HTTP/2 通过最核心最重要的多路复用机制来解决上述问题。多路复用机制可以见下图作为示例：</p>
<p><img src="https://blog.yucohny.vercel.app/images/ComputerNetwork/1.png" alt="img"></p>
<p>每一个具体的请求都有一个对应的 ID，如 stream1 对应了 data.js 的请求，stream2 对应了 index.css 的请求。</p>
<p>服务器在接收到这些请求后，会根据具体的情况来决定优先返回哪些内容。比如服务器可能之前已经缓存好了 index.css 的响应头信息，那么在接收到请求的时候就可以立即把 index.css 的响应头信息返回给浏览器，然后再将 index.css 的响应体数据返回给浏览器。而现在之所以可以随意发送，是因为每份数据都有对应的 ID；浏览器在接收到之后，会筛选出相同 ID 的内容，再将这些 ID 相同的内容拼接为完整的 HTTP 响应数据。</p>
<p>HTTP/2 使用了多路复用技术，可以将请求分成⼀帧⼀帧的数据去传输，这样带来了⼀个额外的好处，就是当收到⼀个优先级⾼的请求时，比如接收到 JS 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</p>
<h2 id="多路复用的实现"><a href="#多路复用的实现" class="headerlink" title="多路复用的实现"></a>多路复用的实现</h2><p>上一小节介绍了 HTTP/2 采取了多路复用的机制来解决 HTTP/1.1 中存在的问题，这一小节来介绍 HTTP/2 是如何实现多路复用的。</p>
<p>我们首先来看看 HTTP/2 的协议栈：</p>
<p><img src="https://blog.yucohny.vercel.app/images/ComputerNetwork/2.png" alt="img"></p>
<p>从图中可以看出，HTTP/2 添加了二进制分帧层。接下来我们通过梳理 HTTP/2 的请求与接收过程，来分析 HTTP/2 的多路复用是如何实现的。</p>
<ol>
<li>浏览器准备好请求数据，包括请求行、请求头等信息。</li>
<li>这些数据经过二进制分帧层处理后，会被转换为一个个带有请求 ID 编号的帧，随后通过协议栈将这些帧发送给服务器。</li>
<li>服务器接受完所有帧之后，会将相同 ID 的帧合并为一条完整的请求信息。</li>
<li>随后服务器处理完整的请求信息，并将处理好的响应行、响应头和响应体分别发送至二进制分帧层。</li>
<li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li>
<li>浏览器接收到响应帧后，会根据 ID 编号将帧的数据提交给对应的请求。</li>
</ol>
<h2 id="HTTP-2-的其他特性"><a href="#HTTP-2-的其他特性" class="headerlink" title="HTTP/2 的其他特性"></a>HTTP/2 的其他特性</h2><p>上面几个小节介绍了 HTTP/2 通过多路复用实现了资源的并行传输。而基于⼆进制分帧层，HTTP/2 还附带实现了许多其他功能。</p>
<h3 id="设置请求的优先级"><a href="#设置请求的优先级" class="headerlink" title="设置请求的优先级"></a>设置请求的优先级</h3><p>浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请 求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对用户体验来说非常不友好。为了解决这个问题，HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p>
<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样⼀个场景，当用户请求⼀个 HTML 页面后，服务器如果已经知道该 HTML 页面会引用几个重要的 JS 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将可能要使用的 CSS 文件和 JS ⽂件⼀并发送给浏览器，这样当浏览器解析完 HTML 文件后，就能直接拿到需要的 CSS 文件和 JS 文件，这对首次打开页面的速度起到了至关重要的作用。</p>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>⽆论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语⾔。HTTP/2 对请求头和响应头进行了压缩。</p>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>浏览器安全主要划分为三大块内容：页面安全，系统安全与网络安全，HTTPS 就属于网络安全的范畴。</p>
<p>最开始设计 HTTP 协议的目的比较简单，仅仅是为了传输超文本文件，因此在当时并没有太强加密传输数据的需求，HTTP 从而一直保持着明文传输数据的特征，但是明文传输会导致在传输过程中的每一个环节，数据都有可能被窃取或者篡改。</p>
<p>具体来说，HTTP 将数据提交给 TCP 后，数据将会经过用户电脑、WiFi 路由器、运营商，以及目标服务器等等，在这中间的每一个环节数据都有可能被窃取或者篡改。假如用户电脑被装上了恶意软件，那么恶意软件或许就有机会抓住并篡改所发出的 HTTP 请求的内容。</p>
<p>HTTPS 并非一个新的协议，它的原理是在 HTTP 与 TCP 两个层面中间添加了一层 <strong>安全层 SSL/TLS</strong>：当 HTTP 向 TCP 发送数据时，会首先经过 SSL/TLS 加密；当 TCP 接收到另外一方传过来的数据时，数据会经过 SSL/TLS 解密，再传输到 HTTP。</p>
<p>如下图：</p>
<p><img src="https://blog.yucohny.vercel.app/images/ComputerNetwork/3.png" alt="img"></p>
<p>简单来说，安全层主要有两个职责：</p>
<ol>
<li>对发起 HTTP 请求的数据进行加密操作。</li>
<li>对接收到 HTTP 的内容进行解密操作。</li>
</ol>
<p>因此，我们需要了解 HTTPS 中的安全层，是如何实现加密与解密操作的。</p>
<h2 id="使用对称加密"><a href="#使用对称加密" class="headerlink" title="使用对称加密"></a>使用对称加密</h2><p>最简单的加密方式是使用对称加密。<strong>对称加密指加密与解密都使用相同密钥。</strong></p>
<p>如果我们需要在客户端与服务端中加密解密同一个文件，那么我们需要提前了解加密解密的方式与对应的密钥。因此在 HTTPS 发送请求之前，浏览器和服务器之间需要协商加密的方式与密钥。</p>
<p>对称加密的具体方法如下：</p>
<ol>
<li>浏览器发送它所支持的加密套件列表和一个随机数 Client Random（<strong>加密套件指的是加密的方法</strong>，加密套件列表指的是浏览器能支持的加密方法列表）。</li>
<li>服务器从收到的加密套件列表中选取一个加密套件，并生成一个随机数 Service Random，然后将 Service Random 与选择的加密套件返回至浏览器。</li>
<li>浏览器和服务器分别返回确认消息。</li>
</ol>
<p>通过上面这个步骤，服务器端与浏览器端都有了相同的 Client Random 与 Service Random，然后他们再使用相同的方法将两者混合起来生成一个密钥 Master Secret，有了密钥 Master Secret 和加密套件后，双方就可以进行数据的加密传输了。</p>
<p>通过这种方式，我们实现了在安全层上应用对称加密。尽管这种方式可以很好的进行工作，但是客户端与服务端所传输的 Client Random 与 Service Random 仍然是明文传输。因此理论上黑客可以得到协商好的加密套件与双方的随机数，而通过随机数合成密钥的算法是公开的，因此黑客拿到随机数之后仍然可以合成密钥，这种方式依然可以被破解。</p>
<h2 id="使用非对称加密"><a href="#使用非对称加密" class="headerlink" title="使用非对称加密"></a>使用非对称加密</h2><p>使用非对称加密可以解决上面的这个问题。<strong>非对称加密指的是有 A、B 两把密钥，如果使用密钥 A 进行加密，那么我们只能使用密钥 B 进行解密；同样，如果我们使用密钥 B 进行加密，那么只能使用密钥 A 进行解密</strong>。</p>
<p>在 HTTPS 中服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为 <strong>公钥</strong>，服务器自己留下的那个密钥叫做 <strong>私钥</strong>。公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。</p>
<p>使用非对称加密的请求流程如下：</p>
<ol>
<li>浏览器发送加密套件列表给服务器。</li>
<li>服务器选择一个加密套件，然后将加密套件与服务器选择好的公钥返回给浏览器。</li>
<li>浏览器和服务器返回确认消息。</li>
</ol>
<p>通过这种方式，浏览器端获得了服务器的公钥，那么当浏览器向服务器发送数据时，便可以使用公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即使黑客获取了数据与公钥，也无法使用公钥来解密数据。</p>
<p>采用非对称加密已经可以保证浏览器发送给服务器的数据是安全的，但是这种方式仍然存在两个严重的问题：</p>
<ol>
<li>非对称加密的效率太低，这会影响到加解密数据的速度，进而影响用户打开页面的速度。</li>
<li>无法保证服务器发送给浏览器的数据安全。虽然浏览器端可以使用公钥进行加密，但是服务器端只能使用私钥加密。私钥加密只有公钥能解密，但黑客也是可以获取到公钥的，因此不能保证服务器端的数据安全。</li>
</ol>
<h2 id="混合加密：对称加密和非对称加密搭配使用"><a href="#混合加密：对称加密和非对称加密搭配使用" class="headerlink" title="混合加密：对称加密和非对称加密搭配使用"></a>混合加密：对称加密和非对称加密搭配使用</h2><p>基于以上原因，我们最终选择了一个更加完美的方案：传输数据阶段依然使用对称加密，但是对称加密的密钥我们提前采用非对称加密进行传输。</p>
<p>混合加密的具体流程如下：</p>
<ol>
<li>浏览器端手握一组密钥 与 ，服务器端手握非对称加密的公钥 和私钥 。</li>
<li>浏览器端向服务器端发送加密套件列表、非对称加密套件列表。</li>
<li>服务器端选择一个加密套件与非加密套件，并结合自己的公钥 一起返回给浏览器。</li>
<li>浏览器使用服务器的公钥 对自己的密钥 进行加密，记加密后的密钥为 。</li>
<li>服务器收到加密后的密钥 ，并使用自己的私钥 进行解密，得到浏览器端的密钥 。</li>
</ol>
<p>通过这种方式浏览器端与服务器端在加密状态下，获得了浏览器端的密钥。因此在接下来传输数据的过程当中，只需要让浏览器端使用一个密钥进行加密，服务器端再使用另外一个密钥要进行解密即可。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>通过这种方式已经实现了数据的加密传输，但是这种方式仍然存在一个问题：假如黑客通过 DNS 劫持了目的地址的 IP 地址，并将其替换为了黑客的 IP 地址，那么我们访问的就是黑客的服务器。黑客就可以在自己的服务器上实现公钥和私钥，但是对于浏览器而言，并不知道实际上访问的是黑客的服务器。</p>
<p>因此服务器需要向浏览器提供证明：我就是你想访问的真正的目的地址。为了达到这一目的，服务器可以向客户端与服务端都信赖的第三方机构 <strong>Certificate Authority CA</strong> 申请 <strong>数字证书 Digital Certificate</strong>。</p>
<p>数字证书由数字签名与服务器的公钥组成。因此对于浏览器而言，数字证书有两个作用：</p>
<ol>
<li>通过数字证书向浏览器证明服务器的身份。</li>
<li>数字证书包含了服务器的公钥。</li>
</ol>
<p>具体而言，混合加密与数字证书结合在一起的流程如下：</p>
<ol>
<li>浏览器端手握一组密钥 与 ，服务器端手握非对称加密的公钥 和私钥 ，CA 自己本身持有根公钥 与根私钥 ，其中根公钥 已经提前置于浏览器或操作系统。</li>
<li>服务器向 CA 申请注册数字证书时提供自己的公钥 。CA 通过服务器的相关信息与自己的根私钥 生成数字签名，同时将服务器自己的公钥 结合在一起生成了服务器的数字证书。</li>
<li>浏览器端想要发起请求时，首先向服务器端发送加密套件列表、非对称加密套件列表。</li>
<li>服务器端选择一个加密套件与非加密套件，并将自己的数字证书一起返回给浏览器。</li>
<li>浏览器端根据提前置于浏览器或者操作系统的 CA 根公钥 对数字证书进行解码，验证响应来源是对应的服务器，并获得服务器的公钥 。然后浏览器使用服务器的公钥 对自己的密钥 进行加密，记加密后的密钥为 。</li>
<li>服务器收到加密后的密钥 ，并使用自己的私钥 进行解密，得到浏览器端的密钥 。</li>
</ol>
<p>此时，浏览器与服务器已经各自持有了一组密钥，并且浏览器也已经验证了响应的数据来源是我们期待的那一个服务器，此时再数据进行加密传输即可。</p>
<p>通过混合加密与数字证书结合的这种方式，最终实现了数据的安全传输。</p>
<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>在没有安全保障的 Web 网页中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据安全。</p>
<p>而页面中最基础、最核心的安全策略就是 <strong>同源策略 Same Origin Policy</strong>。</p>
<h2 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h2><p>如果两个 URL 的协议、域名和端口号都相同，我们就称这两个 URL 同源。</p>
<p>浏览器默认两个同源站点可以互相访问资源并且操作 DOM 的，而两个不同源站点如果想要相互访问资源或者操作 DOM，那么就需要有一套基础的安全策略的制约，即同源策略。</p>
<p>同源策略主要表现在 DOM、Web 数据和网络三个层面。</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读写的操作。</p>
<p>比如我们打开网页 A，并从网页 A 跳转进入网页 B：</p>
<ol>
<li>如果网页 B 与网页 A 同源，那么在网页 B 可以操控网页 A 的 DOM。</li>
<li>如果网页 B 与网页 A 不同源，那么在网页 B 无法操控网页 A 的 DOM。</li>
</ol>
<h2 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h2><p>同源策略限制了不同源站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据，因此无法从不同源的站点中读取其他源站点的 Cookie、IndexDB、LocalStorage 等数据。</p>
<h2 id="网络层面"><a href="#网络层面" class="headerlink" title="网络层面"></a>网络层面</h2><p>同源策略还限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送到不同源的站点。</p>
<h2 id="安全性与便利性的权衡"><a href="#安全性与便利性的权衡" class="headerlink" title="安全性与便利性的权衡"></a>安全性与便利性的权衡</h2><p>安全性与便利性是相互对立的：直接隔离不同源站点，肯定是最安全的措施，但这也会让 Web 项目变得难以开发与使用。因此，同源策略需要在这两者之间做出权衡，即出让一部分安全性来满足便利性。</p>
<p>但是出让安全性又会导致许多安全问题，最典型的就是 <strong>跨站脚本攻击 Cross Site Scripting XSS</strong> 与 <strong>跨站请求伪造 Cross Size Request Forgery CSRF</strong>。</p>
<h2 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a>内容安全策略</h2><p>如果同源策略限制一个页面的所有资源都来自同源，那么自然存在许多限制。因此浏览器支持引用不同源站点资源文件，但是这也导致了许多安全问题。</p>
<p>如果引入了恶意脚本，这些脚本就能够将页面的敏感数据比如 Cookie、IndexDB、LocalStorage 等等通过 XSS 的手段发送到指定服务器。</p>
<p>为了解决 XSS 攻击，浏览器中引入了 <strong>内容安全策略 Content Safe Policy CSP</strong>。<strong>CSP 的核心思想是让服务器决定浏览器的脚本能够加载哪些资源，以及让服务器决定浏览器是否能够执行内联 JavaScript 代码</strong>。</p>
<h2 id="跨域资源共享和跨文档消息机制"><a href="#跨域资源共享和跨文档消息机制" class="headerlink" title="跨域资源共享和跨文档消息机制"></a>跨域资源共享和跨文档消息机制</h2><p>默认情况下，如果打开某一个网站页面，那么该网站页面可能会通过 <code>XMLHttpRequest</code> 或者 <code>Fetch</code> 来请求其他服务器的资源。但是同源策略会阻止其向其他服务器发出请求，但是这样会很大程度制约我们的生产力。</p>
<blockquote>
<p>注意：有三个标签是可以直接进行跨域请求的：</p>
<ul>
<li>  <code>&lt;img src=xxx/&gt;</code></li>
<li>  <code>&lt;link href=xxx/&gt;</code></li>
<li>  <code>&lt;script src=xxx/&gt;</code></li>
</ul>
</blockquote>
<p>为了解决这个问题，便引入了 <strong>跨域资源共享 Cross Origin Resource Sharing CORS</strong>。CORS 可以帮助进行跨域访问控制，并且使得跨域数据传输在安全中进行。</p>
<p>前面提到，如果两个页面不是同源的，那么无法相互操纵 DOM。不过在实际应用中，不同源的 DOM 往往需要进行通信，因此浏览器又引入了 <strong>跨文档消息机制</strong>，即通过 <code>window.postMessage()</code>方法与 JavaScript 接口实现不同源之间的 DOM 通信。</p>
<h1 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h1><p>同源策略可以隔离不同源站点的 DOM 交互、页面数据以及网络通信。严格的同源策略会更加保证安全，但是也束缚了 Web 开发。因此需要在安全性与便捷性之间找到一个平衡点，如果浏览器默认可以引用任意第三方资源，那么就存在 XSS 风险，于是浏览器又通过 CSP 策略来加以限制。</p>
<h2 id="什么是-XSS-攻击"><a href="#什么是-XSS-攻击" class="headerlink" title="什么是 XSS 攻击"></a>什么是 XSS 攻击</h2><p><strong>跨站脚本攻击 Cross Site Scripting</strong> 是指黑客向 HTML 文件或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。跨站脚本攻击的简称为了与 CSS 进行区分，所以对齐简称为 XSS。</p>
<p>在早期，XSS 主要通过跨域实现，所以叫做跨域脚本。但是时至今日，向 HTML 或者 DOM 中注入恶意代码的方式越来越多，并不局限于跨域注入脚本，只是 XSS 这个名字沿用至今。</p>
<p>当页面被注入了恶意脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限，因此恶意脚本可以进行下列这些操作：</p>
<ul>
<li>  窃取 Cookie 信息；</li>
<li>  监听用户行为；</li>
<li>  修改 DOM；</li>
<li>  在页面中生成浮窗广告；</li>
<li>  ……</li>
</ul>
<h2 id="恶意脚本是如何注入的"><a href="#恶意脚本是如何注入的" class="headerlink" title="恶意脚本是如何注入的"></a>恶意脚本是如何注入的</h2><p>通常有三种方式注入恶意脚本：</p>
<ol>
<li>存储型 XSS 攻击。</li>
<li>反射型 XSS 攻击。</li>
<li>基于 DOM 的 XSS 攻击。</li>
</ol>
<h3 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h3><p>存储型 XSS 攻击大致需要经过下列三个步骤：</p>
<ol>
<li>黑客利用服务器漏洞将恶意脚本提交至网站服务器；</li>
<li>用户访问了包含恶意脚本的网站；</li>
<li>当用户浏览网站时，恶意脚本就会将用户的 Cookie 等数据上传到黑客服务器。</li>
</ol>
<h3 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h3><p>反射型 XSS 攻击与存储型 XSS 攻击类似，不同的地方在于，存储型 XSS 攻击是利用服务器将恶意脚本存储值服务器，随后返回至浏览器；而反射型 XSS 攻击是用户将恶意脚本发送至服务器，随后服务器将接收到的恶意脚本发送到网站。具体的过程如下：</p>
<ol>
<li>黑客利用网站漏洞将恶意脚本提交给服务器；</li>
<li>服务器将恶意脚本返回至网站；</li>
<li>恶意脚本成功在网站运行，将用户的 Cookie 等数据上传到黑客服务器。</li>
</ol>
<h3 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h3><p>基于 DOM 的 XSS 攻击并不涉及页面的 Web 服务器。具体而言，黑客通过各种⼿段将恶意脚本注入用户页面，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容。劫持类型很多，可以通过 WiFi 路由器劫持，可以通过本地恶意软件劫持……它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</p>
<h2 id="如何阻止-XSS-攻击"><a href="#如何阻止-XSS-攻击" class="headerlink" title="如何阻止 XSS 攻击"></a>如何阻止 XSS 攻击</h2><p>前面讲过，存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。</p>
<p>基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。</p>
<p>但无论是何种类型的 XSS 攻击，它们都有⼀个共同点，那就是首先向浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</p>
<p>所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p>
<p>主要有以下几种方式可以实现。</p>
<h3 id="对输入脚本进行过滤或转码"><a href="#对输入脚本进行过滤或转码" class="headerlink" title="对输入脚本进行过滤或转码"></a>对输入脚本进行过滤或转码</h3><p>我们可以在客户端或者服务器端对关键字符进行转码，比如如果出现了脚本标签 <code>&lt;script&gt;</code>，那么就将其过滤掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code:&lt;script&gt;alert(&#x27;你被 xss 攻击了&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>过滤后只留下了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br></pre></td></tr></table></figure>

<h3 id="充分利用内容安全策略-CSP"><a href="#充分利用内容安全策略-CSP" class="headerlink" title="充分利用内容安全策略 CSP"></a>充分利用内容安全策略 CSP</h3><p>CSP 大致有如下几个功能：</p>
<ul>
<li>  限制加载非同源资源文件，从而即使黑客插入了恶意脚本，该脚本也无法被加载；</li>
<li>  禁止向第三方提交数据，从而数据不会外泄；</li>
<li>  进制执行内联脚本与未授权的脚本；</li>
<li>  提供上报机制，可以帮我们尽快发现存在哪些 XSS 攻击，以便尽快修复问题。</li>
</ul>
<h3 id="使用-HttpOnly-属性"><a href="#使用-HttpOnly-属性" class="headerlink" title="使用 HttpOnly 属性"></a>使用 HttpOnly 属性</h3><p>许多的 XSS 攻击都是为了盗用 Cookie，因此可以通过 <code>HttpOnly</code> 属性来保护 Cookie 的安全。</p>
<p>服务器可以在 HTTP 响应头中的 <code>Set-Cookie</code> 字段中使用 <code>HttpOnly</code> 标记 Cookie，这样被标记的 Cookie 只能使用在 HTTP 请求中，无法通过脚本代码来读取这段 Cookie：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&quot;Set-Cookie&quot;,</span><br><span class="line">&quot;CookieName=value;Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h1><p><strong>跨站请求伪造 Cross Site Request Forgery CSRF</strong>，指引诱用户利用用户的登录状态发起跨站请求。CSRF 即利用了用户的登录状态，并通过第三方站点来进行其他操作。</p>
<p>攻击者可以通过一些技术手段欺骗用户的浏览器访问一个曾经认证过的网站并运行一些操作。由于浏览器曾经认证过，被访问的网站会认为是真正的用户在操作而去执行。这就是 CSRF 漏洞产生的原因：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p>
<p>​</p>
<p>假设某家银行转账的 URL 形式如下：<code>http://domain/withdraw?account=NAME&amp;amount=AMOUNT&amp;to=PAYEENAME</code>，那么攻击者可以在另外一个网站放置这样的代码：<code>&lt;img src=&#39;http://domain/withdraw?account=PETER&amp;amount=100&amp;to=JOHN&#39;&gt;</code>。当账户名为 Peter 的用户点击了该图片，并且此时浏览器仍然保存了 Peter 的登陆信息，那么将会自动将 100 资金转移至攻击者 John 的账户中。</p>
<p>类似的攻击形式有很多，并且可以藏身于许多地方。任何用户可以生成内容的地方都可能存在这种潜在的危机。因此，如果服务器没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p>
<p>与 XSS 攻击不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞与用户登录状态实施攻击，并且黑客无法通过 CSRF 获取用户的页面数据。因此，XSS 攻击利用的是用户对指定网站的信任，而 CSRF 利用的是网站对用户浏览器的信任。</p>
<h2 id="防范-CSRF-攻击"><a href="#防范-CSRF-攻击" class="headerlink" title="防范 CSRF 攻击"></a>防范 CSRF 攻击</h2><p>服务器防范 CSRF 攻击，通常有以下几种途径。</p>
<h3 id="充分利用-Cookie-的-SameSite-属性"><a href="#充分利用-Cookie-的-SameSite-属性" class="headerlink" title="充分利用 Cookie 的 SameSite 属性"></a>充分利用 Cookie 的 SameSite 属性</h3><p>黑客主要利用用户的登陆状态进行 CSRF 攻击，而 Cookie 就是浏览器与服务器维护登陆状态的关揵数据。</p>
<p>CSRF 攻击通常在第三方站点发起，那么要防止 CSRF 攻击，最好能够实现 <strong>从第三方站点发送请求时禁止 Cookie 的发送</strong>。</p>
<p>即：</p>
<ul>
<li>  如果 HTTP 请求是同一站点发起的请求，那么就需要保证 Cookie 数据正常发送。</li>
<li>  如果是从第三方站点发起请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器。</li>
</ul>
<p>Cookie 中的 <code>SameSite</code> 属性可以解决这个问题：在 HTTP 响应头中，通过 <code>Set-Cookie</code> 字段设置 Cookie 时，可以添加 <code>SameSite</code> 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&quot;Set-Cookie&quot;, &quot;CookieName=value;Path=/;Domain=domainvalue;SameSite=Strict&quot;);</span><br></pre></td></tr></table></figure>

<p><code>SameSite</code> 属性通常有 <code>Strict</code>、<code>Lax</code> 和 <code>None</code> 三个选项：</p>
<ul>
<li>  <code>Strict</code>：最为严格。浏览器会完全禁止第三方 Cookie；</li>
<li>  <code>Lax</code>：相对宽松。在跨站点的情况下，从第三方站点发送请求或者从第三方站点提交 <code>GET</code> 表单都会携带 Cookie。但是如果在第三方站点使用 <code>POST</code> 方法，或者通过 <code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code> 等标签加载 URL 都不会携带 Cookie；</li>
<li>  <code>None</code>：宽松。对于发送 Cookie 没有任何限制。</li>
</ul>
<h3 id="验证请求的来源站点"><a href="#验证请求的来源站点" class="headerlink" title="验证请求的来源站点"></a>验证请求的来源站点</h3><p>服务器通过请求头的 <code>Referer</code> 与 <code>Origin</code> 字段判断来源站点。</p>
<p><code>Referer</code> 记录了该 HTTP 请求的来源地址。虽然可以通过 <code>Referer</code> 字段告诉服务器 HTTP 请求的来源，但是有一些场景并不适合将来源 URL 暴露给服务器。因此可以不用上传 <code>Referer</code> 字段。</p>
<p><code>Origin</code> 记录了该 HTTP 请求的源信息（协议、域名与端口号），并不包括完整的 URL 路径。</p>
<p>服务器的策略是优先判断 <code>Origin</code> 属性，如果请求头中没有包含 <code>Origin</code> 属性，那么再根据实际情况来判断是否使用 <code>Referer</code> 值。</p>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>另外一种方式是，服务器与浏览器约定一个独立于登陆状态以外的隐藏值作为 Token。当网站向服务器发起请求时，服务器生成一个 CSRF Token 返回至网站站点并进行隐藏；当该网站站点再次向服务器发起请求时，需要携带本站点中隐藏的 CSRF Token 值。</p>
<h1 id="跨域的解决方案"><a href="#跨域的解决方案" class="headerlink" title="跨域的解决方案"></a>跨域的解决方案</h1><p><strong>跨域资源共享 Cross Origin Resource Sharing CORS</strong> 是浏览器引入的解决跨域的一个方案。CORS 可以帮助我们进行跨域访问控制，并使得我们的跨域数据传输在安全中进行。</p>
<p>要注意的一个细节是：我们的请求跨域了，那么我们的请求到底有没有发出去？</p>
<p>答案是：跨域并不是请求发不出去，而是请求正常发送，服务端收到请求返回正常结果，只是结果被浏览器拦截了。</p>
<p>CORS 允许浏览器向跨源服务器发送 <code>XMLHttpRequest</code> 请求，从而克服了 AJAX 只能同源使用的限制。但是 CORS 需要浏览器和服务器同时支持，浏览器一旦发现跨域请求，就会添加一些附加的头信息。</p>
<p>浏览器将 CORS 请求分为两类：简单请求与复杂请求。</p>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>简单请求不会触发预检。请求如果满足下列几个条件，都属于简单请求，否则属于非简单请求：</p>
<ul>
<li>请求方法是以下三种方法之一：<ul>
<li>  <code>HEAD</code></li>
<li>  <code>GET</code></li>
<li>  <code>POST</code></li>
</ul>
</li>
<li>没有人为设置以下几种字段外的请求头：<ul>
<li>  <code>Accept</code></li>
<li>  <code>Accept-Language</code></li>
<li>  <code>Content-Language</code></li>
<li>  <code>Content-Type</code> 只限于三个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>。</li>
<li>  <code>DPR</code></li>
<li>  <code>Downlink</code></li>
<li>  <code>Save-Data</code></li>
<li>  <code>Viewport-Width</code></li>
<li>  <code>Width</code></li>
</ul>
</li>
<li>  请求中的 <code>XMLHttpRequestUpload</code> 对象没有注册事件监听器。</li>
<li>  请求中没有使用 <code>ReadableStream</code> 对象。</li>
</ul>
<p>浏览器会为简单请求的请求头添加 <code>Origin</code> 字段，描述请求来源的源信息：协议、域名与端口号。</p>
<p>请求发送至服务器后，服务器如果认为该请求可接收，会在响应头 <code>Access-Control-Allow-Origin</code> 字段中指定相同的源信息或者使用 <code>*</code> 表示所有域名。</p>
<p>除此之外，响应头中可能包括 <code>Access-Control-Expose-Headers</code> 字段。由于 <code>XMLHttpRequest</code> 对象方法只能够拿到响应头的这六个字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code> 与 <code>Pragma</code>。如果 <code>XMLHttpRequest</code> 对象想要获取其他字段，服务器可以将其他字段填入 <code>Access-Control-Expose-Headers</code> 字段。</p>
<h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><p>在 CORS 策略下，复杂请求会在正式通信之前进行一次 <strong>预检</strong> 请求。</p>
<p>浏览器会先询问服务器，当前网页所在的域名是否可以请求该服务器，以及可以使用哪些 HTTP 请求头，只有得到了肯定的答复之后，才会进行正式的请求。</p>
<p><strong>预检</strong> 请求的方法是 <code>OPTIONS</code>，表示该请求用于询问。</p>
<p>服务器在收到预检请求并检查 <code>Origin</code>、<code>Access-Control-Request-Method</code> 与 <code>Access-Control-Request-Headers</code> 字段后，将对其做出响应。</p>
<ul>
<li>  如果服务器拒绝了本次预检请求，那么在返回正常 HTTP 响应报文中，HTTP 响应头将不会含有任何与 CORS 相关的头信息。</li>
<li>  如果服务器同意了本次预检请求，就会在 HTTP 响应头中添加 <code>Access-Control-Allow-Origin</code> 等字段。同时浏览器在确定服务器同意预检后，将会发出正式的 HTTP 跨域请求。</li>
</ul>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p><strong>JSONP JSON with Padding</strong> 实现跨域的原理是 <strong>利用脚本标签 <code>&lt;script&gt;</code> 不受跨域限制的漏洞，使得网页可以从其他来源中接收 JSON 数据</strong>。</p>
<p>尽管都是客户端像浏览器发送请求获取数据，但是 AJAX 受同源策略的影响，而 JSONP 不受影响，可以发起跨域请求。</p>
<p>JSONP 的优点是简单兼容性好，但是缺点也十分明显：仅支持 <code>GET</code> 方法，并且容易遭受 XSS 攻击。</p>
<h2 id="具体实现流程"><a href="#具体实现流程" class="headerlink" title="具体实现流程"></a>具体实现流程</h2><ol>
<li>定义一个辅助函数，接收请求的接口地址、参数，与一个方法名如 <code>work</code>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function jsonp(&#123;url, params, callback&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>辅助函数返回 <code>Promise</code> 实例对象，并将接口与参数整合为请求的 URL，并在 DOM 中添加 <code>script</code> 节点，指定该 URL 为 <code>script</code> 节点的 <code>src</code> 属性：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">		<span class="keyword">const</span> arrs = []</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">			arrs.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		arrs.<span class="title function_">push</span>(<span class="string">`callback=<span class="subst">$&#123;callback&#125;</span>`</span>)</span><br><span class="line">		script.<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span></span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在全局对象（浏览器中为 <code>window</code>）定义传入的方法名，将其作为最后执行的方法。在这个方法中，首先要通过 <code>resolve()</code> 改变 <code>Promise</code> 实例的状态，还需要移除已经执行结束的脚本：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">		<span class="variable language_">window</span>[callback] = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">			<span class="title function_">resolve</span>(data)</span><br><span class="line">			<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">const</span> arrs = []</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">			arrs.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		arrs.<span class="title function_">push</span>(<span class="string">`callback=<span class="subst">$&#123;callback&#125;</span>`</span>)</span><br><span class="line">		script.<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span></span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">jsonp</span>(&#123;</span><br><span class="line">	<span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/api&#x27;</span>,</span><br><span class="line">	<span class="attr">params</span>: &#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">callback</span>: <span class="string">&#x27;work&#x27;</span>,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在服务器代码中，将该接口的对应的属性值取出，并将其作为字符串形式函数调用的方法名，如 <code>work(age=20)</code>。当字符串形式的函数调用返回至浏览器后，浏览器将自动识别并查找 <code>window</code> 中是否有对应的方法名，如果有就调用：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> callback = url.<span class="title function_">parse</span>(req.<span class="property">url</span>, <span class="literal">true</span>).<span class="property">query</span>.<span class="property">callback</span></span><br><span class="line">	res.<span class="title function_">write</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(age=20)`</span>)</span><br><span class="line">	res.<span class="title function_">end</span>()</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Window-postMessage"><a href="#Window-postMessage" class="headerlink" title="Window.postMessage()"></a>Window.postMessage()</h2><p><code>window.postMessage()</code> 方法可以安全地实现跨域通信。<code>window.postMessage()</code> 方法提供了一种机制来规避同源策略的限制：</p>
<p>如果满足下列三者中的一种，那么可以通过 <code>window.postMessage()</code> 方法实现跨域通信：</p>
<p>1.页面与其打开的新窗口的数据传递；</p>
<p>2.多窗口之间数据传递；</p>
<p>3.页面与嵌套的 iframe 消息传递。</p>
<p>方法参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer])</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>otherWindow</code>：其他窗口的引用，比如 <code>iframe</code> 的 <code>contentWindow</code> 属性；</li>
<li>  <code>message</code>：发送的数据；</li>
<li>  <code>targetOrigin</code>：目标地址，指定哪些窗口能接收到数据；</li>
<li>  <code>transfer</code>：可选参数，一串与数据同时传递的 <code>Transferable</code> 对象。这些对象的所有权将被转移至消息的接收方，发送方不再具有所有权。</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><strong>WebSocket</strong> 实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 与 HTTP 都是应用层协议，也都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立持久连接之后，服务器与客户端都能主动向对方发送或接收数据。</p>
<h2 id="nginx-反向代理"><a href="#nginx-反向代理" class="headerlink" title="nginx 反向代理"></a>nginx 反向代理</h2><p>nginx 是常见的 Web 服务器，可以作为中间件转发请求。</p>
<p>nginx 可以通过反向代理实现跨域，只需要进行简单的配置。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="/assets/compute.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/02/08/js/" title="JavaScript"><img class="cover" src="/assets/js.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">JavaScript</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zhper</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhper" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content"><center>主域名：<br><a href="https://zhper.vercel.app/"><b><font color="#5ea6e5">zhper.vercel.app</font></b></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-text">HTTP 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%A1%8C"><span class="toc-text">请求行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">请求头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="toc-text">请求体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%93%8D%E5%BA%94"><span class="toc-text">HTTP 响应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E8%A1%8C"><span class="toc-text">响应行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">响应头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E4%BD%93"><span class="toc-text">响应体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E9%93%BE%E6%8E%A5"><span class="toc-text">持久链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E7%BC%93%E5%AD%98"><span class="toc-text">HTTP 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-text">强缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text">协商缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%88%B7%E6%96%B0%E6%93%8D%E4%BD%9C%E5%AF%B9-http-%E7%BC%93%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">三种刷新操作对 http 缓存的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie"><span class="toc-text">Cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Cookie"><span class="toc-text">什么是 Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-Cookie"><span class="toc-text">查看 Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E8%B7%A8%E5%9F%9F"><span class="toc-text">不可跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E6%9C%9F"><span class="toc-text">有效期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">安全性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Session"><span class="toc-text">Session</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E6%9C%9F-1"><span class="toc-text">有效期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92"><span class="toc-text">传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E7%94%A8-Cookie-%E6%97%B6"><span class="toc-text">禁用 Cookie 时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-%E4%B8%8E-Session-%E5%8C%BA%E5%88%AB"><span class="toc-text">Cookie 与 Session 区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP-1"><span class="toc-text">HTTP&#x2F;1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-0-9"><span class="toc-text">HTTP&#x2F;0.9</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-1-0"><span class="toc-text">HTTP&#x2F;1.0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">请求头与响应头</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-1-1"><span class="toc-text">HTTP&#x2F;1.1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><span class="toc-text">改进持久连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">提供虚拟主机的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">支持动态生成的内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP2"><span class="toc-text">HTTP2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-2-%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">HTTP&#x2F;2 的多路复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">多路复用的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-2-%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-text">HTTP&#x2F;2 的其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">设置请求的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81"><span class="toc-text">服务器推送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="toc-text">头部压缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTPS"><span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-text">使用对称加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-text">使用非对称加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86%EF%BC%9A%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8"><span class="toc-text">混合加密：对称加密和非对称加密搭配使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-text">数字证书</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-text">同源策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%BA%90"><span class="toc-text">同源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM"><span class="toc-text">DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%82%E9%9D%A2"><span class="toc-text">数据层面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E9%9D%A2"><span class="toc-text">网络层面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E4%BE%BF%E5%88%A9%E6%80%A7%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-text">安全性与便利性的权衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5"><span class="toc-text">内容安全策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E5%92%8C%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6"><span class="toc-text">跨域资源共享和跨文档消息机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XSS-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB"><span class="toc-text">XSS 跨站脚本攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB"><span class="toc-text">什么是 XSS 攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E6%98%AF%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5%E7%9A%84"><span class="toc-text">恶意脚本是如何注入的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9E%8B-XSS-%E6%94%BB%E5%87%BB"><span class="toc-text">存储型 XSS 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9E%8B-XSS-%E6%94%BB%E5%87%BB"><span class="toc-text">反射型 XSS 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-DOM-%E7%9A%84-XSS-%E6%94%BB%E5%87%BB"><span class="toc-text">基于 DOM 的 XSS 攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2-XSS-%E6%94%BB%E5%87%BB"><span class="toc-text">如何阻止 XSS 攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%BE%93%E5%85%A5%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4%E6%88%96%E8%BD%AC%E7%A0%81"><span class="toc-text">对输入脚本进行过滤或转码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5-CSP"><span class="toc-text">充分利用内容安全策略 CSP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-HttpOnly-%E5%B1%9E%E6%80%A7"><span class="toc-text">使用 HttpOnly 属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0"><span class="toc-text">CSRF 跨站请求伪造</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E8%8C%83-CSRF-%E6%94%BB%E5%87%BB"><span class="toc-text">防范 CSRF 攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8-Cookie-%E7%9A%84-SameSite-%E5%B1%9E%E6%80%A7"><span class="toc-text">充分利用 Cookie 的 SameSite 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9D%A5%E6%BA%90%E7%AB%99%E7%82%B9"><span class="toc-text">验证请求的来源站点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Token"><span class="toc-text">Token</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">跨域的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82"><span class="toc-text">复杂请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSONP"><span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-text">具体实现流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-postMessage"><span class="toc-text">Window.postMessage()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">nginx 反向代理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/08/css/" title="CSS"><img src="/assets/css.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS"/></a><div class="content"><a class="title" href="/2023/02/08/css/" title="CSS">CSS</a><time datetime="2023-02-07T16:00:00.000Z" title="Created 2023-02-08 00:00:00">2023-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/08/html/" title="HTML"><img src="/assets/html.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTML"/></a><div class="content"><a class="title" href="/2023/02/08/html/" title="HTML">HTML</a><time datetime="2023-02-07T16:00:00.000Z" title="Created 2023-02-08 00:00:00">2023-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/08/ts/" title="TypeScript"><img src="/assets/ts.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScript"/></a><div class="content"><a class="title" href="/2023/02/08/ts/" title="TypeScript">TypeScript</a><time datetime="2023-02-07T16:00:00.000Z" title="Created 2023-02-08 00:00:00">2023-02-08</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgb(118, 123, 126,0.1)"><div id="footer-wrap"><div class="copyright">&copy;2023 By zhper</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>