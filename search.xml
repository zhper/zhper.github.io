<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS</title>
      <link href="/2023/02/08/css/"/>
      <url>/2023/02/08/css/</url>
      
        <content type="html"><![CDATA[<h1 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h1><ul><li>  px</li></ul><p>绝对单位、精确的像素</p><ul><li>  em</li></ul><p>相对单位</p><p>基准点为父节点字体的大小。如果自身定义了 <code>font-size</code>，则按照自身计算。因此整个页面的 1em 不是一个固定的值</p><ul><li>  rem</li></ul><p>相对单位</p><p>可以理解为 root em，按照 根节点为基准进行计算的相对单位</p><ul><li>  vw，vh，vmin，vmax</li></ul><p>vw：viewpoint width，视窗宽度，1vw 等于视窗宽度的 1%。</p><p>vh：viewpoint height，视窗高度，1vh 等于视窗高度的 1%。</p><p>vmin：表示视口宽度和高度中较小的那个的百分比。你可以用它来设置长度值，比如 width, margin, padding 等, 这样他的大小就会随视口大小自适应， 1vmin 就表示较小的那个长度的 1%</p><p>vmax：表示视口宽度和高度中较小的那个的百分比。同理</p><h1 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h1><ul><li>  none</li></ul><p><code>display: none</code> 指定的元素将不会被显示</p><p>这种方式隐藏的元素不会保留空间</p><blockquote><p>相似的： <code>visible: hidden</code> 也是使元素不被显示出来，但是会保留他的空间</p></blockquote><ul><li>  block</li></ul><p><code>display: block</code> 指定元素为块级元素</p><p>特点：</p><ol><li>块级元素自己独占一行</li><li>height、width、padding、margin 都可以直接控制</li><li><strong>宽度</strong>默认是容器（<strong>父级宽度</strong>）的 100%</li><li>块级元素本身也是一个容器，里面可以放 行内元素与块级元素</li></ol><ul><li>  inline</li></ul><p><code>display: inline</code> 指定元素为行内元素</p><p>特点：</p><ol><li>相邻的行内元素在一行、一行可以显示多个行内元素</li><li>宽、高、上下的 padding、margin 不能直接设置；但是左右的 padding、margin 可以直接设置</li><li>宽度默认是他文本内容的宽度</li><li>行内元素只能容纳<strong>文本</strong>或其他<strong>行内元素</strong></li></ol><ul><li>  inline-block</li></ul><p><code>display: inline-block</code> 指定元素为行内块元素</p><p>特点：</p><ol><li> 一行能显示多个</li><li> 可以直接设置宽、高、边距</li></ol><p>元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据 white-space 的处理方式（默认是 normal，合并多余空白），原来 HTML 代码中的回车换行被转成一个空白符，在字体不为 0 的情况下，空白符占据一定宽度，所以 inline-block 的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素 font-size:16px 时，间距为 8px。</p><ul><li>  list-item</li></ul><p><code>display:list-item</code> 指定元素为列表元素</p><p>特点：</p><ul><li>  元素会生成一个 ::marker 伪元素，用来显示列表标记，比如圆点或数字</li><li>  列表标记的样式由 list-style 属性决定</li><li>  元素可以和其他 display: list-item 的元素组成一个列表，也可以嵌套在 或 元素中</li></ul><h1 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>定位由定位模式和边便宜组成</p><p>定位模式由 <code>position</code> 指定，默认值为 <code>static</code>。</p><ul><li>  <code>static</code></li></ul><p>静态定位，即没有定位，没有指定<code>position</code>或者指定为 <code>static</code>， 那么 边偏移：<code>top、right、left、bottom</code> 以及 <code>z-index</code> 无效</p><ul><li>  <code>relative</code></li></ul><p>相对定位，是相对于元素原本的位置进行定位。同时会保留原本的位置，即不会脱离标准流</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span> &gt; &lt;<span class="selector-tag">div</span> class=&#x27;box1&#x27; &gt; &lt;/<span class="selector-tag">div</span> &gt; &lt;<span class="selector-tag">div</span> class=&#x27;box2&#x27; &gt; &lt;/<span class="selector-tag">div</span> &gt; &lt;/<span class="selector-tag">body</span> &gt; <span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span>,</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog.yucohny.vercel.app/images/CSS/Position/1.png" alt="img"></p><p>现在我们对 box1 添加相对定位，并让他进行一定的偏移：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog.yucohny.vercel.app/images/CSS/Position/2.png" alt="img"></p><ul><li>  <code>absolute</code></li></ul><p>绝对定位，相对于 <code>static</code> 定位外的第一个祖先元素进行定位</p><p>如果没有祖先元素或者祖先元素没有定位（除 static），以浏览器为基准</p><p>绝对定位不会保留原来的位置，即 会脱离标准流</p><p>绝对定位后，行内元素将会变为行内块元素</p><ul><li>  <code>fixed</code></li></ul><p>固定定位，相对于浏览器窗口进行定位。同时，固定定位不再占有原先位置。</p><ul><li>  <code>sticky</code></li></ul><p>粘性定位，相对于浏览器窗口进行定位，并且必须添加 <code>top</code>、<code>left</code>、<code>right</code> 和 <code>bottom</code> 中的一个才生效。同时，粘性定位仍然占有原先位置。</p><ul><li>  <code>inherit</code></li></ul><p>继承父元素 <code>position</code> 属性。</p><h2 id="叠放次序"><a href="#叠放次序" class="headerlink" title="叠放次序"></a>叠放次序</h2><p>使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 <code>z-index</code> 属性来控制盒子的前后次序。</p><p>注意：</p><ul><li>  数值可以是正负整数，0，以及 <code>auto</code>（默认值）。如果数值越大，则说明盒子越靠上。</li><li>  如果属性值相同，则按照书写顺序后来者居上。</li><li>  数值后面不能添加单位。</li><li>  只有具有除 <code>static</code> 以外的 <code>position</code> 属性的盒子 <code>z-index</code> 属性才能生效。</li></ul><h1 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h1><p>设计初衷：<code>仅仅是让文字像流水一样环绕浮动元素</code>，就像下图中展示的一样：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c8a2caff5026e~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>特性：</p><ul><li>  包裹性</li><li>  高度塌陷</li><li>  块状化</li><li>  没有任何 margin 合并</li></ul><h2 id="包裹性"><a href="#包裹性" class="headerlink" title="包裹性"></a>包裹性</h2><p>由 “包裹” 和 “自适应” 两部分组成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS代码 */</span></span><br><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid deeppink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.father</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">128px</span>;</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>1）<strong>包裹</strong>。本例中将浮动元素父元素宽度设置为 200px，浮动元素的子元素是一个 128px 宽度的图片，则此时浮动元素宽度表现为”包裹”，也就是里面图片的宽度 128px。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* HTML代码 */</span><br><span class="line">&lt;div <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><br><span class="line">        &lt;img <span class="attr">src</span>=<span class="string">&quot;../../lib/img/mm1.png&quot;</span>&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c8a2caffc316b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="3690013586-5addce853f5e0_articlex"></p><p>2）<strong>自适应性</strong>。在浮动子元素的中增加一些文字：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* HTML代码 */</span><br><span class="line">&lt;div <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><br><span class="line">        &lt;img <span class="attr">src</span>=<span class="string">&quot;../../lib/img/mm1.png&quot;</span>&gt;</span><br><span class="line">        &lt;span <span class="attr">style</span>=<span class="string">&quot;font-size: 12px&quot;</span>&gt;美女<span class="number">1</span>，美女<span class="number">2</span>，美女<span class="number">3</span>，美女<span class="number">4</span>，美女<span class="number">5</span>，美女<span class="number">6</span>，后宫<span class="number">1</span>，后宫<span class="number">2</span>，后宫<span class="number">3</span>，后宫&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;复制代码</span><br></pre></td></tr></table></figure><p>此时，浮动元素宽度就自适应父元素的 200px 宽度，最终的宽度表现也是 200px。如下图所示：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c8a2cafeab5fc~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="4139378965-5addd23fb9ccf_articlex"></p><h2 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h2><p>即会让 <strong>父元素的高度塌陷</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c8a2caffc316b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="3690013586-5addce853f5e0_articlex"></p><p>父元素的高度没有被子元素撑开。</p><p>这是因为子元素浮动后，将会脱离标准流，同时父元素没有设置高度，这时候父元素的高度就会是 0</p><h2 id="块状化"><a href="#块状化" class="headerlink" title="块状化"></a>块状化</h2><p>设置了 float 之后， 浮动的元素会具有 **行内块元素 **的特性，即可以直接设置 宽、高、边距</p><h2 id="没有任何的-margin-重叠"><a href="#没有任何的-margin-重叠" class="headerlink" title="没有任何的 margin 重叠"></a>没有任何的 margin 重叠</h2><p>在这里，我们将<code>.son</code>类增加<code>margin:10px</code>样式，在浏览器中查看实际效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* HTML 代码 */</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../lib/img/mm1.png&quot;</span> /&gt;</span>     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../lib/img/mm1.png&quot;</span> /&gt;</span>     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../lib/img/mm1.png&quot;</span> /&gt;</span>     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/4/163c8a2cafc0db8c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="39060460-5addd255ae994_articlex"></p><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p><strong>浮动的副作用</strong></p><ol><li>父元素无法正常显示背景颜色和背景图片</li><li>父元素的边框无法撑开</li><li>内外边距无法正常显示。</li></ol><p>下面介绍清除浮动的三种方法。</p><p><strong>overflow: hidden</strong></p><p>对父元素添加 overflow: hidden。</p><blockquote><p>本质上是 BFC 模式</p></blockquote><p><strong>clear: both</strong></p><p>在浮动元素的后面添加一个块级元素，并将这个块级元素设置 clear: both 属性。</p><p><strong>伪类</strong></p><p>给父元素伪类添加 clear: both 属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><p>所有的 HTML 元素都可以看作盒子。</p><p>这个盒子包括了外边距，边框，内边距，内容四个部分：</p><p><img src="https://www.w3school.com.cn/i/css/boxmodel.gif" alt="img"></p><p>CSS3 中的盒模型有以下两种：<strong>标准盒模型</strong>、<strong>IE（替代）盒模型</strong>。通过<code>box-sizing</code> 指定</p><p>两种盒子模型都是由 <code>content + padding + border + margin</code> 构成，其大小都是由 <code>content + padding + border</code> 决定的，但是盒子内容宽/高度（即 <code>width/height</code>）的计算范围根据盒模型的不同会有所不同：</p><h2 id="标准盒子模型"><a href="#标准盒子模型" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h2><p>是<code>box-sizing</code>的默认值 即 <code>box-sizing: content-box</code></p><p>当我们直接指定一个元素的宽度和高度时，只是设置了内容区域的宽高，但是完整元素大小，必须添加内外边距和边框</p><p>元素宽高 只包含 <code>content</code></p><h2 id="IE-（代替）-盒模型"><a href="#IE-（代替）-盒模型" class="headerlink" title="IE （代替） 盒模型"></a>IE （代替） 盒模型</h2><p><code>box-sizing: border-box</code></p><p>直接设置属性的宽高，包含 <code>content + padding + border</code></p><h1 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h1><blockquote><p>水平垂直居中一般指儿子节点相对于父亲节点实现水平垂直居中。</p></blockquote><p>可以根据 <strong>居中的元素的宽高是否确定</strong> 分为两类</p><blockquote><p>注意： 任何一个元素想要实现水平垂直居中，都可以使用 【居中元素不确定宽高】的方法，只是对于确定宽高的元素而言，可以额外使用【居中元素确定宽高】的方法</p></blockquote><h2 id="居中元素确定宽高"><a href="#居中元素确定宽高" class="headerlink" title="居中元素确定宽高"></a><strong>居中元素确定宽高</strong></h2><ul><li>  绝对定位+负外边距</li><li>  绝对定位+自动外边距</li><li>  绝对定位 + <code>calc</code> 计算</li></ul><h3 id="绝对定位-负外边距"><a href="#绝对定位-负外边距" class="headerlink" title="绝对定位+负外边距"></a>绝对定位+负外边距</h3><ul><li>  首先需要将父元素设置为 <code>relative</code> ，然后子元素设置为 <code>absolute</code></li><li>  通过 <code>top: 50%; left: 50%</code> 将子元素<strong>左上角</strong>移至父元素中心</li><li>  设置 负边距（上和左）为子元素自身的一半</li></ul><h3 id="绝对定位-自动外边距"><a href="#绝对定位-自动外边距" class="headerlink" title="绝对定位+自动外边距"></a>绝对定位+自动外边距</h3><p>我们可以在绝对定位的元素中， 设置各个方向的距离都为 0， 同时设置自动外边距：<code>margin:0</code> ，就可以在各个方向上居中（如果只设置水平方向为 0， 这样就能只在水平方向上居中，垂直方向同理）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid cornflowerblue;</span><br><span class="line"></span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#div</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绝对定位-calc-计算"><a href="#绝对定位-calc-计算" class="headerlink" title="绝对定位 + calc 计算"></a>绝对定位 + <code>calc</code> 计算</h3><p>与第一种方法类似，只是可以直接通过 <code>calc()</code>计算出准确位置，注意<code>calc</code> 运算的百分号是根据父元素</p><h2 id="居中元素不确定宽高"><a href="#居中元素不确定宽高" class="headerlink" title="居中元素不确定宽高"></a><strong>居中元素不确定宽高</strong></h2><ul><li>  绝对定位 + <code>transform</code></li><li>  设置行高与行内居中</li><li>  <code>table-cell</code></li><li>  弹性布局（<code>flex</code>）</li><li>  网格布局（<code>grid</code>）</li></ul><h3 id="绝对定位-translate"><a href="#绝对定位-translate" class="headerlink" title="绝对定位 + translate"></a>绝对定位 + <code>translate</code></h3><p>思路类似， 注意 <code>translate</code> 中的百分比是相对于自身元素的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta charset=&quot;UTF-<span class="number">8</span>&quot;&gt;</span><br><span class="line">   &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">   &lt;style&gt;</span><br><span class="line">       <span class="selector-id">#div</span> &#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">           <span class="attribute">border</span>: <span class="number">2px</span> solid cornflowerblue;</span><br><span class="line"></span><br><span class="line">           <span class="attribute">position</span>: relative;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="selector-id">#div</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">           <span class="attribute">position</span>: absolute;</span><br><span class="line">           <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">           <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">           <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">   &lt;<span class="selector-tag">div</span> id=&quot;<span class="selector-tag">div</span>&quot;&gt;</span><br><span class="line">       &lt;<span class="selector-tag">div</span>&gt;<span class="attribute">Content</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">   &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="设置行高与行内居中"><a href="#设置行高与行内居中" class="headerlink" title="设置行高与行内居中"></a>设置行高与行内居中</h3><blockquote><p>注意这种方式是在父元素上面设置</p></blockquote><p>设置行内居中属性 <code>text-align: center</code> 可以使具有<strong>行内特征</strong>的元素在水平方向上居中，注意此时就不需要设置定位了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid cornflowerblue;</span><br><span class="line"></span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#div</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要设置垂直方向上的居中，可以将父元素的<code>line-height</code> 设置为自身的高，这样整个父亲节点仅可以容纳一行元素，从而实现垂直方向上的居中， 但是注意，由于<strong>行内元素</strong>默认是基线对齐，所有如果子元素是<strong>行内块元素</strong>，同时设置了一定的宽高，我们这样只是让他的基线垂直居中了，我们可以在子元素上设置 <code>vertical-algin: middle</code>，就可以垂直居中了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#div</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a>table-cell</h3><p>在表格中，我们可以使用 <code>text-align</code> 与 <code>vertical-align</code> 分别实现水平与垂直方向上的居中，而 <code>display: table-cell</code> 属性则可以将元素设置为具有表格单元格元素的特性，</p><p>注意，如果子元素是行内块元素，同时设置了宽高，那么里面的文本将会按照基线对齐</p><p><img src="C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230227162523079.png" alt="image-20230227162523079"></p><p>我们可以将该子元素设置为 <code>vertical-align: middle</code> ，来使文本垂直居中</p><h3 id="弹性布局与网格布局"><a href="#弹性布局与网格布局" class="headerlink" title="弹性布局与网格布局"></a>弹性布局与网格布局</h3><p>见相关章节</p><h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p>FC(Formatting Context),，元素在标准流里面都属于一个 FC 的， 可能是一个 block, 或者 inline， 但不能同时属于， 块级参与 BFC 的布局中， 行内元素参与 IFC 的布局中</p><p>BFC （block formatting context）</p><p>下列情况会创建 BFC</p><p><img src="C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230227173904733.png" alt="image-20230227173904733"></p><p>BFC 作用（或者说规范）</p><p>在 BFC 中。盒子将会在垂直方向上 从顶部 一个接着一个排列， 盒子间的距离，通过 margin 设置， 垂直方向上，相邻两个块级元素在<strong>同一个 BFC 中</strong>的 margin 会折叠， 每一个盒子的左边将会包含块的左边缘</p><ul><li>  解决 margin 的折叠问题</li></ul><p>下面所示的代码一定会产生 margin 折叠问题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css"><span class="attribute">margin-bottom</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">height</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background-color</span>: purple;</span></span><br><span class="line"><span class="language-css"><span class="attribute">margin-top</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们要利用 BFC 解决折叠问题，就要将 box1 和 box2 处于不同的 BFC 中，于是我们可以利用 <code>overflow: 除 visible外</code></p><p>但是这里要注意，我们不能直接在 box1 中设置 <code>overflow</code>， 这样设置，box1 和 box2 依然处于 html 的 BFC 中， 只是 box1 内部创建了一个新的 BFC， 所以我们在 box1 外套一层，以此创建新的 BFC</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">overflow</span>: auto;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css"><span class="attribute">margin-bottom</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">height</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background-color</span>: purple;</span></span><br><span class="line"><span class="language-css"><span class="attribute">margin-top</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>  解决浮动高度的塌陷问题</li></ul><p>BFC 中高度是 auto 的情况下，按照如下方法计算高度</p><ol><li>如果只有 inline-level 是行高的顶部和底部的距离</li><li>如果只有 block-level 是由<strong>最底层</strong>的块上边缘和最底层块盒子下边缘之间的距离</li><li>如果有绝对定位元素，将被忽略</li><li>如果有浮动元素，那么会增加高度以包括这些浮动元素的下边缘</li></ol><ul><li>  实现两栏布局（左侧固定 + 右侧自适应）</li></ul><p>BFC 区域不会与浮动的容器发生重叠</p><p>每个元素的左 margin 值 和 容器的 左 border 相接触</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.outer</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css"><span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background</span>: lightcoral;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">overflow</span>: auto;</span></span><br><span class="line"><span class="language-css"><span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css"><span class="attribute">background</span>: lightseagreen;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="重排（reflow）和重绘（repaint）的理解"><a href="#重排（reflow）和重绘（repaint）的理解" class="headerlink" title="重排（reflow）和重绘（repaint）的理解"></a>重排（reflow）和重绘（repaint）的理解</h1><p>简单地总结下两者的概念：</p><ul><li>  重排：无论通过什么方式影响了元素的<strong>几何信息</strong>(元素在视口内的位置和尺寸大小)，浏览器需要<strong>重新计算</strong>元素在视口内的几何属性，这个过程叫做重排。</li><li>  重绘：通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的<strong>实际像素</strong>，这个阶段就叫做重绘。</li></ul><h1 id="选择器和优先级"><a href="#选择器和优先级" class="headerlink" title="选择器和优先级"></a>选择器和优先级</h1><p>首先我们要知道有哪些选择器：<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors%23%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%82%E8%80%83%E8%A1%A8">选择器参考表</a>。</p><p><strong>优先级计算</strong></p><p>上述文章中核心内容： 优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p><ul><li>  如果存在内联样式，那么 <code>A = 1</code>，否则 <code>A = 0</code> ；</li><li>  B 的值等于 <code>ID选择器（#id）</code> 出现的次数；</li><li>  C 的值等于 <code>类选择器（.class）</code> 和 <code>属性选择器（a[href=&quot;https://example.org&quot;]）</code> 和 <code>伪类（:first-child）</code> 出现的总次数；</li><li>  D 的值等于 <code>标签选择器（h1,a,div）</code> 和 <code>伪元素（::before,::after）</code> 出现的总次数。</li></ul><h1 id="flex（弹性布局）"><a href="#flex（弹性布局）" class="headerlink" title="flex（弹性布局）"></a>flex（弹性布局）</h1><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img"></p><h2 id="声明为弹性容器"><a href="#声明为弹性容器" class="headerlink" title="声明为弹性容器"></a>声明为弹性容器</h2><p>有以下两种方式将元素声明为弹性容器：</p><ul><li>  <code>display: flex</code> 属性可以将元素声明为块级弹性容器；</li><li>  <code>display: inline-flex</code> 属性可以将元素声明为行内弹性容器。</li></ul><p>弹性容器中存在主轴与交叉轴，默认主轴为垂直方向，交叉轴为水平方向。</p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><ul><li>  flex-direction</li></ul><p>决定主轴的方向，即项目的排列方向</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br><span class="line">row（默认值）：主轴为水平方向，起点在左端。</span><br><span class="line">row-reverse：主轴为水平方向，起点在右端。</span><br><span class="line">column：主轴为垂直方向，起点在上沿。</span><br><span class="line">column-reverse：主轴为垂直方向，起点在下沿。</span><br></pre></td></tr></table></figure><ul><li>  flex-wrap</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br><span class="line">nowrap（默认） ： 不换行</span><br><span class="line">wrap： 换行，第一行在上方</span><br><span class="line">wrap-reverse：换行，第一行在下方。</span><br></pre></td></tr></table></figure><p>如果想要研究为什么换行之后第二行没有紧贴第一行排列，可以参见下面小节 <code>align-content</code></p><ul><li>  flex-flow</li></ul><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  justify-content</li></ul><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">flex</span>-start（默认值）：左对齐</span><br><span class="line"><span class="attribute">flex</span>-end：右对齐</span><br><span class="line">center： 居中</span><br><span class="line">space-between：两端对齐，项目之间的间隔都相等。</span><br><span class="line">space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br></pre></td></tr></table></figure><ul><li>  align-items</li></ul><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">flex</span>-start：交叉轴的起点对齐。</span><br><span class="line"><span class="attribute">flex</span>-end：交叉轴的终点对齐。</span><br><span class="line">center：交叉轴的中点对齐。</span><br><span class="line">baseline: 项目的第一行文字的基线对齐。</span><br><span class="line">stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br></pre></td></tr></table></figure><ul><li>  align-content</li></ul><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">flex</span>-start：与交叉轴的起点对齐。</span><br><span class="line"><span class="attribute">flex</span>-end：与交叉轴的终点对齐。</span><br><span class="line">center：与交叉轴的中点对齐。</span><br><span class="line">space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</span><br><span class="line">space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span><br><span class="line">stretch（默认值）：轴线占满整个交叉轴。</span><br></pre></td></tr></table></figure><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><ul><li>  <code>order</code></li></ul><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>flex-grow</code></li></ul><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在<strong>剩余空间</strong>，也不放大。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的<code>flex-grow</code>属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p><ul><li>  <code>flex-shrink</code></li></ul><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p><p>负值对该属性无效。</p><ul><li>  <code>flex-basis</code></li></ul><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如 350px），则项目将占据固定空间。</p><ul><li>  <code>flex</code></li></ul><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: none | [ &lt; <span class="string">&#x27;flex-grow&#x27;</span> &gt; &lt; <span class="string">&#x27;flex-shrink&#x27;</span> &gt;? || &lt; <span class="string">&#x27;flex-basis&#x27;</span> &gt; ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><ul><li>  flex: 1 即 1 1 0%, 使用 flex: 1 会使元素自身设置的高度不起作用</li></ul><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><ul><li>  <code>align-self</code></li></ul><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="line-height-如何继承？"><a href="#line-height-如何继承？" class="headerlink" title="line-height 如何继承？"></a>line-height 如何继承？</h1><ul><li>  父元素的 <code>line-height</code> 写了<strong>具体数值</strong>，比如 <code>30px</code>，则子元素 <code>line-height</code> 继承该值。</li><li>  父元素的 <code>line-height</code> 写了<strong>比例</strong>，比如 <code>1.5 或 2</code>，则子元素 <code>line-height</code> 也是继承该比例。</li><li>  父元素的 <code>line-height</code> 写了<strong>百分比</strong>，比如 <code>200%</code>，则子元素 <code>line-height</code> 继承的是父元素 <code>font-size * 200%</code> 计算出来的值。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2023/02/08/html/"/>
      <url>/2023/02/08/html/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML-语义化"><a href="#HTML-语义化" class="headerlink" title="HTML 语义化"></a>HTML 语义化</h2><ul><li>  让人跟容易看懂（增加代码的可读性）</li><li>  让搜索引擎更容易看懂</li><li>  在没有 CSS 样式下，页面也能呈现出很好的内容结构、代码结构</li></ul><h2 id="script-标签中的属性"><a href="#script-标签中的属性" class="headerlink" title="script 标签中的属性"></a>script 标签中的属性</h2><p>HTML 中的 <code>&lt;script&gt;</code> 标签包含下列 8 个属性：</p><ul><li>  <code>async</code></li><li>  <code>charset</code></li><li>  <code>crossorigin</code></li><li>  <code>defer</code></li><li>  <code>integrity</code></li><li>  <code>language</code></li><li>  <code>src</code></li><li>  <code>type</code></li></ul><p>我们重点关注 <code>async</code> 和 <code>defer</code> 属性</p><p><code>script</code> 如果上面两个属性都不包括，那么此时的 <code>script</code> 标签将会阻碍 HTML 的解析，只有下载成功并执行完脚本，才会继续解析 HTML。</p><p><code>async script</code> 属性表示异步下载，即在解析 HTML 的过程中进行脚本的异步下载，下载成功后立刻执行（仍然可能阻断 HTML 的解析）</p><ul><li>  下载完就执行</li></ul><p><code>defer script</code> 属性同样是在解析 HTML 的过程进行脚本的异步下载，但是只有在 HTML 解析完成之后才会顺序执行脚本</p><ul><li>  渲染完再执行</li></ul><p>在 <code>&lt;script&gt;</code> 元素中的代码被计算完成之前，页面的其余内容不会被加载，也不会被显示</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea091aed8364b88a653a13c4845a824~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h1 id="从浏览器地址栏输入-url-到请求返回发生了什么"><a href="#从浏览器地址栏输入-url-到请求返回发生了什么" class="headerlink" title="从浏览器地址栏输入 url 到请求返回发生了什么"></a>从浏览器地址栏输入 url 到请求返回发生了什么</h1><ol><li>首先会通过 URL 接续出协议、主机、端口号、路径等信息，构造出一个 HTTP 请求</li><li>通过 DNS，得到 IP 地址</li><li>通过三次握手建立 TCP 链接</li><li>发起 HTTP 请求</li><li>服务端处理请求并返回 HTTP 报文</li><li>浏览器渲染页面</li><li>通过四次挥手断开链接</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2023/02/08/ts/"/>
      <url>/2023/02/08/ts/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>Promise 是 JS 中进行异步编程的新解决方案</p><p>备注：旧方案是单纯使用回调函数</p><p>从语法上来说: Promise 是一个构造函数</p><p>从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功失败的结果值</p><p>promise 支持链式调用，可以解决回调地狱问题</p><p><img src="C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230207215542285.png" alt="image-20230207215542285"></p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2023/02/08/js/"/>
      <url>/2023/02/08/js/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="原始数据类型（简单数据类型）"><a href="#原始数据类型（简单数据类型）" class="headerlink" title="原始数据类型（简单数据类型）"></a>原始数据类型（简单数据类型）</h2><p><code>Undefined</code>、<code>Null</code>、<code>Bollean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>、<code>BigInt</code></p><h2 id="引用类型（复杂数据类型）"><a href="#引用类型（复杂数据类型）" class="headerlink" title="引用类型（复杂数据类型）"></a>引用类型（复杂数据类型）</h2><p><code>Object</code></p><p>其中 <code>Symbol</code>和 <code>BigInt</code> 是 ES6 新增的数据类型</p><ul><li>  <code>Symbol</code></li></ul><p>每个从 <code>Symbol()</code> 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">sym2 === sym3 <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li>  <code>BigInt</code></li></ul><p>表示大于 <code>2^53-1</code> 的整数，这是在 js 中 <code>Number</code> 可以表示的最大数字</p><p>可以在一个整数字面量后面加上<code>n</code>的方式定义一个 <code>BigInt</code> ： <code>10n</code>， 也可以直接使用<code>BigInt()</code> 包裹一个数字或者字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theBiggestInt = <span class="number">9007199254740991n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alsoHuge = <span class="title class_">BigInt</span>(<span class="number">9007199254740991</span>)</span><br><span class="line"><span class="comment">// ↪ 9007199254740991n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hugeString = <span class="title class_">BigInt</span>(<span class="string">&#x27;9007199254740991&#x27;</span>)</span><br><span class="line"><span class="comment">// ↪ 9007199254740991n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hugeHex = <span class="title class_">BigInt</span>(<span class="string">&#x27;0x1fffffffffffff&#x27;</span>)</span><br><span class="line"><span class="comment">// ↪ 9007199254740991n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hugeBin = <span class="title class_">BigInt</span>(</span><br><span class="line"><span class="string">&#x27;0b11111111111111111111111111111111111111111111111111111&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// ↪ 9007199254740991n</span></span><br></pre></td></tr></table></figure><h2 id="赋值变动过程"><a href="#赋值变动过程" class="headerlink" title="赋值变动过程"></a>赋值变动过程</h2><ul><li>  值类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a = <span class="number">200</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55df6cb63d3346be9ec1f572a1514853~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片 1.png"></p><p>值类型的数据直接存储在 <code>栈(stack)</code> 中， 数据简单，空间小，大小固定</p><ul><li>  引用类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">b.<span class="property">age</span> = <span class="number">30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">age</span>) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56c5c43d1c584ed4b8e4cce8855bab52~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片 2.png"></p><p>引用类型的数据存储在 <code>堆（heap）</code> 中， 数据复杂，空间大、大小不固定</p><h1 id="检测数据类型"><a href="#检测数据类型" class="headerlink" title="检测数据类型"></a>检测数据类型</h1><ul><li>  <strong>typeof</strong> : 能判断所有 值类型、函数，但是不能直接对 <strong>null(空对象)、对象、数组</strong>进行判断， 都返回 <code>object</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>) <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>) <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>) <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)) <span class="comment">// symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2172141653n</span>) <span class="comment">// bigint</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) <span class="comment">// function</span></span><br><span class="line"><span class="comment">// 不能判别</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []) <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;) <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// object</span></span><br></pre></td></tr></table></figure><ul><li>  <strong>instanceof</strong>: 能判断对象类型， 运行机制是判断在其 原型链 中能否找到该类型的原型, 检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vortesnail = <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vortesnail <span class="keyword">instanceof</span> <span class="title class_">People</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vortesnail <span class="keyword">instanceof</span> <span class="title class_">Student</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>  <strong>Object.prototype.toString.call()</strong>: 能够判断所有的原始数据类型，同时包括 <strong>Error 对象、Date 对象等</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">2</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>) <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>) <span class="comment">// &quot;[object Math]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure><ul><li>  检测数组类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) <span class="comment">//利用 Array的isArray</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// 利用instanceof</span></span><br><span class="line">arr.<span class="property">__proto</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">//利用原型链，实际上 instanceof 原理也是如此</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr) <span class="comment">//利用这个方法</span></span><br><span class="line">arr.<span class="property">constructor</span> === <span class="title class_">Array</span> <span class="comment">//利用构造函数,实例的构造函数属性 constructor 指向构造函数</span></span><br></pre></td></tr></table></figure><h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><ul><li>  浅拷贝</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/1/16ce894a1f1b5c32~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><ul><li>  深拷贝</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/1/16ce893a54f6c13d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p><h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><h3 id="乞丐版"><a href="#乞丐版" class="headerlink" title="乞丐版"></a>乞丐版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure><h3 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h3><p>基于浅拷贝的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> cloneTarget = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">cloneTarget[key] = target[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们利用递归来解决深层的对象</p><ul><li>  若是原始数据类型，直接返回</li><li>  若是引用类型，我们创建一个新对象，将需要克隆的对象的属性递归到这个新对象上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> cloneTarget = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">cloneTarget[key] = <span class="title function_">clone</span>(target[key])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于只存在对基本数据类型，这个就够了，但是并没有考虑数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">cloneTarget[key] = <span class="title function_">clone</span>(target[key])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>如果我们有下面这种例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">field1</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">field2</span>: <span class="literal">undefined</span>,</span><br><span class="line"><span class="attr">field3</span>: &#123;</span><br><span class="line"><span class="attr">child</span>: <span class="string">&#x27;child&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">field4</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">&#125;</span><br><span class="line">target.<span class="property">target</span> = target</span><br></pre></td></tr></table></figure><p>此时<code>target</code>内部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">field1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">field2</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">field3</span>: &#123; <span class="attr">child</span>: <span class="string">&#x27;child&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">field4</span>: [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span> ],</span><br><span class="line">  <span class="attr">target</span>: [<span class="title class_">Circular</span> *<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230212110721837.png" alt="image-20230212110721837"></p><p>如果这时候我们调用上面的拷贝函数，会得到如下结果</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/1/16ce894778498ae4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>因为在其内部无限递归，导致栈溢出</p><p>我们使用一组 Map 来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，我们首先去 Map 中找</p><ul><li>  检查<code>map</code>中有无克隆过的对象</li><li>  有 - 直接返回</li><li>  没有 - 将当前对象作为<code>key</code>，克隆对象作为<code>value</code>进行存储</li><li>  继续克隆</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (map.<span class="title function_">get</span>(target)) &#123;</span><br><span class="line"><span class="keyword">return</span> map.<span class="title function_">get</span>(target)</span><br><span class="line">&#125;</span><br><span class="line">map.<span class="title function_">set</span>(target, cloneTarget)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">cloneTarget[key] = <span class="title function_">clone</span>(target[key], map)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target, <span class="string">&#x27;:&#x27;</span>, map.<span class="title function_">get</span>(target))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中需要注意的是，我们将 target 和 cloneTarget 通过链接， 下面对 cloneTarget 的改变是会同步更新的，因为这里也相当于将他们的地址进行链接</p><p><strong>最后 cloneTarget 的 target 属性也会指向 cloneTarget 的地址，造成循环引用</strong></p><p>对于上面的输出，我们会有下面的过程</p><p><img src="C:\Users\zzzzp\AppData\Roaming\Typora\typora-user-images\image-20230212110910532.png" alt="image-20230212110910532"></p><h1 id="根据-0-1-0-2-0-3，讲讲-IEEE-754-，如何让其相等？"><a href="#根据-0-1-0-2-0-3，讲讲-IEEE-754-，如何让其相等？" class="headerlink" title="根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？"></a>根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？</h1><h2 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h2><p>JavaScript 的数字是 IEEE-754 标准存储的双精度浮点数类型。双精度浮点数总共有 64 位（bit），第一位用于表示符号，接着十一位用于表示阶码，剩余的五十二位用于表示尾数。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/453cabd88adc477a9f6548fca7e35268~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e446a5d6d9784281b1dfd43096510c7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>同时， 在阶码运算时需要在二进制运算的基础上，手动减去 1023 才是真正表达的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01111111111</span> <span class="comment">// 0</span></span><br><span class="line"><span class="number">10000000000</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">11111111110</span> <span class="comment">// 1023</span></span><br><span class="line"><span class="number">00000000000</span> <span class="comment">// -1023</span></span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li>  <strong>进制转换</strong>: 在将 0.1、0.2 转换为二进制时，他们的尾数是无限循环的， 但是最多只能存储 53 位有效数字（包括默认的 1）， 所以会造成进度的损失</li><li>  <strong>对阶运算</strong>: 由于指数位数的不太，运算时阶数小的需要根据阶差右移，相加后根据 0 舍 1 入， 尾数位移时可能会发生数丢失的情况，影响精度。</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>转换为整数运算</li><li>使用 <code>Number.EPSILON</code> 误差范围</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEqual</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(a - b) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEqual</span>(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Number.EPSILON</code> 的实质是一个可以接受的最小误差范围，一般来说为 <code>Math.pow(2, -52)</code> 。</p><h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><ul><li>  每一个<strong>函数</strong>都有一个<code>prototype</code> 属性， 这个属性指向 调用该构造函数而创建的<strong>实例</strong>的原型</li><li>  每一个 JavaScript 对象（null 除外），在创建的时候就会与之关联另一个对象，这个对象就是原型，每一个对象都会从原型”继承”属性</li></ul><p><img src="https://camo.githubusercontent.com/02789d6806b75d34b2017021f58efa3aa7a2ee6be8a0c05fb3293438884b9ec0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065312e706e67" alt="构造函数和实例原型的关系图"></p><ul><li>  每一个 JavaScript 对象（null）除外，都具有一个 <code>__proto__</code> 属性，这个属性指向该对象的原型</li></ul><p><img src="https://camo.githubusercontent.com/3dde335faa15d03ffe3b907f6e5c2b5f4d2183caa4c47ac7486794bc407f663c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065322e706e67" alt="实例与实例原型的关系图"></p><ul><li>  每一个原型都有一个 <code>constructor</code> 属性，指向与之相关联的构造函数</li></ul><p><img src="https://camo.githubusercontent.com/0aaf005afda83d4e2fdd2bbe523df228b567a091317a2154181771b2706ea2ef/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065332e706e67" alt="实例原型与构造函数的关系图"></p><ul><li>  当实例读取属性，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就查找原型的原型，直到最顶层</li></ul><p><img src="https://camo.githubusercontent.com/ad0ee0e2594c1ac471bbb42321963c130f4fe1ef9ec70389c8ced54544d3fd6c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065342e706e67" alt="原型的原型关系图"></p><ul><li>  <code>Object.prototype</code> 的原型就是 null, 所有可以说 <code>Object.prototype</code> 没有原型</li></ul><p><img src="https://camo.githubusercontent.com/9a69b0f03116884e80cf566f8542cf014a4dd043fce6ce030d615040461f4e5a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065352e706e67" alt="原型链示意图"></p><ul><li>  原型链就是 由相互关联的原型组成的链状结构</li></ul><h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><ul><li><p>  JavaScript 分为<strong>函数对象</strong>和<strong>普通对象</strong>，每个对象都有<code>__proto__</code>属性，但是只有函数对象才有<code>prototype</code>属性</p></li><li><p>  Object、Function 都是 js 内置的<strong>函数</strong>, 类似的还有我们常用到的 Array、RegExp、Date、Boolean、Number、String</p></li></ul><p>于是我们有下图</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line"><span class="keyword">let</span> f2 = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a61ca07672a45d3aecf382100cc9719~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>理解一下，然后自己能通过代码画出来这个，就没问题了</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>将下面四篇文章仔细研读</p><ul><li>  <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/4">JavaScript 深入之执行上下文栈</a>；</li><li>  <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/5">JavaScript 深入之变量对象</a>；</li><li>  <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/6">JavaScript 深入之作用域链</a>；</li><li>  <a href="https://link.juejin.cn/?target=https://www.ruanyifeng.com/blog/2018/06/javascript-this.html">JavaScript 的 this 原理</a></li><li>  <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/8">JavaScript 深入之执行上下文</a>。</li></ul><p>总结：当 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：</p><ul><li><p>  变量对象（Variable object，VO）</p></li><li><p>  作用域链（Scope chain）</p></li><li><p>  this</p></li></ul><h1 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h1><ul><li><p>  作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。换句话说，作用域决定了代码区块中变量和其他资源的可见性。（全局作用域、函数作用域、块级作用域）</p></li><li><p>  作用域链：从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。（由多个执行上下文的<strong>变量对象</strong>构成的链表就叫做作用域链，可以同时将 执行上下文 看了再仔细理解）</p></li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul><li>  是指程序源代码中定义变量的区域</li><li>  确定当前执行代码对变量的访问权限</li><li>  JavaScript 采用的是词法作用域（也就是 静态作用域）</li></ul><h2 id="静态作用域-与-动态作用域"><a href="#静态作用域-与-动态作用域" class="headerlink" title="静态作用域 与 动态作用域"></a>静态作用域 与 动态作用域</h2><ul><li>  静态作用域</li></ul><p>函数的作用域在函数定义的时候就已经决定了</p><ul><li>  动态作用域</li></ul><p>函数的作用域是在函数调用的时候采决定的</p><p>下面有个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">2</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br></pre></td></tr></table></figure><p>结果会是 <code>1</code></p><ul><li>  静态作用域的分析过程</li></ul><p>执行 <code>foo</code> 函数，查找函数内部是否有局部变量 <code>value</code> ，如果没有，就根据<strong>书写的位置</strong>，查找上面一层的代码， 即 <code>value = 1</code></p><ul><li>  动态作用域的分析过程</li></ul><p>执行 <code>foo</code> 函数， 查找函数内部是否有局部变量 <code>value</code>， 如果没有， 就从调用函数的作用域， 即 <code>bar</code> 函数内部查找 <code>value</code> 变量， 即 <code>value = 2</code></p><p>下面有个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> scope</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkscope</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> scope</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkscope</span>()()</span><br></pre></td></tr></table></figure><p>两者的结果都是 <code>local scope</code></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><ol><li>函数声明</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数表达式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Function 构造函数 (几乎无人使用)， 这里不做叙述</li></ol><p>值得注意的是： JavaScript 在任何代码执行之前，都会先读取函数声明，并在执行上下文中生成函数定义，而函数表达式需要等到代码执行到所在位置，才会在执行上下文中生成函数定义</p><p>所以上述两段代码中，第一段可以正常运行，称为<strong>函数声明提升</strong></p><h2 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h2><ul><li>  name 属性</li></ul><p>将返回函数的名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">f1.<span class="property">name</span> <span class="comment">//f1</span></span><br></pre></td></tr></table></figure><p>如果是通过变量赋值定义的函数， 那么 <code>name</code> 属性将返回变量名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">f2.<span class="property">name</span> <span class="comment">// &quot;f2&quot;</span></span><br></pre></td></tr></table></figure><p>但是，如果变量的值是一个具名函数，而不是上面这种匿名函数， <code>name</code>属性返回<code>function</code> 关键字之后的那个函数名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">function</span> <span class="title function_">myName</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">f3.<span class="property">name</span> <span class="comment">// &#x27;myName&#x27;</span></span><br></pre></td></tr></table></figure><p>如果函数没有名称，会显示为空字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="function">() =&gt;</span> &#123;&#125;.<span class="property">name</span>)</span><br></pre></td></tr></table></figure><p>如果是使用 <code>Function</code> 构造函数创建的，则会标识成 <code>anonymous</code>。</p><p>如果函数是一个获取函数、设置函数，或者使用了 <code>bind()</code> 进行实例化，那么标识符会在结果前面加上一个前缀：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">bind</span>(<span class="literal">null</span>).<span class="property">name</span>) <span class="comment">// bound foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="attr">years</span>: <span class="number">1</span>,</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">year</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">years</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">year</span>(<span class="params">newYear</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">years</span> = newYear</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> propertyDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;year&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">get</span>.<span class="property">name</span>) <span class="comment">// get year</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">set</span>.<span class="property">name</span>) <span class="comment">// set year</span></span><br></pre></td></tr></table></figure><ul><li>  length 属性</li></ul><p>函数的<code>length</code>属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b</span>) &#123;&#125;</span><br><span class="line">f.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码定义了空函数<code>f</code>，它的<code>length</code>属性就是定义时的参数个数。不管调用时输入了多少个参数，<code>length</code>属性始终等于 2。</p><ul><li>  toString()</li></ul><p>函数的<code>toString()</code>方法返回一个字符串，内容是函数的源码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">a</span>()</span><br><span class="line"><span class="title function_">b</span>()</span><br><span class="line"><span class="title function_">c</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// function f() &#123;</span></span><br><span class="line"><span class="comment">//  a();</span></span><br><span class="line"><span class="comment">//  b();</span></span><br><span class="line"><span class="comment">//  c();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>对于那些原生的函数，<code>toString()</code>方法返回<code>function ()&#123;[native code]&#125;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">sqrt</span>.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// &quot;function sqrt() &#123; [native code] &#125;&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Math.sqrt()</code>是 JavaScript 引擎提供的原生函数，<code>toString()</code>方法就返回原生代码的提示。</p><p>函数内部的注释也可以返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// &quot;function f()&#123;/*</span></span><br><span class="line"><span class="comment">//   这是一个</span></span><br><span class="line"><span class="comment">//   多行注释</span></span><br><span class="line"><span class="comment">// */&#125;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>如果函数定义了两个参数，但是运行时无论提供多少个参数，JavaScript 都不会报错。而省略的参数的值就变为 <code>undefined</code>。</p><p>但是没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入 <code>undefined</code>。</p><ul><li>  同名参数</li></ul><p>如果有同名的参数，则取最后出现的那个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, a</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>即使后面的<code>a</code>没有值或被省略，也是以其为准。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, a</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>调用函数<code>f()</code>的时候，没有提供第二个参数，<code>a</code>的取值就变成了<code>undefined</code>。这时，如果要获得第一个<code>a</code>的值，可以使用<code>arguments</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, a</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h2><p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">one</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>正常模式下，<code>arguments</code>对象可以在运行时修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line"><span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line"><span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系。也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line"><span class="string">&#x27;use strict&#x27;</span> <span class="comment">// 开启严格模式</span></span><br><span class="line"><span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line"><span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><blockquote><p>注意： 箭头函数不存在 arguments 对象</p></blockquote><ul><li>  与数组的关系</li></ul><p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</p><p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> args = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">args.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  callee 属性</li></ul><p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span> === f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = <span class="number">5</span></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span> <span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">2</span> <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用参数默认值时，函数不能有同名参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, x, y</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, x, y = <span class="number">1</span></span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure><p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><ul><li>  参数默认值的位置</li></ul><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入<code>undefined</code>。</p><h2 id="reset-参数"><a href="#reset-参数" class="headerlink" title="reset 参数"></a>reset 参数</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...values</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">sum += val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>实际上 reset 参数也是用了 扩展运算符</p><h2 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul><li>  在标准函数中，this 引用的是<strong>把函数当作方法调用的上下文对象</strong> （可变的）</li><li>  在箭头函数中，this 引用的是<strong>定义箭头函数的上下文</strong> （固定的）</li></ul><h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><ul><li>  函数的 caller 属性引用的是调用当前函数的函数，如果是在全局作用域中国调用，则该属性为 null。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">B</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(B.<span class="property">caller</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">A</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ƒ A() &#123;</span></span><br><span class="line"><span class="comment">//     B()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><ul><li>  当函数如果是<strong>作为构造函数调用</strong>，那么在该函数中的 new.target 指向该构造函数；如果函数没有使用 new 关键字，那么 new.target 的值变为 undefined。我们可以使用该值来判断函数是否作为构造函数调用：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;People must be instantiated using &quot;new&quot;&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;People instantiated using &quot;new&quot;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>参考博客： <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/9">JavaScript 深入之闭包</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">//error</span></span><br><span class="line">我们无法获得函数内部的局部变量</span><br></pre></td></tr></table></figure><p>但我们可以通过在函数内部定义一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> z = <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">z</span>()) <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>闭包就是上面的<code>c</code> 函数, 闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p>MDN 对闭包的定义为：</p><blockquote><p>闭包是指那些能够访问自由变量的函数</p></blockquote><p>那什么是自由变量呢？</p><blockquote><p>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。</p></blockquote><p>由此，我们可以看出闭包共有两部分组成：</p><blockquote><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><p>也可以简单理解为 定义在函数内部的函数</p><p>ECMAScript 中，闭包指的是：</p><ol><li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li><li>从实践角度：以下函数才算是闭包：<ol><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li><li>在代码中引用了自由变量</li></ol></li></ol><p>在某个内部函数的执行上下文创建时，会将父级函数的<strong>活动对象</strong>加到内部函数的 <code>[[scope]]</code> 中，形成作用域链，所以即使父级函数的执行上下文销毁（即执行上下文栈弹出父级函数的执行上下文），但是因为其<strong>活动对象</strong>还是实际存储在内存中可被内部函数访问到的，从而实现了闭包。</p><h2 id="call、apply、bind-手写"><a href="#call、apply、bind-手写" class="headerlink" title="call、apply、bind 手写"></a>call、apply、bind 手写</h2><ul><li>  call</li></ul><blockquote><p><strong><code>call()</code></strong> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>.<span class="title function_">call</span>(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><ul><li><p>  如果我们使用 call 并指定了第一个参数，那么 this 将会绑定到该对象上</p></li><li><p>  如果没指定，那么 this 将会绑定为全局对象，在严格模式下，this 的值将会是 undefined</p></li><li><p>  手写</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property">proptotype</span>.<span class="title function_">mycall</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        thorw <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Type error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="variable language_">window</span> <span class="comment">//如果没传入，就让他指向window</span></span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 将被调用的方法设置为 context 的属性</span></span><br><span class="line">  <span class="comment">// this 即为我们要调用的方法</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">let</span> result = constext.<span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  apply</li></ul><blockquote><p><code>apply()</code> 方法调用一个具有给定 <code>this</code> 值的函数，以及以一个数组（或一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">apply</span>(thisArg)</span><br><span class="line"><span class="title function_">apply</span>(thisArg, argsArray)</span><br></pre></td></tr></table></figure><p><strong>备注：</strong> 该方法的语法和作用与 <code>call()</code>方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是<strong>一个参数列表</strong>，而 <code>apply()</code> 方法接受的是<strong>一个包含多个参数的数组</strong>。</p><ul><li>  手写</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property">proptotype</span>.<span class="title function_">mycall</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        thorw <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Type error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="variable language_">window</span> <span class="comment">//如果没传入，就让他指向window</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//这里判断下是否传入了参数数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  bind</li></ul><p><strong><code>bind()</code></strong> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> = <span class="keyword">function</span>.<span class="title function_">bind</span>(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><p>参考博客： <a href="https://link.juejin.cn/?target=https://github.com/sisterAn/JavaScript-Algorithms/issues/81">解析 bind 原理，并手写 bind 实现</a>。</p><ul><li>  手写</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Funciton</span>.<span class="property">proptotype</span>.<span class="title function_">bind</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        thorw <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取参数</span></span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//记录调用的函数</span></span><br><span class="line">    fn = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">//需要返回一个函数</span></span><br><span class="line">    <span class="comment">//需要注意的是，如果将bind返回的函数视为构造函数，即使用new，那我们提供的 this 的值应当被忽略，从而指向实例,我们使用 instanceof 来判断</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>( <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context, args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h3><p>《JavaScript 高级程序设计（第 4 版）》中指出：「ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如 <code>[[Enumerable]]</code>。」</p><p>属性分为两种： <strong>数据属性</strong> 和 <strong>访问器属性</strong></p><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性由 4 个特性来描述它们的行为</p><ul><li>  <code>[[Configurable]]</code>：表示属性是否可以通过 <code>delete</code> 删除、是否可以修改该属性的特性，以及是否可以将该数据属性修改为访问器属性。默认值为 <code>true</code>。</li></ul><blockquote><p>注意：</p><ol><li>严格模式下，如果该特性为 <code>false</code> 但是仍然使用 <code>delete</code> 方法删除属性，将会抛出错误。</li><li>一个属性被定义为不可配置后，将无法再变回可配置。</li><li>此处即下面所说的默认值，指的是通过字面量形式指定属性的值时，该特性的默认值；如果通过 <code>Object.defineProperty()</code> 方法添加新的属性，那么该属性的特性默认值为 <code>false</code>。</li></ol></blockquote><ul><li>  <code>[[Enumerable]]</code>：表示属性是否可枚举。具体的，<code>[[Enumerable]</code> 特性表示该属性是否可以通过 <code>for-in</code> 循环返回。默认值为 <code>true</code>。</li><li>  <code>[[Writable]]</code>：表示属性的值是否可以被修改。默认值为 <code>true</code>。</li></ul><blockquote><p>注意：严格模式下修改只读属性将会抛出错误。</p></blockquote><ul><li>  <code>[[Value]]</code>：表示属性实际的值。默认值为 <code>undefined</code>。</li></ul><p>如果想要修改属性的数据特性，必须使用 <code>Object.defineProperty()</code> 或 <code>Object.defineProperties()</code> 方法。<code>Object.defineProperty()</code> 接收 3 个参数：对象、属性名称和描述特性的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// Yucohny</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line"><span class="attr">value</span>: <span class="string">&#x27;Yucoh&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// Yucoh</span></span><br></pre></td></tr></table></figure><p>上面提到，如果使用 <code>Object.defineProperty()</code> 方法添加新属性，那么新属性的特性默认值为 <code>false</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line"><span class="attr">value</span>: <span class="number">20</span>,</span><br><span class="line">&#125;)</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">19</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>)</span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，尽管我们尝试修改 <code>age</code> 为 <code>19</code>，但是由于 <code>age</code> 属性通过 <code>Object.defineProperty()</code> 指定时并未指定 <code>[[Writable]]</code> 特性的值，因此 <code>[[Writable]]</code> 特性取默认值 <code>false</code>，即不可修改。</p><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>在一个对象中，如果在某种情况下，我们不希望可以通过对象点属性名的方法直接修改属性值，我们<strong>希望可以通过一次“过滤”之后</strong>，如果传入的值符合要求，才能改变对象属性的值，因此，这就是访问器的作用。</p><p>访问器属性包含下列 4 个特性：</p><ul><li>  <code>[[Configurable]]</code>：表示属性是否可以通过 <code>delete</code> 删除并重新定义，是否可以修改它的特性，以及是否可以把它修改为数据属性。默认值为 <code>false</code>。</li><li>  <code>[[Enumerable]]</code>：表示属性是否可以通过 <code>for-in</code> 循环返回。默认值为 <code>false</code>。</li><li>  <code>[[Get]]</code>：获取函数，在读取属性时调用，默认值为 <code>undefined</code>。</li><li>  <code>[[Set]]</code>：设置函数，在写入属性是调用，默认值为 <code>undefined</code>。</li></ul><p>访问器属性是不能直接定义的，必须使用 <code>Object.defineProperty()</code> 或 <code>Object.defineProperties()</code> 定义，下面是一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    <span class="attr">year_</span>: <span class="number">2017</span>, <span class="comment">// year_ 中的下划线用来表示该属性并不希望在对象方法的外部被访问</span></span><br><span class="line">    <span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">year_</span> = newValue</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2017</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.<span class="property">year</span> = <span class="number">2018</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">edition</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>访问器属性的典型使用场景便是和上面一样，即设置一个属性值会导致一些其他变化发生。</p><p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只定义设置函数的属性是不能读取的，非严格模式下读取会返回 <code>undefined</code>，严格模式下会抛出错误。</p><h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p><code>Object.defineProperties()</code> 方法可以一次性定义多个属性的特性。该方法接收两个参数：对象和一个描述符对象，描述符对象的属性与要添加或修改的属性一一对应，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book, &#123;</span><br><span class="line"><span class="attr">year_</span>: &#123;</span><br><span class="line"><span class="attr">value</span>: <span class="number">2017</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">edition</span>: &#123;</span><br><span class="line"><span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>使用 <code>Object.getOwnPropertyDescriptor()</code> 方法可以获取指定属性的特性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于数据属性和访问器属性分别包含对应的特性作为属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line"><span class="attr">value</span>: <span class="string">&#x27;Yucoh&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   value: &#x27;Yucoh&#x27;,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>ES 2017 新增了 <code>Object.getOwnPropertyDescriptors()</code> 方法，并接收一个对象作为参数，该方法将会在每个属性上调用 <code>Object.getOwnPropertyDescriptor()</code> 并在一个新对象中返回它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line"><span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj))</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   name: &#123;</span></span><br><span class="line"><span class="comment">//     value: &#x27;Yucohny&#x27;,</span></span><br><span class="line"><span class="comment">//     writable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   age: &#123;</span></span><br><span class="line"><span class="comment">//     get: [Function: get],</span></span><br><span class="line"><span class="comment">//     set: undefined,</span></span><br><span class="line"><span class="comment">//     enumerable: false,</span></span><br><span class="line"><span class="comment">//     configurable: false</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h3><h5 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h5><p>在给对象添加变量的时候，经常会出现属性名与变量名一致的情况，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"><span class="attr">name</span>: name,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 <code>ReferenceError</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">name,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h5><p>如果想要使用变量值为属性，那么必须先声明对象，然后使用中括号语法来添加属性。即，不能在对象字面量中直接动态命名属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line">person[name] = <span class="number">19</span></span><br></pre></td></tr></table></figure><p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为表达式而不是字符串来求值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&#x27;age&#x27;</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeUniqueKey</span>(<span class="params">key</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>_&#123;count++&#125;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">[<span class="title function_">makeUniqueKey</span>(nameKey)]: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">[<span class="title function_">makeUniqueKey</span>(ageKey)]: <span class="number">19</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>其本身是一个普通的函数，但有着自己的特征和用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Vehicle</code>就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。</p><p>构造函数的特点有两个。</p><ul><li>  函数体内部使用了<code>this</code>关键字，代表了所要生成的对象实例。</li><li>  生成对象的时候，必须使用<code>new</code>命令</li></ul><h3 id="无-new-命令调用构造函数"><a href="#无-new-命令调用构造函数" class="headerlink" title="无 new 命令调用构造函数"></a>无 new 命令调用构造函数</h3><p>在没有<code>new</code> 命令的情况下调用构造函数，会使得该构造函数变成普通函数，同时函数内部的<code>this</code>将会指向全局对象</p><p>所以我们必须保证构造函数与<code>new</code>命令一起使用</p><ol><li>构造函数开启严格模式</li></ol><p>严格模式下，没有<code>new</code>命令调用构造函数将会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="string">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="title class_">Vehicle</span>()</span><br><span class="line"><span class="comment">// TypeError: Cannot set property &#x27;price&#x27; of undefined</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过判断构造函数中的 <code>this</code> 是否是它的实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Vehicle</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">price</span> = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="title class_">Vehicle</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v.<span class="property">price</span>) <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><ol start="3"><li>同样的，我们也可以使用 <code>new.target</code>来进行判断</li></ol><p>如果是通过 <code>new</code>命令调用，那么 <code>new.target</code>将会指向当前函数，否则为<code>undefined</code></p><h3 id="手写-new"><a href="#手写-new" class="headerlink" title="手写 new"></a>手写 new</h3><ol><li>首先创一个新的空对象。</li><li>根据原型链，设置空对象的 <code>__proto__</code> 为构造函数的 <code>prototype</code> 。</li><li>构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</li><li>判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">new</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">    obj.<span class="property">__proto__</span> = context.<span class="property">proptotype</span></span><br><span class="line">    <span class="keyword">const</span> res = context.<span class="title function_">apply</span>(obj, [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;Object&#x27;</span> ? res || obj : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>类有两种方式定义： 类声明和类表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125; 类声明</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">class</span>&#123;&#125;  类表达式</span><br></pre></td></tr></table></figure><ul><li>  类声明不会提升</li><li>  默认情况下，类中的代码都启用了<strong>严格模式</strong></li></ul><p>类表达式的名称是可选的, 可以通过<code>name</code>属性获取类表达式的名称，但是不能在类作用域外部访问类表达式的名称（这里的 VehicleName）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> <span class="title class_">VehicleName</span> &#123;</span><br><span class="line"><span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vehicle</span>.<span class="property">name</span>, <span class="title class_">VehicleName</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>()</span><br><span class="line"></span><br><span class="line">v.<span class="title function_">identify</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vehicle</span>.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">VehicleName</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// VehicleName VehicleName</span></span><br><span class="line"><span class="comment">// VehicleName</span></span><br><span class="line"><span class="comment">// ReferenceError: ObjName is not defined</span></span><br></pre></td></tr></table></figure><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>该关键字用于在类中创建类的构造函数， 当使用 <code>new</code> 命令创建新的实例，会调用<code>constructor</code></p><p>当使用 <code>new</code> 命令通过类实例化对象时，可以传入参数，对应的参数将被传入类构造函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">flag</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Vehicle&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vehicle</span></span><br></pre></td></tr></table></figure><p>如果没有使用<code>new</code>， 将会报错</p><blockquote><p>类构造函数和构造函数</p><p>没有使用 new 执行，构造函数会正常执行，只是其中的<code>this</code>指向会出现问题</p></blockquote><p>类也具有 <code>prototype</code>属性，且这个原型具有<code>constructor</code>属性指向类本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vehicle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Vehicle</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="实例属性与方法"><a href="#实例属性与方法" class="headerlink" title="实例属性与方法"></a>实例属性与方法</h3><p>我们可以在构造函数内部添加实例属性与方法，<code>this</code>指向为新创建的实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasPrototypeProperty = <span class="keyword">function</span> (<span class="params">obj, property</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> !obj.<span class="title function_">hasOwnProperty</span>(property) &amp;&amp; property <span class="keyword">in</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是判断该属性是否在实例的原型上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>(<span class="string">&#x27;Yucohny&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(v, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>实例属性的新写法：</p><p>实例属性现在除了可以定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类内部的最顶层。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting the current value!&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_count</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_count</span>++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h3><p>在类块中定义的方法为原型方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasPrototypeProperty = <span class="keyword">function</span> (<span class="params">obj, property</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> !obj.<span class="title function_">hasOwnProperty</span>(property) &amp;&amp; property <span class="keyword">in</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line"><span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>(<span class="string">&#x27;Yucohny&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v.<span class="title function_">getName</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Vehicle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">getName</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototypeProperty</span>(v, <span class="string">&#x27;getName&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Yucohny</span></span><br><span class="line"><span class="comment">// Yucohny</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="静态方法与静态属性"><a href="#静态方法与静态属性" class="headerlink" title="静态方法与静态属性"></a>静态方法与静态属性</h3><p>在其前面添加 <code>static</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> prop = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vehicle</span>.<span class="title function_">print</span>()</span><br><span class="line"><span class="title class_">Vehicle</span>.<span class="property">prop</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//hello</span></span><br></pre></td></tr></table></figure><h3 id="getter-amp-setter"><a href="#getter-amp-setter" class="headerlink" title="getter &amp; setter"></a>getter &amp; setter</h3><p>在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">prop</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter: &#x27;</span> + value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br><span class="line"></span><br><span class="line">inst.<span class="property">prop</span> = <span class="number">123</span></span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.<span class="property">prop</span></span><br><span class="line"><span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h3><p>ES6 类通过 <code>extends</code> 关键字实现继承。一个类可以继承任何拥有构造器属性与原型的对象，因此一个类不仅可以继承一个类，也可以继承普通的构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Person</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>  super</li></ul><p>子类可以通过 <code>super</code> 关键字引用父类。但是要注意，这个关键字只能在子类构造函数、实例方法与静态方法内部使用。在子类构造函数中，<code>super()</code> 可以直接调用父类构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Vehicle&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">super</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vehicle</span></span><br></pre></td></tr></table></figure><p><code>super</code> 的一些注意事项：</p><ul><li>  <code>super</code> 只能在子类构造函数、实例方法与静态方法内部使用；</li><li>  不能单独引用 <code>super</code> 关键字，要么用它调用构造函数，要么用它引用静态方法；</li><li>  调用 <code>super()</code> 会调用父类构造函数，并将返回的实例赋值给 <code>this</code> 子类实例；</li></ul><blockquote><p>因此，如果在子类中显式定义了构造函数，则要么必须在其中调用 <code>super()</code>，要么必须在其中返回一个对象。</p></blockquote><ul><li>  如果没有在子类中定义类构造函数，那么在实例化子类时会自动调用 <code>super()</code>，并将自动传入所有传给子类构造函数的参数；</li><li>  在子类构造函数中，不能在调用 <code>super()</code> 之前引用 <code>this</code>。</li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类指的是可供其他类继承，但是本事并不会被实例化。JavaScript 中没有专门支持抽象类的语法，但是可以通过 <code>new.target</code> 实现。</p><p><code>new.target</code> 保存了通过 <code>new</code> 关键字调用的类或者函数，可以通过在实例化时检测 <code>new.target</code> 是不是抽象类来阻止抽象类的实例化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Vehicle = class &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        if (new.target === Vehicle) &#123;</span><br><span class="line">            throw new Error(&#x27;This class cannot be directly instantiated&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const v = new Vehicle()</span><br><span class="line"></span><br><span class="line">// Error: This class cannot be directly instantiated</span><br></pre></td></tr></table></figure><p>由于原型方法在调用类构造函数前就已经存在，因此可以通过抽象类检查子类是否定义了某个方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Vehicle</span> = <span class="keyword">class</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Vehicle</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;This class cannot be directly instantiated&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getName</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Inheriting class must define getName()&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Inheriting class must define getName()</span></span><br></pre></td></tr></table></figure><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>js 是一个单线程语言，意味着他只有一个调用栈，同一时刻只能做一件事</p><p>如果我们所有的程序都是同步的，那么很有可能造成调用栈的阻塞，所以我们使用异步回调</p><p>js 同一时刻只能做一件事，但是浏览器给我们提供了其他的东西： Web APIs, 你可以对应地创建一些线程，但你不能直接访问，只能通过某些方式进行调用，浏览器对这种调用进行响应</p><h2 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h2><ul><li>  同步任务</li></ul><p>指直接在主线程上排队执行的任务</p><p>同步任务的执行，按照代码顺序和调用顺序，直接进入调用栈中并执行，执行结束后就移除调用栈。</p><ul><li>  异步任务</li></ul><p>指不进入主线程，进入任务队列的任务</p><p>异步任务的执行，首先它依旧会进入调用栈中，然后发起调用，然后解释器会将其<strong>响应回调任务</strong>放入一个<strong>任务队列</strong>，紧接着调用栈会将这个任务移除。当主线程清空后，即所有同步任务结束后，解释器会读取任务队列，并依次将<strong>已完成的异步任务</strong>加入调用栈中并执行。</p><p>重点就是异步任务<strong>不是直接</strong>进入任务队列的。</p><h2 id="任务队列与事件循环"><a href="#任务队列与事件循环" class="headerlink" title="任务队列与事件循环"></a>任务队列与事件循环</h2><ul><li>  任务队列</li></ul><p>WebAPIs 不能直接进行你的调用栈中， 所以引入了 callback queue(task queue) 回调队列（任务队列）， webaips 结束后就把回调函数送入队列中。</p><p>主线程首先会将调用栈中的同步任务执行完成，当同步任务<strong>清空</strong>时，就会从队首检查任务队列中的异步任务，放入调用栈中执行，执行结束后，主线程将重复此过程，直到所有的任务执行结束。这是早期的<strong>事件循环</strong></p><p>一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">cb</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cb&#x27;</span>) <span class="comment">// cb 即 callback</span></span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Bye&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e15fc609aa84eac973c5b8ff163c11c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="屏幕录制 2021-07-19 15.01.09.gif"></p><p>我们有如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">cb</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;there&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;JS&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对于第二行地定时器，我们将它的第二个参数设置为 0， 实际上，我们设置了定时器，他确实在 webapi 中 马上就进入了回调队列中，但是我们必须要等到 stack 中为空，才能将对调队列中的函数放进 stack 中，所以 setTimeout 设置为 0， 就是想让代码在 栈底执行，或者是为了等到栈空之后再执行</p><p>所以说，我们给 setTimeout 设置地时间，实际上并不是指多久之后执行，而是最快要多久之后执行，因为我们不仅要在 callback queue 中排队，也要等到栈空之后才能进入 stack</p><ul><li>  宏任务与微任务</li></ul><p>后面又引入了宏任务与微任务，他们都是异步任务，但是执行时机有所不同</p><p>进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。如果在执行宏任务的同时又产生了微任务，这个微任务会被立即添加到微任务队列中，这就是<strong>事件循环</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdcea13361a1ec~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>宏任务：DOM 渲染后触发，如 <code>setTimeout</code> 、<code>setInterval</code> 、<code>DOM 事件</code> 、<code>script</code> 。</p><p>微任务：DOM 渲染前触发，如 <code>Promise.then</code> 、<code>MutationObserver</code> 、Node 环境下的 <code>process.nextTick</code> 。</p><ul><li><p>  事件循环时 JavaScript 的执行机制</p></li><li><p>  推荐文章： <a href="https://juejin.cn/post/6844903512845860872">这一次，彻底弄懂 JavaScript 执行机制</a>。</p></li><li><p>  如果意犹未尽，不如再读下这篇非常详细带有大量动图的文章：<a href="https://juejin.cn/post/6969028296893792286#comment">做一些动图，学习一下 EventLoop</a>。</p></li><li><p>  想了解事件循环和页面渲染之间关系的又可以再阅读这篇文章：<a href="https://juejin.cn/post/6844904165462769678">深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）</a>。</p></li></ul><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><p>可以指定一个函数在 至少 多少 毫秒 后执行（由于时间循环的存在，这个时间可能不会准时），他会返回一个编号，可以利用该编号清除这个定时器</p><p><code>setTimeout()</code> 通常接收两个参数，第一个参数一个函数或者一段字符串形式的代码，第二个参数是要推迟的时间。第二个参数如果省略，则默认为 0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&#x27;console.log(2)&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>如果 <code>setTimeout()</code> 中的回调函数具有参数，可以直接跟在 <code>setTimeout()</code> 后面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(</span><br><span class="line"><span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + b)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="number">1000</span>,</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><p>与 <code>setTimeout</code> 用法一直，不过他是指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p><p>它指定的是 开始执行 的最小间隔，并不考虑每次任务的执行时间， 所有，如果我们指定 <code>setInterval</code> 的时间间隔为 <code>1000</code>， 而每次执行需要 5ms， 那么第一次执行结束后 95ms ，第二次循环就会开始， 亦然，如果每次执行需要 105ms， 那么第二次的任务在第一次执行结束就会立即开始</p><h3 id="清除定时器"><a href="#清除定时器" class="headerlink" title="清除定时器"></a>清除定时器</h3><p>利用两者返回的编号，我们使用<code>clearTimeout()</code> 和 <code>clearInterval()</code> 函数，就可以取消对应的定时器。</p><h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h2><p>指的是在事件被触发若干秒后再执行回调，如果在这若干秒内触发相同事件，则<strong>重新计时。</strong></p><ul><li>  搜索框搜索输入</li><li>  文本编辑器的实时保存</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;ipt&quot;</span> <span class="attr">onkeyup</span>=<span class="string">&quot;buttonChange()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">buttonChange</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> ipt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ipt&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (timer !== <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="built_in">clearTimeout</span>(timer)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(ipt.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;, <span class="number">2000</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>建议看看这个： <a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/22">JavaScript 专题之跟着 underscore 学防抖 </a></p><h2 id="防抖-throttle"><a href="#防抖-throttle" class="headerlink" title="防抖 throttle"></a>防抖 throttle</h2><p>指的是在一个单位时间内，只能触发一次事件。如果在这个单位时间内多次触发，则<strong>仅有</strong>一次生效。不要打断</p><ul><li>  高频事件（快速点击，鼠标滑动，resize 事件）</li><li>  下拉加载</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px; background-color: red;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;div&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">onclick</span>=<span class="string">&quot;onClick()&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">onClick</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (timer !== <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;zzz&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">&#125;, <span class="number">2000</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>从语义上来说，<code>Promise</code> 是一个容器，里面保存着某个未来才会结束的事件的结果。</p><p>从语法上来说，<code>Promise</code> 是一个对象，它可以获取异步操作的消息。</p><p><code>Promise</code> 对象有以下两个特点：</p><ol><li>无法通过外界对 <code>Promise</code> 对象造成影响。<code>Promise</code> 对象代表一个异步操作，有 3 种状态：进行中 <code>pending</code>、已成功 <code>fulfilled</code>（也称为 <code>resolved</code>） 和已失败 <code>rejected</code>。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li></ol><blockquote><p>有一个地方值得注意：对于事件而言，在错过事件发生之后再去监听，将不会得到结果；而 <code>Promise</code> 对象改变后再去添加回调函数，我们仍然是能够得到改变后的状态的。</p></blockquote><ol start="2"><li>一旦状态改变就不会再变，并且任何时候都可以得到这个结果。<code>Promise</code> 对象的状态改变只有两种可能：<code>pending</code> 变为 <code>fulfilled</code>，<code>pending</code> 变为 <code>rejected</code>。只要这两种情况发生，状态就不会再变。这时就称为已定型 <code>resolved</code>（但是很多时候都默认 <code>resolved</code> 特指 <code>fulfilled</code>）。</li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><p><code>Promise</code> 对象是一个构造函数，用于生成 <code>Promise</code> 实例。</p><p><code>Promise</code> 构造函数接收一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 与 <code>reject</code>。</p><p><code>resolve</code> 和 <code>reject</code> 是两个函数，由 JavaScript 引擎提供，不需要自己部署。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a><strong>resolve()</strong></h3><p><code>resolve()</code> 函数的作用是，将 <code>Promise</code> 对象的状态从 <code>pending</code> 变为 <code>resolved</code>。<code>resolve()</code> 函数在异步操作成功时调用，并 <strong>将异步操作的结果，作为参数传递出去</strong>。</p><h3 id="reject"><a href="#reject" class="headerlink" title="reject()"></a><strong>reject()</strong></h3><p><code>reject()</code> 函数的作用是，将 <code>Promise</code> 对象的状态从 <code>pending</code> 变为 <code>rejected</code>。<code>reject</code>() 函数在异步操作失败时调用，并 <strong>将异步操作报出的错误，作为参数传递出去</strong>。</p><p>如果执行 <code>resolve()</code> 或者 <code>reject()</code> 后还有命令需要执行，那么会继续执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>但是从语义上而言，执行 <code>resolve()</code> 或 <code>reject()</code> 参数后，<code>Promise</code> 本身的使命就已经完成了，后续命令应该添加至 <code>then</code> 方法中。</p><p>为了避免上面示例这样的情况，我们可以在 <code>resolve()</code> 或 <code>reject()</code> 执行前添加 <code>return</code> 命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>  即 上面两个函数决定了返回的 Promise 对象的状态，函数传递的值就是这个 Promise 的值</li></ul><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p><code>then</code> 方法定义在构造函数的原型对象上，因此为每一个实例对象所共享。</p><p><code>then</code> 方法的作用是为 <code>Promise</code> 实例 <strong>添加状态改变时的回调函数</strong>。</p><p><code>then</code> 方法可以接收两个<strong>回调函数</strong>作为参数。</p><p>第一个回调函数是 <code>Promise</code> 对象的状态变为 <code>resolved</code> 时调用。</p><p>第二个回调函数是 <code>Promise</code> 对象的状态变为 <code>rejected</code> 时调用。</p><p>这两个函数都是可选的，不一定要提供，它们都接收 <code>Promise</code> 对象传出的值作为参数。</p><p><code>Promise</code> 本身是同步执行，但是其回调 <code>then</code> 方法是异步执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><code>then</code> 方法返回的是一个新的 <code>Promise</code> 实例，因此可以采用链式写法，即 <code>then</code> 方法后面再调用另一个 <code>then</code> 方法。这样做将会将前一个 <code>then</code> 方法<strong>返回值</strong>传入这个新的 <code>then</code> 方法作为参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line"><span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line"><span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>  在 <code>.then</code> 和 <code>.catch</code> 中 <code>return</code> 一个 <code>error</code> 对象并不会抛出错误，也不会被后续的 <code>cathc </code>捕获，它相当于返回了一个 <code>Promise.resolve(new Error(xxx))</code> ，状态为 <code>reslove</code> ， 值为这个错误</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then: &#x27;</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch: &#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;then: &quot; &quot;Error: error!!!&quot;</span></span><br></pre></td></tr></table></figure><p>可以使用下面的方式来抛出错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>))</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>  总结： <code>.then</code> 方法会返回一个新的<code>Promise</code> 对象，这个对象的状态由它的返回值决定，对象的值就是返回值，当然如果它返回的是一个<code>new Promise</code> ，那么就是由这个<code>Promise</code>来决定</li></ul><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><ul><li><p>  <code>Promise.prototype.catch()</code> 方法等同于 <code>.then(null, reject)</code> 或者 <code>.then(undefined, reject)</code>，用于指定发生错误时的回调函数。</p></li><li><p>  有了 <code>catch()</code> 方法的存在，因此一般不在 <code>then</code> 方法中定义 <code>rejected</code> 状态的回调函数，而应该总是使用 <code>catch</code> 方法。</p></li><li><p>  与传统 <code>try/catch</code> 代码块不同的是，如果没有使用 <code>catch</code> 方法指定错误处理的回调函数，<code>Promise</code> 对象抛出的错误不会传递到外层代码，即不会有任何反应。但是浏览器会打印出对应的输出，但是并不会终止脚本的运行。</p></li><li><p>  <code>catch</code> 函数也会返回一个 promise, promise 的值由它的返回值决定</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;success2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then1: &#x27;</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then2: &#x27;</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch: &#x27;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then3: &#x27;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;catch: &quot;</span> <span class="string">&quot;error&quot;</span></span><br><span class="line"><span class="string">&quot;then3: &quot;</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p><code>.then</code> 和 <code>.catch</code> 的参数期望是函数，如果传入的不是函数，将会发生值透穿</p><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>finally()</code> 方法用于指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作。</p><p><code>finally()</code> 方法的回调函数不接受任何参数，这意味着没有办法知道状态到底是 <code>fulfilled</code> 还是 <code>rejected</code>。这表明，<code>finally()</code> 方法里面的操作，应该是与状态无关的，不依赖于 <code>Promise</code> 的执行结果。</p><p><code>finally()</code> 方法可以看作是 <code>then()</code> 方法的语法糖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 语句</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 相同的语句</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 相同的语句</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p>  <strong>链式调用</strong>后面的内容需要等前一个调用执行完才会执行。</p></li><li><p>  <code>.finally</code> 最终返回的默认是上一次的 Promise 的对象值，除非它直接抛出一个异常，则返回异常的 Promise 对象</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally2&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;我是finally2返回的值&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally2后面的then函数&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="string">&#x27;finally2&#x27;</span></span><br><span class="line"><span class="string">&#x27;finally&#x27;</span></span><br><span class="line"><span class="string">&#x27;finally2后面的then函数&#x27;</span> <span class="string">&#x27;2&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ol><li><code>Promise</code>的状态一经改变就不能再改变。(见 3.1)</li><li><code>.then</code>和<code>.catch</code>都会返回一个新的<code>Promise</code>。(上面的 👆1.4 证明了)</li><li><code>catch</code>不管被连接到哪里，都能捕获上层未捕捉过的错误。(见 3.2)</li><li>在<code>Promise</code>中，返回任意一个非 <code>promise</code> 的值都会被包裹成 <code>promise</code> 对象，例如<code>return 2</code>会被包装为<code>return Promise.resolve(2)</code>。</li><li><code>Promise</code> 的 <code>.then</code> 或者 <code>.catch</code> 可以被调用多次, 但如果<code>Promise</code>内部的状态一经改变，并且有了一个值，那么后续每次调用<code>.then</code>或者<code>.catch</code>的时候都会直接拿到该值。(见 3.5)</li><li><code>.then</code> 或者 <code>.catch</code> 中 <code>return</code> 一个 <code>error</code> 对象并不会抛出错误，所以不会被后续的 <code>.catch</code> 捕获。(见 3.6)</li><li><code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。(见 3.7)</li><li><code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传。(见 3.8)</li><li><code>.then</code>方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为<code>catch</code>是<code>.then</code>第二个参数的简便写法。(见 3.9)</li><li><code>.finally</code>方法也是返回一个<code>Promise</code>，他在<code>Promise</code>结束的时候，无论结果为<code>resolved</code>还是<code>rejected</code>，都会执行里面的回调函数。</li></ol><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><code>Promise.all()</code> 方法用于将多个 <code>Promise</code> 实例包装成一个新的 <code>Promise</code> 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3])</span><br></pre></td></tr></table></figure><p><code>Promise.all()</code> 接收具有 <code>Iterator</code> 接口的对象（最典型的就是数组）作为参数，数组元素期望为 <code>Promise</code> 对象的实例；如果不是，就会对该元素调用 <code>Promise.resolve()</code> 方法，将参数转为 <code>Promise</code> 实例，再进一步处理。</p><p>返回的状态由传入参数的状态决定，分为两种情况：</p><ol><li>只有当传入的 <code>Promise</code> 实例都是 <code>fulfilled</code> 状态，得到的新 <code>Promise</code> 实例才是 <code>fulfilled</code> 状态。并且 <code>Promise</code> 实例参数的返回值会组成一个数组，传递给新的 <code>Promise</code> 实例的回调函数。</li><li>当传入的 <code>Promise</code> 实例存在 <code>rejected</code> 状态，则得到的结果就是 <code>rejected</code> 状态。并且第一个 <code>rejected</code> 状态的实例的返回值会传递给新的 <code>Promise</code> 实例的回调函数。</li></ol><p>结合 <code>Promise.all()</code> 的含义，可以手写出 <code>PromiseAll()</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">PromiseAll</span> = (<span class="params">iterator</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> promises = <span class="title class_">Array</span>.<span class="title function_">from</span>(iterator)</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> data = []</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> promises) &#123;</span><br><span class="line">promises[i]</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">data[i] = res</span><br><span class="line"><span class="keyword">if</span> (++index === promises.<span class="property">length</span>) &#123;</span><br><span class="line"><span class="title function_">resolve</span>(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Promise.all()</code> 的应用场景很容易设想：并发了多个网络请求时，需要等到全部返回成功后再进行接下来的操作。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><code>Promise.race()</code> 方法同样是将多个 <code>Promise</code> 实例包装成一个新的 <code>Promise</code> 实例。<code>Promise.race()</code> 的参数处理与 <code>Promise.all()</code> 相同，但是新 <code>Promise</code> 实例的状态规则与 <code>Promise.all()</code> 不同：</p><p>如果 <code>Promise</code> 实例参数有一个实例的状态发生改变，则新的 <code>Promise</code> 实例的状态也跟着改变，并且率先改变状态的参数的返回值作为新的 <code>Promise</code> 实例回调函数参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runAsync</span>(<span class="params">x</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">r</span>(x, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span>))</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runReject</span>(<span class="params">x</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">rej</span>(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span> * x)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">runReject</span>(<span class="number">0</span>), <span class="title function_">runAsync</span>(<span class="number">1</span>), <span class="title function_">runAsync</span>(<span class="number">2</span>), <span class="title function_">runAsync</span>(<span class="number">3</span>)])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, res))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure><p>遇到错误的话，也是一样的，在这道题中，<code>runReject(0)</code>最先执行完，所以进入了<code>catch()</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">;(<span class="string">&#x27;Error: 0&#x27;</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>  <code>Promise.all()</code>的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。</li><li>  <code>.race()</code>的作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。</li><li>  <code>Promise.all().then()</code>结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致。</li><li>  <code>all和race</code>传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被<code>then</code>的第二个参数或者后面的<code>catch</code>捕获；但并不会影响数组中其它的异步任务的执行</li></ul><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h3><p><code>Promise.allSettled()</code> 方法同样是将多个 <code>Promise</code> 实例包装成一个新的 <code>Promise</code> 实例。<code>Promise.allSettled()</code> 的参数处理与 <code>Promise.all()</code> 相同，但是新 <code>Promise</code> 实例的状态规则与 <code>Promise.all()</code> 不同：</p><p>当参数数组的 <code>Promise</code> 对象状态全部发生改变（无论是 <code>fulfilled</code> 还是 <code>rejected</code>）后，新的 <code>Promise</code> 对象状态发生改变，为 <code>fullfilled</code>，并且将参数数组作为新的 <code>Promise</code> 实例回调函数参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([resolved, rejected])</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">promises</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(promises))</span><br><span class="line"></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#123; status: &#x27;fulfilled&#x27;, value: 1 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>可以通过 <code>Array.prototype.filter()</code> 方式筛选出状态分别为 <code>fulfilled</code> 与 <code>rejected</code> 的 <code>Promise</code> 对象，并且返回错误原因：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">work</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">2</span>),</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>),</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">4</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fulfilleds = results.<span class="title function_">filter</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rejecteds = results</span><br><span class="line">.<span class="title function_">filter</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>)</span><br><span class="line">.<span class="title function_">map</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> p.<span class="property">reason</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fulfilleds)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rejecteds)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">work</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#123; status: &#x27;fulfilled&#x27;, value: 1 &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; status: &#x27;fulfilled&#x27;, value: 3 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br><span class="line"><span class="comment">// [ 2, 4 ]</span></span><br></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h3><p><code>Promise.any()</code> 方法同样是将多个 <code>Promise</code> 实例包装成一个新的 <code>Promise</code> 实例。<code>Promise.any()</code> 的参数处理与 <code>Promise.all()</code> 相同，但是新 <code>Promise</code> 实例的状态规则与 <code>Promise.all()</code> 不同：</p><p>如果 <code>Promise</code> 实例参数有一个实例的状态变为 <code>fulfilled</code>，则新的 <code>Promise</code> 实例的状态也变为 <code>fulfilled</code>；如果所有 <code>Promise</code> 实例参数都变为 <code>rejected</code>，则新的 <code>Promise</code> 实例的状态才会变为 <code>rejected</code>。</p><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p><code>Promise.resolve()</code> 用于将现有对象转化为 <code>Promise</code> 对象，分为下列四种情况：</p><ol><li>参数是一个 <code>Promise</code> 实例</li></ol><p>不做修改，直接返回该实例。</p><p>如果参数是一个原始值，或者是一个不具有 <code>then</code> 方法的对象，那么 <code>Promise.resolve</code> 方法返回一个新的 <code>Promise</code> 对象，状态为 <code>resolved</code>，并且值就为该参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ol start="2"><li>不带有参数</li></ol><p>直接返回一个 <code>resolved</code> 状态的 <code>Promise</code> 对象，值为 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p><code>Promise.reject()</code> 方法也返回一个新的 <code>Promise</code> 实例，状态为 <code>rejected</code>。</p><p><code>Promise.reject()</code> 方法的参数会原封不动作为 <code>reject</code> 的理由变成后续方法的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">1</span>).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h2><p>ECMAScript2017 中添加了<code>async functions</code>和<code>await</code>。</p><ul><li>  async</li></ul><p><code>async</code>关键字是将一个同步函数变成一个异步函数，并将返回值变为<code>Promise</code>。</p><p><code>async</code> 函数返回的 <code>Promise</code> 对象的状态由以下两点决定：</p><ol><li>如果异步函数内执行 <code>throw</code> 抛出错误语句，那么状态为 <code>rejected</code>；</li><li>否则状态为 <code>fulfilled</code>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P1</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P2</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">P1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">P2</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123; 1 &#125;</span></span><br><span class="line"><span class="comment">// Promise &#123;</span></span><br><span class="line"><span class="comment">//   &lt;rejected&gt; Error: 2</span></span><br><span class="line"><span class="comment">//       at P2 (E:\code\js-demo\index.js:6:11)</span></span><br><span class="line"><span class="comment">//       at Object.&lt;anonymous&gt; (E:\code\js-demo\index.js:12:12)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><code>async</code> 函数返回的 <code>Promise</code> 对象的值由以下几点决定：</p><ol><li>如果执行了 <code>throw</code> 抛出错误语句，那么 <code>Promise</code> 对象的值为 <code>Error</code> 对象的值。</li><li>否则，如果存在 <code>return</code> 语句，那么 <code>return</code> 的内容就是 <code>Promise</code> 对象的值。</li><li>否则，如果不存在 <code>return</code> 语句，那么 <code>Promise</code> 对象的值为 <code>undefined</code>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P1</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P2</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P3</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">P1</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">P2</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title function_">P3</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123; 1 &#125;</span></span><br><span class="line"><span class="comment">// Promise &#123; undefined &#125;</span></span><br><span class="line"><span class="comment">// Promise &#123;</span></span><br><span class="line"><span class="comment">//   &lt;rejected&gt; Error: 2</span></span><br><span class="line"><span class="comment">//       at P2 (E:\code\js-demo\index.js:6:11)</span></span><br><span class="line"><span class="comment">//       at Object.&lt;anonymous&gt; (E:\code\js-demo\index.js:12:12)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>既然 <code>async</code> 函数返回的是 <code>Promise</code> 对象，那么可以在调用 <code>async</code> 函数后追加 <code>then</code> 等其他语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncPrint</span>(<span class="params">value</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">asyncPrint</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v + <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>  await</li></ul><p><code>await</code> 命令用于等待一个 <code>Promise</code> 对象执行完毕。<code>await</code> 命令要注意下列两点：</p><ol><li><code>await</code> 命令只能用于 <code>async</code> 函数中。</li><li><code>await</code> 命令一般跟 <code>Promise</code> 对象，如果不是 <code>Promise</code> 对象，那么就会将命令后面的值直接返回。</li></ol><p>如果 <code>async</code> 函数执行到了 <code>await</code> 语句，那么就会直接返回一个 <code>Promise</code> 对象，该 <code>Promise</code> 对象状态为 <code>pending</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;Demo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">P</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(promise)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123; &lt;pending&gt; &#125;</span></span><br></pre></td></tr></table></figure><p>如果 <code>await</code> 命令后的 <code>Promise</code> 对象状态改变为 <code>fulfilled</code>，那么 <code>async</code> 函数将继续执行后面的语句，并且返回的 <code>Promise</code> 实例对象值与上一小节所述一致：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">P</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(promise)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(promise)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123; &lt;pending&gt; &#125;</span></span><br><span class="line"><span class="comment">// Promise &#123; 2 &#125;</span></span><br></pre></td></tr></table></figure><p>如果该 <code>await</code> 命令后的 <code>Promise</code> 对象状态改变为 <code>rejected</code>，那么整个 <code>async</code> 函数执行结束，并且将 <code>async</code> 函数返回的 <code>Promise</code> 对象的状态改变为 <code>rejected</code>，值为 <code>await</code> 命令后面的 <code>Promise</code> 对象执行 <code>reject()</code> 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">P</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">P</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(promise)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(promise)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123; &lt;pending&gt; &#125;</span></span><br><span class="line"><span class="comment">// Promise &#123; &lt;rejected&gt; 1 &#125;</span></span><br></pre></td></tr></table></figure><p>可以理解为： 紧跟着 await 后面的语句相当于放到了 new Promise 中，下一行及之后的语句相当于放在了 Promise.then 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="comment">// 原来代码</span></span><br><span class="line">  <span class="comment">// await async2();</span></span><br><span class="line">  <span class="comment">// console.log(&quot;async1 end&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转换后代码</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">async</span> start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br></pre></td></tr></table></figure><ul><li>  如果 await 后面的表达式是一个 Promise， 它的返回值就是 Promise 的解决值</li><li>  如果是一个非 Promise，它的返回值就是表达式本身的值</li><li>  如果 await 右侧的 Promise 被拒绝，await 会抛出拒绝的原因，并且将不再执行后续代码</li></ul><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>即 文档对象模型</p><h2 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h2><p><img src="https://www.runoob.com/images/pic_htmltree.gif" alt="DOM HTML tree"></p><ul><li>  文档： document，一个页面就是一个文档</li><li>  元素： element， 页面中所以的标签都是元素</li><li>  节点： node， 网页中所有的内容都是节点（标签，属性，文本，注释等）</li></ul><p>每个节点都至少有三个基本属性</p><ul><li>  nodeType</li></ul><p>返回节点类型的常数值，常用的有 1（元素）、2（属性）、3（文本）</p><ul><li>  nodeName</li></ul><p>返回节点的名称</p><ul><li>  nodeValue</li></ul><p>返回或者设置当前节点的值，格式为字符串</p><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><ol><li><p>根据 id <code>document.getElementById()</code></p></li><li><p>根据 tag <code>document.getElementByTagName()</code> 返回伪数组</p></li><li><p>根据 class <code>document.getElementByTagName() </code> 返回伪数组</p></li><li><p>利用选择器</p><ol><li><code>document.querySelector(#id .class tag)</code> 返回匹配到的第一个元素</li><li><code>document.querySeletorAll(#id .class tag)</code> 返回伪数组</li></ol></li></ol><ul><li>  获取 body <code>document.body</code></li><li>  获取 html <code>document.documentElement</code></li></ul><h3 id="利用节点层次获取属性"><a href="#利用节点层次获取属性" class="headerlink" title="利用节点层次获取属性"></a>利用节点层次获取属性</h3><p><strong>父级节点</strong></p><ul><li>  <code>node.parentNode</code> 获得离元素最近的父级节点，找不到就为 null</li></ul><p><strong>子级节点</strong></p><ul><li><p>  <code>node.childNodes</code> 获取包含换行、空格等文本节点在内的节点，可以通过<code>nodeType</code>进一步获取</p></li><li><p>  <code>node.children</code> 获取所有的<strong>子级元素</strong>节点</p></li><li><p>  <code>node.firstChild</code> 获取第一个子节点，注意包括了文本等节点</p></li><li><p>  <code>node.firstElementChild</code> 获取第一个子元素节点</p></li><li><p>  <code>node.lastElementChild</code> 获取最后一个子元素节点</p></li></ul><p><strong>兄弟节点</strong></p><ul><li>  <code>node.nextSibling</code> 下一个节点， 包含了文本等节点</li><li>  <code>node.previousSibling</code> 上一个节点， 包含了文本等节点</li><li>  <code>node.nextElementSibling</code> 下一个兄弟元素节点</li><li>  <code>node.previousElementSibling</code> 上一个兄弟元素节点</li></ul><h2 id="操作-DOM"><a href="#操作-DOM" class="headerlink" title="操作 DOM"></a>操作 DOM</h2><h3 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a><strong>操作元素</strong></h3><p><strong>改变元素内容</strong></p><ul><li><p>  <code>element.innerText</code> 不识别 html 标签（如<div></div>等），会去除空格和换行</p></li><li><p><code>element.innerHTML</code> 识别 html 标签 ， 保留空格和换行 *<br>  都是可读写</p></li></ul><p><strong>操作常见元素</strong></p><ul><li>  src , href, alt , title , id</li></ul><p><strong>表单属性操作</strong></p><ul><li>  type、 value、checked、selected、disabled(禁用)</li></ul><p><strong>样式属性操作</strong></p><ul><li>  <code>element.style</code> 是行内样式， 样式较少，功能简单</li><li><code>element.className</code><br>  如果原来元素有类名，直接赋值会覆盖掉<br>  通过并列写不会覆盖 <code>element.className=原来的  新添的</code></li></ul><p><strong>创建节点</strong></p><ul><li>  <code>document.creatElement(tag)</code></li></ul><p><strong>添加节点</strong></p><ul><li>  <code>node.appendChild(节点)</code> 添加到父级子元素的末尾</li><li>  <code>node.insertBefore(child, 指定元素)</code> 添加到指定元素的前面</li></ul><p><strong>删除节点</strong></p><ul><li>  <code>node.removeChild(child)</code></li></ul><p><strong>复制节点</strong></p><ul><li><p><code>node.cloneNode()</code></p><p>  如果括号为空或者<code>false</code>，只复制标签</p><p>  如果为 true, 标签和内容都会复制</p></li></ul><h3 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h3><p><strong>获取属性</strong></p><ul><li>  <code>element.属性</code> 一般用于获取内置的 id class 等</li><li>  <code>element.getAttribute(属性)</code> 一般用于获取自定义属性，但是什么样的属性都能获取</li></ul><p><strong>设置属性</strong></p><ul><li>  <code>element.属性</code> = ‘值’</li><li>  <code>element.setAttribute(属性，值)</code></li><li>  用法规则与上面相同</li></ul><p><strong>移出属性</strong></p><ul><li>  <code>removeAttribute(属性)</code></li><li>  什么都能移出</li></ul><h3 id="H5-自定义属性"><a href="#H5-自定义属性" class="headerlink" title="H5 自定义属性"></a>H5 自定义属性</h3><ul><li>  规定自定义属性以 <code>data-</code> 开头作为属性名并且赋值</li><li>  使用 <code>element.dataset</code> 获取自定义属性集合,获取到的自定义属性是不带<code>data-</code>的</li><li>  使用 <code>element.dataset.自定义属性(不带data-)</code> 或者 <code>element.dataset[&#39;自定义属性&#39;]</code> 进行进一步获取或者进行赋值</li><li>  只能获取到 <code>data-</code>开头的自定义属性</li><li>如果自定义属性有多个<code>-</code> 采用驼峰命名<ul><li>  <code>data-list-name</code> -&gt; <code>element.dataset.listName</code></li></ul></li></ul><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>即 浏览器对象模型</p><ul><li>  与浏览器窗口进行交互</li><li>  顶级对象是 <code>window</code></li></ul><h2 id="浏览器进程问题"><a href="#浏览器进程问题" class="headerlink" title="浏览器进程问题"></a>浏览器进程问题</h2><p>浏览器是多进程的，浏览器的每一个 tab 标签都代表一个独立的进程（也不一定，因为多个空白 tab 标签会合并成一个进程），浏览器内核（浏览器渲染进程）属于浏览器多进程中的一种。</p><p>浏览器每个进程有多个线程，主要有以下线程</p><p>1）GUI 渲染线程</p><p>负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。</p><p>GUI 渲染进程 和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。</p><p>2）JS 引擎线程</p><p>单线程工作，负责解析运行 JavaScript 脚本。</p><p>和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。</p><p>3）事件触发线程</p><p>当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。</p><p>4）定时器触发线程</p><p>浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。 开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。</p><p>5）http 请求线程</p><p>http 请求的时候会开启一条请求线程。 请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。</p><h2 id="window-对象常用事件"><a href="#window-对象常用事件" class="headerlink" title="window 对象常用事件"></a>window 对象常用事件</h2><p><strong>load 事件和 onload 属性</strong></p><ul><li>  <code>load</code>事件发生在文档在浏览器窗口加载完毕时。<code>window.onload</code>属性可以指定这个事件的回调函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> elt = elements[i]</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>URL 统一资源定位符（uniform resource locator）</strong></p><p>是互联网上标准资源的地址</p><p>语法： <code>protool://host[:port]/path/[?query]#fragment</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如 http://www.itcast.cn/index.html?name=andy&amp;age=18#link</span><br><span class="line">_ protool 通信协议 http 等</span><br><span class="line">_ host 主机（域名） www.baidu.com</span><br><span class="line">_ port 端口号，可选，省略是使用迷人端口</span><br><span class="line">_ path 路径 一般用来表示主机上的一个目录或文件地址</span><br><span class="line">_ query 参数， 以键值对的形式，通过&amp;符分开</span><br><span class="line">_ fragment 片段 #后面内容 常见于链接， 锚点</span><br></pre></td></tr></table></figure><p><strong>location 对象</strong></p><p>window 提供一个 location 属性用于获取或设置窗体的 URL, 并且可以用于解析 URL,返回一个对象</p><p><strong>属性</strong></p><ol><li>location.href 获取或设置整个 URL</li><li>location.host 返回主机（域名）</li><li>location.port 返回端口号 未写则返回空字符串</li><li>location.pathname 返回路径</li><li>location.search 返回参数</li><li>location.hash 返回片段 #后面内容 常见于链接， 锚点</li></ol><p><strong>方法</strong></p><ol><li>location.assign() 可以重定向页面，记录历史</li><li>location.replace() 替换当前页面，因为不记录历史，不能后退页面</li><li>location.reload() 重新加载页面， 参数为 true 为强制刷新</li></ol><p><strong>navigator 对象</strong></p><ul><li>  包含了有关浏览器的信息，常用 userAgent，返回由客户机发送服务器的 user-agent 头部的值，判断用户是在哪个终端（pc,移动）打开页面，实现跳转</li></ul><p><strong>history 对象</strong></p><p><strong>方法</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> back() 后退</span><br><span class="line"><span class="bullet">2.</span> forward() 前进</span><br><span class="line"><span class="bullet">3.</span> go(参数) 前进后退功能， 参数为 1 前进一个页面 -1 就后退一个页面</span><br></pre></td></tr></table></figure><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><strong>相关概念</strong></h2><ul><li><p>  <strong>静态语言</strong>：<strong>在使用之前</strong>就需要确认其变量书记类型的编程语言</p></li><li><p>  <strong>动态语言</strong>： <strong>运行过程中</strong>需要检查数据类型的编程语言</p></li><li><p>  <strong>弱类型语言</strong>： 支持<strong>隐式类型转换</strong>（可以偷偷的转换数据类型）的编程语言</p></li><li><p>  <strong>强类型语言</strong>： 不支持隐式类型转换的编程语言</p></li></ul><p><code>JavaScript</code>的数据类型一共有 8 种</p><p><code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Number</code>、<code>BigInt</code>、<code>String</code>、<code>Symbol</code> 和 <code>Object</code>。</p><p>前 7 种称为原始类型（简单数据类型），最后一个对象类型称为引用类型（复杂数据类型）。原始类型与引用类型之间的一个差别就是在<strong>内存中存放的位置</strong>不一样。</p><h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><p>JS 的内存模型可以认为包含了从上到下三个空间： 代码空间、栈空间、堆空间</p><p>代码空间存储可执行代码；堆空间存储了<strong>引用类型的数据</strong>；栈空间存储了<strong>原始类型的数据</strong>和引用类型数据的<strong>引用地址</strong></p><h2 id="为什么需要堆空间"><a href="#为什么需要堆空间" class="headerlink" title="为什么需要堆空间"></a>为什么需要堆空间</h2><p>JavaScript 需要使用 栈空间维护程序执行期间的上下文状态，如果所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而影响到整个程序的执行效率</p><p>所以，一般来说， 栈空间主要存放原始类型的小数据，同时存放引用类型的地址； 因为堆空间很大，同时它的操作更加复杂，而引用类型的数据占用的空间都比较大，所以它的数据放在堆中</p><h2 id="什么是垃圾回收机制"><a href="#什么是垃圾回收机制" class="headerlink" title="什么是垃圾回收机制"></a>什么是垃圾回收机制</h2><p>即 <code>GC</code> -&gt; <code>Garbage Collection</code></p><p>程序工作过程中会产生很多 <code>垃圾</code>，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 <code>GC</code> 就是负责回收垃圾的</p><h2 id="垃圾的产生"><a href="#垃圾的产生" class="headerlink" title="垃圾的产生"></a>垃圾的产生</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;zzz&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">text = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>上面代码首先我们声明了一个变量 <code>test</code>，它引用了对象 <code>&#123;name: &#39;isboyjc&#39;&#125;</code>，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，那么之前的对象引用关系就没有了，如下图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a428ca00cb164eeab16e8cbbb603e7d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>没有了引用关系，也就是无用的对象，这个时候假如任由它搁置，一个两个还好，多了的话内存也会受不了，所以就需要被清理（回收）</p><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><ul><li>  <strong>自动回收</strong>： 内存中的垃圾数据由垃圾回收器进行释放，并不需要手动通过代码来释放。如 JavaScript、Java、Python 等语⾔</li><li>  <strong>手动回收</strong>： 何时分配内存、销毁内存都是由代码控制的，C++ 中，如果某段数据已经不再需要了，但是又没有主动调用 <code>free</code> 函数来销毁，那么这种情况就被称为<strong>内存泄漏</strong>。</li></ul><h3 id="栈空间的数据回收方式"><a href="#栈空间的数据回收方式" class="headerlink" title="栈空间的数据回收方式"></a>栈空间的数据回收方式</h3><p>在栈空间中有一个记录当前执行状态的指针，称为 ESP。当某一个执行上下文结束的时候，JS 就会将 ESP 移动到下一个执行上下文，整个下移操作就是销毁了上一个执行上下文的过程。</p><p>这样上一个执行上下文虽然保存在栈空间当中，但是已经是无效内存了。而当有的数据要保存进来时，这一块内容就会覆盖掉。</p><h3 id="堆空间的数据回收方式"><a href="#堆空间的数据回收方式" class="headerlink" title="堆空间的数据回收方式"></a>堆空间的数据回收方式</h3><p>在栈空间中，旧的执行上下文被移除后，仅仅是从栈空间中被移除了。但是如果这一段执行上下文含有堆空间的地址，那么对应堆空间的内存是不会被直接销毁的。而如果想要回收堆中的垃圾数据，就需要使用 JS 中的垃圾回收器。</p><p>**标记清除算法 Mark-Sweep **</p><p>整个标记清除算法大致过程就像下面这样</p><ul><li>  垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0</li><li>  然后从各个根对象开始遍历，把不是垃圾的节点改成 1</li><li>  清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间</li><li>  最后，把所有内存中对象标记修改为 0，等待下一轮垃圾回收</li></ul><p>优点 ：简单</p><p>缺点：</p><ul><li><p>  <strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块</p></li><li><p>  <strong>分配速度慢</strong>，因为即便是使用 <code>First-fit</code> 策略，其操作仍是一个 <code>O(n)</code> 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢</p></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12247ac3d8f249a5ab85b9b40ba1147b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p><strong>标记整理算法 Mark-Compact</strong></p><p>它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04b0a5a40084e0ba4550500c57f2270~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><h2 id="V8-对-GC-的优化"><a href="#V8-对-GC-的优化" class="headerlink" title="V8 对 GC 的优化"></a>V8 对 GC 的优化</h2><p>JavaScript V8 引擎将堆空间分为 <strong>新生代</strong> 和 <strong>老生代</strong> 两个区域：<strong>新生代中存放的是生存时间短的对象；老生代中存放的是生存时间久的对象</strong>。</p><p>新生区通常只支持 1~8M 的容量，而老生区支持的容量更大。V8 引擎分别使用 <strong>副垃圾回收器</strong> 和 <strong>主垃圾回收器</strong> 分别负责新生代与老生代的垃圾回收。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abae5b06648a40d2aaa453b5d8a83939~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><h3 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h3><p>副垃圾回收器负责的新生代使用 <strong>Scavenge 算法</strong> 来处理。Scavenge 算法又叫做 <strong>基于 copy 的垃圾回收算法</strong>。<strong>Scavenge</strong> 算法的主要思想如下：</p><ol><li>把新生代空间对半划分为两个区域：<strong>对象区域</strong> 与 <strong>空闲区域</strong>。</li><li>新加入的对象存放至对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</li><li>在垃圾回收过程中，首先按照共同的执行流程对活动对象与非活动对象进行标记。标记结束后，清理非活动对象，同时将活动对象复制到空闲区域。执行结束后，将复制到空闲区域的活动对象有序排列。因此在这个过程中，已经完成了内存整理的操作，复制后空闲区域就没有内存碎片了。</li><li>完成复制后，对象区域与空闲区域进行翻转：原来的对象区域变成空闲区域，原来的空闲区域变成对象区域。</li></ol><p>经过这一系列步骤后，副垃圾回收器就完成了对新生区的一次垃圾回收</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><ul><li>  <strong>对象晋升策略</strong>： 经过两次新生代垃圾回收依然还存活的对象，将会被移动到老生区中</li><li>  如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中</li></ul><h3 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h3><p>使用 <strong>标记-整理算法</strong> 进行垃圾回收</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c04b0a5a40084e0ba4550500c57f2270~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><h3 id="全停顿-Stop-The-World"><a href="#全停顿-Stop-The-World" class="headerlink" title="全停顿 Stop-The-World"></a>全停顿 Stop-The-World</h3><p>JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为叫做 <strong>全停顿 Stop-The-World</strong>。</p><p>在新生代的垃圾回收中，因其空间较小，且活动对象较少，所以全停顿的影响不大，但老生代就不一样。为了降低老生代的垃圾回收而造成的卡顿，V8 引擎使用了 <strong>增量标记 Incremental Marking 算法</strong>：将标记过程分为一个个的子标记过程，同时让垃圾回收标记与 JavaScript 应用逻辑交替进行，直到标记阶段完成。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e16d93c2c8414d3ab7eac55c852c678a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行。这样用户就不容易感受到页面的卡顿了。</p><p>增量标记的优缺</p><p>优：主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅</p><p>缺： 但是由于每个小的增量标记之间执行了 <code>JavaScript</code> 代码，堆中的对象指针可能发生了变化</p><h3 id="并行回收-Concurrent"><a href="#并行回收-Concurrent" class="headerlink" title="并行回收 Concurrent"></a>并行回收 Concurrent</h3><p>它指的是主线程在执行 <code>JavaScript</code> 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bae064a3a8e481b8829c9c7aef73a06~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 <code>JavaScript </code> 时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点，这里我们不再细说</p><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>AJAX 指 <strong>异步 JavaScript 与 XML （Asynchronous JavaScript And XML）</strong>。</p><p>尽管 X 在 Ajax 中代表 XML，但由于<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/JSON">JSON</a>的许多优势，比如更加轻量以及作为 Javascript 的一部分，目前 JSON 的使用比 XML 更加普遍。JSON 和 XML 都被用于在 Ajax 模型中打包信息。</p><p>AJAX 是一个技术统称，是一个概念模型，并不特指某一技术，<code>XMLHttpRequest</code> 是实现 AJAX 的一种常见方式。</p><p>AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。不使用 AJAX 的传统网页如果需要更新内容，必须重载整个页面。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><strong>创建 XMLHttpRequest 对象</strong></li></ol><p>所有现代浏览器均内建 <code>XMLHttpRequest</code> 对象，只需要像创建实例对象一样去创建 <code>XMLHttpRequest</code> 实例即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br></pre></td></tr></table></figure><ol start="2"><li>发送请求</li></ol><p>将请求发送到服务器，可以使用 <code>XMLHttpRequest</code> 实例的 <code>open()</code> 与 <code>send()</code> 方法：</p><ul><li>  <code>XMLHttpRequest.prototype.open()</code></li></ul><p><code>open()</code> 方法接收三个参数：</p><p>（1）HTTP 请求方法。可以是 <code>GET</code>、<code>POST</code> 以及其他服务器支持的方法，但是要注意，这些方法需要保证大写。</p><p>（2）目的地的 URL。由于 <a href="https://blog.yucohny.vercel.app/computer-network/same-origin-policy">同源策略</a> 的限制，默认不能向非同源进行请求。</p><p>（3）第三个参数是可选参数，设置该请求是否是异步请求。如果为 <code>true</code>（默认值），即开启异步。</p><ul><li>  <code>XMLHttpRequest.prototype.send()</code></li></ul><p><code>send()</code> 方法可以接收一个可选参数，即想要发送给服务器的且服务器可以解析的表单数据。</p><ol start="3"><li>设置请求头</li></ol><p>可以通过 <code>setRequestHeader()</code> 方法设置请求头：</p><p>如果想要发送 <code>POST</code> 数据，那么需要在请求头中设置 <code>Content-Type</code> 字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li>处理服务器响应</li></ol><p>可以在 <code>XMLHttpRequest</code> 实例的 <code>onreadystatechange</code> 属性设置当请求状态改变时的回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>响应函数会在 <code>XMLHttpRequest</code> 实例对象属性 <code>readyState</code> 发生变化时调用。<code>readyState</code> 的具体值与含义如下：</p><ul><li>  <code>0</code>：请求未初始化；</li><li>  <code>1</code>：已建立服务器连接；</li><li>  <code>2</code>：请求已接受；</li><li>  <code>3</code>：正在处理请求；</li><li>  <code>4</code>：请求已完成。</li></ul><p>除此之外，可以通过 <code>XMLHttpRequest</code> 实例对象 <code>status</code> 属性检查响应码。</p><p>如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">使用xhr发送get请求</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 创建xhr对象</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="number">2.</span> 调用xhr.<span class="title function_">open</span>() 函数</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>)</span><br><span class="line"><span class="number">3.</span> 调用xhr.<span class="title function_">send</span>() 函数</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 监听 xhr.<span class="property">onreadystatechange</span> 事件</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//监听xhr对象的请求状态readyState 和 与服务器响应的状态status</span></span><br><span class="line"><span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span>=== xxx)  &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">resposeText</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">发送post请求</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 创建xhr对象</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="number">2.</span> 调用xhr.<span class="title function_">open</span>() 函数</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>)</span><br><span class="line"><span class="number">3.</span> 设置 <span class="title class_">Content</span>-<span class="title class_">Type</span>属性 （固定写法）</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line"><span class="number">3.</span> 调用xhr.<span class="title function_">send</span>() 函数   同时将数据以 查询字符串 的形式传入</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&#x27;bookname=水浒传&amp;author=赎买按&amp;publisher=&#x27;</span>zzz<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">4. 监听 xhr.onreadystatechange 事件</span></span><br><span class="line"><span class="string">xhr.onreadystatechange = function() &#123;</span></span><br><span class="line"><span class="string">//监听xhr对象的请求状态readyState 和 与服务器响应的状态status</span></span><br><span class="line"><span class="string">if(xhr.readyState === 4 &amp;&amp; xhr.status=== xxx)  &#123;</span></span><br><span class="line"><span class="string">console.log(xhr.resposeText)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>具体的，可以使用 <code>XMLHttpRequest</code> 实例对象 <code>responseTest</code> 或者 <code>responseXML</code> 获取响应数据：</p><ul><li>  <code>responseText</code>：服务器以文本字符的形式返回，可以据此获得字符串形式的响应数据并直接使用：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">innerHTML</span> = request.<span class="property">responseText</span></span><br></pre></td></tr></table></figure><ul><li>  <code>responseXML</code>：服务器以 <code>XMLDocument</code> 对象的形式返回，之后可以使用 JavaScript 进行更深的处理：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xmlDocument = xmlhttp.<span class="property">responseXML</span></span><br><span class="line"><span class="keyword">const</span> x = xmlDocument.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;ARTIST&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> txt = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; x.<span class="property">length</span>; i++) &#123;</span><br><span class="line">txt = txt + x[i].<span class="property">childNodes</span>[<span class="number">0</span>].<span class="property">nodeValue</span> + <span class="string">&#x27;&lt;br&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">innerHTML</span> = txt</span><br></pre></td></tr></table></figure><p>xhr level2 新特性 1. 可以设置 http 请求的时限</p><p>​ 新增 timeout 属性，设置 http 请求时限<br>​ xhr.timeout = 3000 单位是 ms<br>​ 其对应事件<br>​ xhr.ontimeout = function(event) {}</p><ol start="2"><li><p>使用 FormData 对象管理表单数据</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> let fa = new FormData()</span><br><span class="line">   fd.append(&#x27;zz&#x27;,&#x27;zz&#x27;)</span><br><span class="line">   fa.append(&#x27;pp&#x27;,&#x27;pp&#x27;)</span><br><span class="line">    let xhr = new XMLHttpRequest()</span><br><span class="line">      xhr.open(&#x27;POST&#x27;,&#x27;url&#x27;)</span><br><span class="line">    xhr.send(fd)</span><br><span class="line"></span><br><span class="line">也可以获取网页表单的值</span><br><span class="line">let form = document.querySelector(&quot;#form1&quot;) 获取表单元素</span><br><span class="line">  let fd = new FormData(form)</span><br><span class="line">  直接传入该元素就能自动填充</span><br></pre></td></tr></table></figure></li><li><p>可以上传文件</p><ol><li>定义 UI 结构<input type='file'></li><li>验证是否选择了文件<br>获取选择的文件列表<br>let files = document.querySelector(‘#file1’).files</li><li>向 FormData 中传入文件<br>let fd = new FormData()<br>fd.append(‘name’, files[0])</li><li>使用 xhr 发起上传文件的请求<br>上传文件需要使用 post<br>xhr.send(fd)</li></ol></li><li><p>可以获得数据传输的进度信息<br>监听 xhr.upload.onprogress</p><p> xhr.upload.onprogress = function(e) {<br> e.lengthComputable 是一个布尔值，表示当前上传资源是否具有可计算的长度<br> if(e.lengthComputable) {<br> e.loaded 已传输字节<br> e.total 需要传输的字节<br> let percentComplete = Math.cell( (e.loaded / e.total) * 100)<br> }<br> }</p><p> xhr.upload.onload 传输完成的函数</p></li></ol><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="EventTarget-接口"><a href="#EventTarget-接口" class="headerlink" title="EventTarget 接口"></a>EventTarget 接口</h2><p>DOM 节点的事件操作都定义在 <code>EventTarget</code> 中。所有节点对象，以及其他一些需要事件通信的浏览器内置对象继承自 <code>EventTarget</code> 的原型，从而可以调用事件接口。</p><p>事件接口主要提供三个实例方法：</p><ul><li>  <code>addEventListener()</code>：绑定事件的监听函数；</li><li>  <code>removeEventListener()</code>：移除事件的监听函数；</li><li>  <code>dispatchEvent()</code>：触发事件</li></ul><h3 id="EventTarget-prototype-addEventListener"><a href="#EventTarget-prototype-addEventListener" class="headerlink" title="EventTarget.prototype.addEventListener()"></a>EventTarget.prototype.addEventListener()</h3><p><code>addEventListener()</code> 方法用于在当前节点或对象上定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。</p><p>该方法可以接收三个参数：</p><ul><li>  <code>type</code>：字符串形式的事件名称；</li><li>  <code>listener</code>：监听函数，即事件发生时的回调函数；</li></ul><p>第二个参数除了可以直接传入函数作为监听函数外，也可以是一个具有 <code>handleEvent()</code> 方法的对象，效果与监听函数一样。当事件发生时，会调用该对象的 <code>handleEvent()</code> 方法。</p><p>监听函数内部的 <code>this</code> 指向了触发事件的对象。</p><ul><li>  <code>useCapture</code>：布尔值，可选参数，默认为 <code>false</code>，表示监听函数将在冒泡阶段被触发。如果值为 <code>true</code>，表示监听函数将在捕获阶段触发。</li></ul><p>如下面一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, print, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>上面的代码便是在 id 为 <code>btn</code> 的节点上绑定了 <code>click</code> 事件，当事件被触发时，会在冒泡阶段打印触发节点的信息。</p><p>第三个参数除了是布尔值，还可以是一个监听器配置对象。该对象具有以下属性：</p><ul><li>  <code>capture</code>：布尔值，如果缺省该属性，则默认为 <code>false</code>。<code>capture</code> 属性与 <code>useCapture</code> 一致。</li><li>  <code>once</code>：布尔值，如果缺省该属性，则默认为 <code>false</code>。如果该属性为 <code>true</code>，则表示该监听函数执行一次就会自动移除，后面将不再监听该事件。</li><li>  <code>passive</code>：布尔值，如果确实该属性，则默认为 <code>false</code>。如果该属性为 <code>true</code>，则表示禁止监听函数调用 <code>preventDefault()</code> 方法。如果 <code>passive</code> 为 <code>true</code> 并且调用 <code>preventDefault()</code> 方法，浏览器将忽略该请求，并在控制台输出一条警告。</li><li>  <code>signal</code>：该属性为一个 <code>AbortSignal</code> 对象，用于在需要时发出信号，移除监听函数。</li></ul><p><code>addEventListener()</code> 方法可以为同一个对象同一个事件添加多个 <strong>不同的监听函数</strong>。这些函数按照顺序先添加先触发，顺序触发。如果为同一个对象同一个事件添加多个相同的监听函数，那么当事件发生时只会触发一次。</p><h3 id="EventTarget-prototype-removeEventListener"><a href="#EventTarget-prototype-removeEventListener" class="headerlink" title="EventTarget.prototype.removeEventListener()"></a>EventTarget.prototype.removeEventListener()</h3><p><code>removeEventListener()</code> 方法用于移除 <code>addEventListener()</code> 方法添加的事件监听函数，同样没有返回值。</p><p>如果想要移除监听事件，需要让 <code>removeEventListener()</code> 的每一个参数，与 <code>addEventListener()</code> 完全一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, print, <span class="literal">false</span>)</span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, print, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="EventTarget-prototype-dispatchEvent"><a href="#EventTarget-prototype-dispatchEvent" class="headerlink" title="EventTarget.prototype.dispatchEvent()"></a>EventTarget.prototype.dispatchEvent()</h3><p><code>dispatchEvent()</code> 方法用于在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了 <code>preventDefault()</code>，则返回值为 <code>false</code>，否则为 <code>true</code>。</p><p><code>dispatchEvent()</code> 方法的参数是一个 <a href="https://blog.yucohny.vercel.app/javascript/event"><code>Event</code></a> 对象的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, print, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>))</span><br></pre></td></tr></table></figure><p>如果 <code>dispatchEvent()</code> 方法参数为空，或者不是一个有效的事件对象，将报错。</p><h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><h3 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h3><p>一个事件发生后，会在子元素与父元素之间传播。这种传播顺序分为三个阶段：</p><ul><li>  捕获阶段：从顶层对象（浏览器中即为 <code>window</code> 对象）传导至目标结点；</li><li>  目标阶段：事件在目标节点上触发；</li><li>  冒泡阶段：从目标结点传导回顶层对象。</li></ul><h3 id="事件的代理（委托）"><a href="#事件的代理（委托）" class="headerlink" title="事件的代理（委托）"></a>事件的代理（委托）</h3><p>由于事件会在冒泡阶段向上传播到父节点，所以可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做 <strong>事件的代理</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// work</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>事件的代理好处是，只需要在父节点定义一个监听函数，就可以处理多个子节点的事件，而不用在每个子节点上设置监听函数。并且，如果以后继续添加子节点，父节点的监听函数依然有效。</p><p>如果希望事件传播到某个节点为止之后不再传播，可以使用事件对象的 <code>stopPropagation()</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件传播到 p 元素后，就不再向下传播了</span></span><br><span class="line">p.<span class="title function_">addEventListener</span>(</span><br><span class="line"><span class="string">&#x27;click&#x27;</span>,</span><br><span class="line"><span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">event.<span class="title function_">stopPropagation</span>()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件冒泡到 p 元素后，就不再向上冒泡了</span></span><br><span class="line">p.<span class="title function_">addEventListener</span>(</span><br><span class="line"><span class="string">&#x27;click&#x27;</span>,</span><br><span class="line"><span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">event.<span class="title function_">stopPropagation</span>()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>stopPropagation()</code> 方法只会阻止事件的传播，并不会阻止该事件触发当前节点其他相同事件的监听函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">event.<span class="title function_">stopPropagation</span>()</span><br><span class="line"><span class="comment">// 会输出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line"><span class="comment">// 会输出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>事件发生以后，会产生 <code>Event</code> 实例对象作为参数传递给事件监听函数。</p><p><code>Event</code> 本身就是一个构造函数，可以用来生成新的实例。</p><p><code>Event</code> 构造函数接收两个参数：</p><ul><li>  <code>type</code>：事件的名称；</li><li>options：一个对象，表示事件对象的配置。该对象主要有下面两个属性：<ul><li>  <code>bubbles</code>：布尔值，可选，默认为 <code>false</code>，表示该事件是否会执行冒泡阶段。<code>Event</code> 构造函数生成的事件实例会在捕获阶段触发。</li><li>  <code>cancelable</code>：布尔值，可选，默认为 <code>false</code>，表示事件是否可以通过 <code>Event.preventDefault()</code> 取消。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fu = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fu.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, callback)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">dispatchEvent</span>(event)</span><br></pre></td></tr></table></figure><p>首先在父节点上绑定了冒泡阶段会触发的点击事件，但是由于儿子节点触发的点击事件不会进入冒泡阶段，因此父结点上设置的点击监听事件不会触发。如果 div 的事件监听变成捕获阶段触发（<code>&#39;click&#39;, callback, true</code>），儿子节点的事件就会触发, 或者这样<code>new Event(&#39;click&#39;, &#123;bubbles: true&#125;)</code></p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a><strong>实例属性</strong></h3><p><strong>bubbles</strong></p><p><code>bubbles</code> 属性为布尔值，表示该事件是否会执行冒泡阶段。该属性只读，除非显式在构造函数中显式指定 <code>bubbles: true</code>，否则默认为 <code>true</code>。</p><p><strong>eventPhase</strong></p><p><code>eventPhase</code> 属性为整数常量，表示事件当前所处阶段。该属性只读。</p><p><code>eventPhase</code> 值为以下四种中的一种：</p><ul><li>  <code>0</code>：事件没有发生；</li><li>  <code>1</code>：事件处于捕获阶段；</li><li>  <code>2</code>：事件处于目标阶段，即目标节点；</li><li>  <code>3</code>：事件处于冒泡阶段。</li></ul><p><strong>cancelable</strong></p><p><code>cancelable</code> 为布尔值，表示事件是否可以取消。该属性只读，除非显式在构造函数中显式指定 <code>cancelable: true</code>，否则默认为 <code>true</code>。</p><p><strong>cancelBubble</strong></p><p><code>cancelBubble</code> 为布尔值，如果设为 <code>true</code>，相当于执行 <code>Event.stopPropagation()</code>，即阻止事件的传播。</p><p><strong>defaultPrevented</strong></p><p><code>defaultPrevented</code> 为布尔值，表示该事件是否调用过 <code>Event.preventDefault</code> 方法。该属性只读。</p><p><strong>target 与 currentTarget</strong></p><p>事件发生后，会在捕获阶段与冒泡阶段经过多个 DOM 节点。因此，任何事件都有两个与事件相关的节点，一个是事件的原始触发节点 <code>target</code>，另一个是事件当前正在通过的节点 <code>currentTarget</code>。</p><p><code>target</code> 通常是 <code>currentTarget</code> 的后代节点。</p><p>由于监听函数只有事件经过时才会触发，所以 <code>currentTarget</code> 总是等同于监听函数内部的 <code>this</code>。</p><p><strong>type</strong></p><p><code>type</code> 属性为字符串，表示事件类型。该属性只读。</p><p><strong>timeStamp</strong></p><p><code>timeStamp</code> 属性为网页加载成功至事件触发的毫秒时间间隔。</p><p><code>timeStamp</code> 可能是整数，也可能是小数，取决于浏览器的设置。</p><p><strong>isTrusted</strong></p><p><code>isTrusted</code> 属性为布尔值，表示该事件是否由用户行为产生：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">isTrusted</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><strong>preventDefault</strong>()</p><p><code>preventDefault()</code> 方法用于取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了。</p><p>该方法生效的前提是事件实例的 <code>cancelable</code> 为 <code>true</code>，如果为 <code>false</code>，那么调用该方法没有任何效果。</p><p>该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，需要使用 <code>stopPropagation()</code> 或 <code>stopImmediatePropagation()</code> 方法。</p><p><strong>stopPropagation</strong>()</p><p><code>stopPropagation()</code> 方法阻止事件继续传播或冒泡，即防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p><p><strong>stopImmediatePropagation</strong>()</p><p><code>stopImmediatePropagation()</code> 方法阻止同一个事件的所有监听函数被调用。</p><p><strong>composedPath</strong>()</p><p><code>composedPath()</code> 返回一个数组，数组成员依次是事件冒泡从下往上会经过的所有节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id=&#x27;div&#x27;&gt;</span></span><br><span class="line"><span class="comment">//     &lt;button id=&#x27;btn&#x27;&gt;</span></span><br><span class="line"><span class="comment">//        Click</span></span><br><span class="line"><span class="comment">//    &lt;/button&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="title function_">composedPath</span>())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (6) [button#btn, div#div, body, html, document, Window]</span></span><br></pre></td></tr></table></figure><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>ES6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体来讲，我们可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用；在对目标对象的各种操作直接影响目标对象之前，可以在代理对象中对这些操作加以控制。</p><h2 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h2><p>即除了作为一个抽象的目标对象，没有其他的特别功能，在默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象</p><p>代理是使用 Proxy 构造函数创建的。这个构造函数接收两个<strong>必要</strong>参数：目标对象和处理程序对象。对于空代理的处理程序对象，我们只需要传递一个简单的对象字面量即可。</p><p>空代理对象上执行的操作都会应用到目标对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>) <span class="comment">// target</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>) <span class="comment">// target</span></span><br><span class="line"></span><br><span class="line">target.<span class="property">one</span> = <span class="string">&#x27;one&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">one</span>) <span class="comment">// one</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">one</span>) <span class="comment">// one</span></span><br><span class="line"></span><br><span class="line">proxy.<span class="property">two</span> = <span class="string">&#x27;two&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">two</span>) <span class="comment">// two</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">two</span>) <span class="comment">// two</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;id&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;id&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>  Proxy.prototype 为 undefined， 所有不能使用 instanceof 操作符</li></ul><h2 id="捕获器"><a href="#捕获器" class="headerlink" title="捕获器"></a>捕获器</h2><p>捕获器就是在处理程序对象中定义的“基本操作的拦截器”。</p><p>每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改对应的行为。</p><p>如同下面的例子，我们定义了一个 get() 捕获器，那么在代理对象中执行 get() 操作时，就会触发定义的 get() 捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器，在目标对象上执行这些操作仍然会产生正常的行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> trap = &#123;</span><br><span class="line"><span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;this action is modified by proxy&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, trap)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>) <span class="comment">// target</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>) <span class="comment">// this action is modified by proxy</span></span><br></pre></td></tr></table></figure><p>​</p><h2 id="捕获器的参数与-Reflect-对象"><a href="#捕获器的参数与-Reflect-对象" class="headerlink" title="捕获器的参数与 Reflect 对象"></a>捕获器的参数与 Reflect 对象</h2><p><strong>参数</strong></p><p>使用捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。不同的捕获器可能存在不同的参数，get() 中存在三个参数：依次为目标对象、要查询的属性和代理对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> trap = &#123;</span><br><span class="line"><span class="title function_">get</span>(<span class="params">targetObj, property, proxyObj</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target === targetObj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(property)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy === proxyObj)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, trap)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">id</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// id</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>Reflect</strong><br>所有捕获器都可以基于上面的这三个参数来重建原始参数，但是更多的捕获器函数并不都像上面的例子这么简单，因此，总是手写是不实际的。而事实上，开发者不需要手动重建原始行为，而是可以通过调用封装了原始行为的全局 Reflect 对象上的同名方法来重建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"><span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> trap = &#123;</span><br><span class="line"><span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，也可以这样定义：</span></span><br><span class="line"><span class="comment">// const trap = &#123;</span></span><br><span class="line"><span class="comment">//     get: Reflect.get</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, trap)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>) <span class="comment">// target</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>) <span class="comment">// target</span></span><br></pre></td></tr></table></figure><p><code>Reflect</code> 对象共有 13 个静态方法，下面介绍两种</p><ol><li>Reflect.get(target, name, receiver)</li></ol><p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;bar&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;baz&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">bar</span>: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;baz&#x27;</span>, myReceiverObject) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Reflect.set(target, name, value, receiver)</li></ol><p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  set bar(value) &#123;</span><br><span class="line">    return this.foo = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.foo // 1</span><br><span class="line"></span><br><span class="line">Reflect.set(myObject, &#x27;foo&#x27;, 2);</span><br><span class="line">myObject.foo // 2</span><br><span class="line"></span><br><span class="line">Reflect.set(myObject, &#x27;bar&#x27;, 3)</span><br><span class="line">myObject.foo // 3</span><br></pre></td></tr></table></figure><p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="number">4</span>,</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">foo</span> = value)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;bar&#x27;</span>, <span class="number">1</span>, myReceiverObject)</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 4</span></span><br><span class="line">myReceiverObject.<span class="property">foo</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>模块模式的思想是：将代码逻辑分成独立模块，按照各自的内容进行封装，每个模块自行决定向外暴露什么内容，同时自行引入执行其他模块。</p><p>在 ES6 发布模块规范之前，不同的模块系统具有各自的模块语法，同时具有单独的模块工具将自己的模块语法与 JavaScript Runtime 连接。</p><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS 规范创建了 <strong>服务端的模块约定</strong>。尽管 CommonJS 也可用于定义在浏览器中使用的模块依赖，但是 CommonJS 模块语法<strong>不能在浏览器中直接运行</strong>。</p><blockquote><p>Node.js 使用了轻微修改版本的 CommonJS 规范。</p></blockquote><p>CommonJS 规范使用 <code>require()</code> 方法导入模块依赖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> demo = <span class="built_in">require</span>(<span class="string">&#x27;./demo&#x27;</span>)</span><br></pre></td></tr></table></figure><p>CommonJS 规范使用 <code>module.exports</code> 对象暴露公共 API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别地，如果想要暴露一个具体值，那么可以直接赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;Yucohny&#x27;</span></span><br></pre></td></tr></table></figure><p>在 CommonJS 中，模块第一次加载后会进行缓存，后续加载将会取得缓存的模块。同时，CommonJS 模块的加载顺序由依赖关系决定。</p><p>在 CommonJS 中，模块加载是模块系统执行的同步操作，因此 <code>require()</code> 方法可以以编程式嵌入在模块代码中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">const</span> demo = <span class="built_in">require</span>(<span class="string">&#x27;./demo&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p><strong>异步模块定义 Asynchronous Module Definition AMD</strong> 的模块系统以浏览器为目标执行环境，因此需要考虑网络延迟问题。</p><p>AMD 的一般策略是让模块声明自己的依赖，而运行在浏览器中的模块系统会按需获取依赖，并在依赖加载完成后立即执行依赖它们的模块。</p><p>AMD 规范的核心是使用函数包装模块定义，这样做有几点优势：</p><ol><li>由于函数作用域的存在，<strong>不会声明全局变量</strong>；</li><li><strong>允许加载器库控制何时加载模块</strong>。</li><li>由于包装函数内部的所有模块代码使用的都是原生 JavaScript 结构，因此更加易于模块代码的移植。</li></ol><p>AMD 支持 <code>require</code> 与 <code>exports</code> 对象，通过它们可以在 AMD 模块工厂函数内部定义 CommonJS 风格的模块。但 AMD 加载器会将它们识别为 AMD 结构，而不是模块定义。</p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="模块标签"><a href="#模块标签" class="headerlink" title="模块标签"></a>模块标签</h3><p>带有 <code>type=&quot;module&quot;</code> 属性的 <code>&lt;script&gt;</code> 标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行。</p><p>模块可以直接嵌入在网页中，也可以作为外部文件引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;MODULEURL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>与 <code>&lt;script defer&gt;</code> 加载的脚本一样，引入的模块会立即下载模块文件，但执行会延迟至文档解析完成。</p><p>值得注意的是，嵌入的模块代码不能使用 <code>import</code> 加载到其他模块；只有通过外部文件加载的模块代码才可以使用 <code>import</code> 加载，因此，嵌入模块只时候作为入口模块。</p><h3 id="模块行为"><a href="#模块行为" class="headerlink" title="模块行为"></a>模块行为</h3><p>ES6 新增的模块功能借用了 CommonJS 与 AMD 的许多优秀特性，包括：</p><ol><li>模块代码只在加载后执行；</li><li>模块只能加载一次；</li><li>模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互；</li><li>……</li></ol><p>同时，ES6 的模块系统也增加了一些新行为：</p><ol><li>ES6 模块默认在严格模式下执行；</li><li>ES6 模块不共享全局命名空间；</li><li>ES6 模块顶级 <code>this</code> 的值是 <code>undefined</code>，而常规脚本中是 <code>window</code>；</li><li>……</li></ol><p>浏览器运行时在知道应该把某个文件当成模块时，会有条件地按照 ES6 模块的行为添加限制。与 <code>&lt;script type=&quot;module&quot;&gt;</code> 关联或者通过 <code>import</code> 语句加载的 JavaScript 文件会被认定为模块。</p><h3 id="模块导出"><a href="#模块导出" class="headerlink" title="模块导出"></a>模块导出</h3><p>ES6 模块通过 <code>export</code> 关键字实现两种导出方式：命名导出与默认导出。不同的导出方式对应了不同的导入方式。</p><p><strong>命名导出（按需导出）</strong></p><p><code>export</code> 关键字用于声明一个值为命名导出。要注意的是，导出语句不能嵌套于某个块中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> xxx <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">export</span> xxx <span class="comment">// 不允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要将某个变量导出，可以使用行内命名导出，或者变量声明于导出不在同一行。</p><p>行内命名导出，指的是变量声明与变量导出写于同一行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br></pre></td></tr></table></figure><p>但是也可以不在同一行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name &#125;</span><br></pre></td></tr></table></figure><p>如果想要在导出时为变量提供别名，那可以且仅能通过 <code>export</code> 表达式中大括号的 <code>as</code> 标识符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> myName &#125;</span><br></pre></td></tr></table></figure><p><strong>默认导出</strong></p><p><strong>默认导出 Default Export</strong> 将模块直接视为被导出的值。</p><p>默认导出使用 <code>default</code> 关键字将一个变量的值声明为默认导出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = &quot;Yucohny&quot;</span><br><span class="line">export default name</span><br></pre></td></tr></table></figure><p>要注意的是，一个模块只能有一个默认导出，重复的默认导出会出现 <code>SyntaxError</code> 错误。</p><p>由于 <code>default</code> 是默认导出关键字，因此如果在命名语法中出现 <code>default</code> 关键字，那么会将其视为默认导出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Yucohny&quot;</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name</span><br></pre></td></tr></table></figure><p>命名导出与默认导出不会产生冲突，因此可以在同一个模块中同时定义这两种导出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">20</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> <span class="keyword">default</span>, age &#125;</span><br></pre></td></tr></table></figure><h3 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h3><p>模块使用 <code>import</code> 关键字导入其他模块导出的值。与 <code>export</code> 一样，<code>import</code> 语句不能出现在块中。</p><p><code>import</code> 后面跟导入的模块路径，这个路径必须是直接给出，不能是动态计算的结果，比如不支持字符串拼接。</p><p>命名导出可以使用 <code>*</code> 批量获取并赋值给保存导出对象的别名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">20</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, age &#125;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> demo <span class="keyword">from</span> <span class="string">&#x27;./demo.js&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(demo.<span class="property">age</span>)</span><br></pre></td></tr></table></figure><p>如果想要指定部分导入，那么直接将需要导入的属性指定于 <code>import</code> 语句中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, age <span class="keyword">as</span> myAge &#125; <span class="keyword">from</span> <span class="string">&#x27;./demo.js&#x27;</span></span><br></pre></td></tr></table></figure><p>默认导出可以使用 <code>default</code> 关键字并提供 <strong>别名</strong> 实现导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> myAge &#125; <span class="keyword">from</span> <span class="string">&#x27;./demo.js&#x27;</span></span><br></pre></td></tr></table></figure><p>也可以不使用 <code>default</code> 关键字与大括号，但是此时导入的变量名就固定为导出时的变量名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> age <span class="keyword">from</span> <span class="string">&#x27;./demo.js&#x27;</span></span><br></pre></td></tr></table></figure><p>如果模块同时使用了命名导出与默认导出，那么可以在 <code>import</code> 语句中同时获得它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Yucohny&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">20</span></span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> <span class="keyword">default</span>, age &#125;</span><br><span class="line"><span class="keyword">import</span> name, &#123; age <span class="keyword">as</span> myAge &#125; <span class="keyword">from</span> <span class="string">&#x27;./demo.js&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本使用</title>
      <link href="/2023/02/08/%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/02/08/%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="基础用法说明"><a href="#基础用法说明" class="headerlink" title="基础用法说明"></a>基础用法说明</h1><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p><code>Front-matter</code> 是 markdown 文件最上方以<code>---</code>分隔的区域，用于指定个别档案的变数。</p><ul><li>  Page Front-matter 用于页面配置</li><li>  Post Front-matter 用于文章页配置</li></ul><p><strong>Page Front-matter：</strong></p><table><thead><tr><th align="left">写法</th><th>解释</th></tr></thead><tbody><tr><td align="left">title</td><td>【必需】页面标题</td></tr><tr><td align="left">date</td><td>【必需】页面创建日期</td></tr><tr><td align="left">type</td><td>【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td align="left">updated</td><td>【可选】页面更新日期</td></tr><tr><td align="left">description</td><td>【可选】页面描述</td></tr><tr><td align="left">keywords</td><td>【可选】页面关键字</td></tr><tr><td align="left">comments</td><td>【可选】显示页面评论模块(默认 true)</td></tr><tr><td align="left">top_img</td><td>【可选】页面顶部图片</td></tr><tr><td align="left">mathjax</td><td>【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">kates</td><td>【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td align="left">aplayer</td><td>【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置</td></tr><tr><td align="left">highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><p><strong>Post Front-matter：</strong></p><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置 top_img,文章页顶部将显示缩略图，可设为 false/图片地址/留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章 TOC(默认为设置中 toc 的 enable 配置)</td></tr><tr><td>toc_number</td><td>【可选】显示 toc_number(默认为设置中 toc 的 number 配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中 post_copyright 的 enable 配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中 highlight_shrink 的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> introduction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React</title>
      <link href="/2023/02/08/react/"/>
      <url>/2023/02/08/react/</url>
      
        <content type="html"><![CDATA[<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><h2 id="jsx-语法规则"><a href="#jsx-语法规则" class="headerlink" title="jsx 语法规则"></a>jsx 语法规则</h2><p>1.写虚拟 DOM 时，不要写引号。</p><p>2.标签中混入 JS 表达式时，要使用花括号 {} 。</p><p>3.样式的类名指定不要用 class ，要用 className 。</p><p>4.内联样式，要用 style=<code>&#123;&#123;key: value&#125;&#125;</code> 的形式去写。</p><blockquote><p>此处的第一个 {} 源于规则 2，表示内部是一个 js 对象</p></blockquote><p>5.虚拟 DOM 只能有一个根标签。</p><p>6.标签必须闭合。</p><p>7.标签首字母</p><ul><li>  若小写字母开头，则将该标签转为 html 同名元素，若 html 中无该标签中的同名元素，则报错</li><li>  若大写字母开头， react 就去渲染对应的组件，若组件没有报错，则报错。</li></ul><h2 id="React-必须在作用域内"><a href="#React-必须在作用域内" class="headerlink" title="React 必须在作用域内"></a>React 必须在作用域内</h2><p>参考下面这个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">function Demo() &#123;</span><br><span class="line">    return &lt;div&gt;Hello, JSX&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们没有直接使用导入的 React，但是仍然需要导入，这是因为导入 React 才规定了这是 JSX 的代码作用域。</p><h2 id="Props-默认值为-“True”"><a href="#Props-默认值为-“True”" class="headerlink" title="Props 默认值为 “True”"></a>Props 默认值为 “True”</h2><p>如果没有给 prop 赋值，那么它将取默认值 true，因此以下两个 JSX 表达式是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyTextBox autocomplete /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyTextBox autocomplete=&#123;true&#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="空行与空格问题"><a href="#空行与空格问题" class="headerlink" title="空行与空格问题"></a>空行与空格问题</h2><p>SX 会移除行首尾的空格以及空行。与标签相邻的空行均会被删除，文本字符串之间的新行会被压缩为一个空格。因此以下的几种方式都是等价的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="布尔类型、Null-以及-Undefined-将会忽略"><a href="#布尔类型、Null-以及-Undefined-将会忽略" class="headerlink" title="布尔类型、Null 以及 Undefined 将会忽略"></a>布尔类型、Null 以及 Undefined 将会忽略</h2><p>false，null，undefined，和 true 是合法的子元素。但它们并不会被渲染。以下的 JSX 表达式渲染结果相同：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;false&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;null&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;undefined&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;true&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这有助于依据特定条件来渲染其他的 React 元素。例如，在以下 JSX 中，仅当 showHeader 为 true 时，才会渲染 <Header /> 组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;showHeader &amp;&amp;</span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> /&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">content</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>值得注意的是有一些 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">“falsy” 值</a>，如数字 0 ，仍然会被 React 渲染。例如，以下代码并不会像你预期那样工作，因为当 props.messages 是空数组时， 0 仍然会被渲染：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;props.messages.length &amp;&amp; <span class="tag">&lt;<span class="name">MessageList</span> <span class="attr">messages</span>=<span class="string">&quot;&#123;props.messages&#125;&quot;</span> /&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要解决这个问题，确保 &amp;&amp; 之前的表达式总是布尔值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;props.messages.length &gt; 0 &amp;&amp; <span class="tag">&lt;<span class="name">MessageList</span> <span class="attr">messages</span>=<span class="string">&quot;&#123;props.messages&#125;&quot;</span> /&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>反之，如果你想渲染 false 、 true 、 null 、 undefined 等值，你需要先将它们转换为字符串：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>My JavaScript variable is &#123;String(myVariable)&#125;.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        // 创建函数式组件</span><br><span class="line">        function Demo () &#123;</span><br><span class="line">            return &lt;h1&gt;zzz&lt;/h1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactDOM.render(&lt;Demo /&gt;, document.querySelector(&#x27;#test&#x27;))</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>注意</p><p>（1）我们没有直接调用函数式组件的这个函数，但是在渲染组件过程中，<code>React</code>会自动帮我们调用。</p><p>（2）函数式组件中的<code>this</code>指向何处？<code>undefined</code>。因为<code>babel</code>在翻译函数式组件时会自动开启严格模式，因此会禁止自定义函数中的<code>this</code>直接指向<code>window</code>。</p><p>（3）执行了<code>ReactDOM.render(...)</code>之后发生了什么？</p><ul><li>  <code>React</code>解析组件标签，找到了<code>Demo</code>组件</li><li>  发现组件是使用函数定义的，随后调用该函数，将返回的虚拟<code>DOM</code>转化为真实<code>DOM</code>，随后呈现在页面中。</li></ul><h2 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        // 创建函数式组件</span><br><span class="line">        class Demo extends React.Component &#123;</span><br><span class="line">            render () &#123;</span><br><span class="line">                return &lt;h1&gt;ppp&lt;/h1&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactDOM.render(&lt;Demo /&gt;, document.querySelector(&#x27;#test&#x27;))</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><p>（1）<code>render</code>方法是定义在原型对象上的，供实例使用。</p><p>（2）执行<code>ReactDOM.render(...)</code>后，发生了什么？</p><ul><li>  <code>React</code>解析组件标签，找到了<code>Demo</code>组件</li><li>  发现组件是类式组件，随后调用<code>new</code>命令生成该类的实例对象，并通过该实例调用到原型的<code>render</code>方法。</li><li>  将<code>render</code>方法返回的虚拟<code>DOM</code>转化为真实<code>DOM</code>，并呈现在页面中。</li></ul><h1 id="state-props-refs"><a href="#state-props-refs" class="headerlink" title="state-props-refs"></a>state-props-refs</h1><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>我们可以通过在 constructor 中定义 state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        <span class="attr">isHappy</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 中，我们也可以直接在类的顶部定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">isHappy</span>: <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;isHappy&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>I’m &#123;isHappy ? &#x27;happy&#x27; : &#x27;sad&#x27;&#125; today.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类式组件中可以通过 this.props 获取传参</p></blockquote><h2 id="setState"><a href="#setState" class="headerlink" title="setState()"></a>setState()</h2><p>在 React 中， 状态 state 是不可以直接更改的</p><p>应该使用内置 API <code>setState() 进行</code>更新，同时，这种更新属于<strong>合并</strong></p><p>作用：</p><ul><li>  修改 state 中的数据状态</li><li>  更新 UI</li></ul><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>在渲染组件时，React 会自动把标签内的实行以对象的形式传到组件的属性 <code>props</code>中</p><ul><li>  函数式组件</li></ul><p>直接通过参数获取 props 对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FSon</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">子组件1</span></span><br><span class="line"><span class="language-xml">&#123;props.msg&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  类式组件</li></ul><p>通过 <code>this.props</code> 获取</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FSon</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">子组件1</span></span><br><span class="line"><span class="language-xml">&#123;props.msg&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们可以直接通过展开运算符进行简写，需要注意的是，展开运算符并不能直接展开对象的可遍历属性，此处可以如此书写是因为经过了 Babel 与 React 编译后得到的语法糖：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age, sex &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;小红&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;小蓝&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span> &#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Info</span> &#123;<span class="attr">...obj1</span>&#125; /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test1&#x27;</span>))</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Info</span> &#123;<span class="attr">...obj2</span>&#125; /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test2&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="对-props-属性进行限制"><a href="#对-props-属性进行限制" class="headerlink" title="对 props 属性进行限制"></a>对 props 属性进行限制</h2><p>在对组件标签属性进行限制，首先需要引入 <code>prop-types.js</code> 依赖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br></pre></td></tr></table></figure><p>随后在组件属性 <code>propTypes</code> 与 <code>defaultProps</code> 中对各项属性进行限制</p><p><strong>四种常见结构</strong></p><ol><li>常见类型：array、bool、func、number、object、string</li><li>React 元素类型：element</li><li>必填项：isRequired</li><li>特定的结构对象：shape({})</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见类型</span></span><br><span class="line"><span class="attr">optionalFunc</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>,</span><br><span class="line"><span class="comment">// 必填 只需要在类型后面串联一个isRequired</span></span><br><span class="line"><span class="attr">requiredFunc</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line"><span class="comment">// 特定结构的对象</span></span><br><span class="line"><span class="attr">optionalObjectWithShape</span>: <span class="title class_">PropTypes</span>.<span class="title function_">shape</span>(&#123;</span><br><span class="line"><span class="attr">color</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line"><span class="attr">fontSize</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="限制属性数据类型"><a href="#限制属性数据类型" class="headerlink" title="限制属性数据类型"></a>限制属性数据类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Demo.propTypes = &#123;</span><br><span class="line">    name: PropTypes.string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：当限制属性为某个数据类型时，必须要将该数据类型首字母小写，如上；而如果限制属性为函数，应该书写为 <code>func</code>。</p></blockquote><h3 id="限制属性必要性"><a href="#限制属性必要性" class="headerlink" title="限制属性必要性"></a>限制属性必要性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Demo.propTypes = &#123;</span><br><span class="line">    name: PropTypes.isRequired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限制属性初始值"><a href="#限制属性初始值" class="headerlink" title="限制属性初始值"></a>限制属性初始值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Demo.defaultProps = &#123;</span><br><span class="line">    name: &#x27;你没有名字&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限制单个子元素"><a href="#限制单个子元素" class="headerlink" title="限制单个子元素"></a>限制单个子元素</h3><p>可以通过 <code>PropTypes.element</code> 来确保传递给组件的某个属性只包含一个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyComponent</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line"><span class="attr">children</span>: <span class="title class_">PropTypes</span>.<span class="property">element</span>.<span class="property">isRequired</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简写方式"><a href="#简写方式" class="headerlink" title="简写方式"></a>简写方式</h3><p>可以将 <code>propTypes</code> 与 <code>defaultProps</code> 属性放入组件类中定义，并且声明为 <code>static</code> 属性，这样就可以避免在组件类的外部单独进行限制。</p><h2 id="子元素-chilren"><a href="#子元素-chilren" class="headerlink" title="子元素 chilren"></a>子元素 chilren</h2><p>包含在开始和结束标签之间的 JSX 表达式内容将作为特定属性 <code>props.children</code> 传递给外层组件。</p><p>如下面的这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent &#123;children:&#x27;zzz&#x27;&#125;&gt;Hello world!&lt;/MyComponent&gt;</span><br></pre></td></tr></table></figure><p>如果传入的 props 中恰好有一个属性名为 children， 那么它将会被覆盖，即此时 <code>props.children</code> 就只是 <code>Hello world!</code> 字符串。</p><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><h3 id="何时使用-refs？"><a href="#何时使用-refs？" class="headerlink" title="何时使用 refs？"></a>何时使用 refs？</h3><p>refs 的使用场景包括：</p><ol><li>管理焦点，文本选择或媒体播放。</li><li>触发强制动画。</li><li>集成第三方 DOM 库。</li></ol><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>  字符串形式的 ref</li></ul><p>直接将 ref 属性设置为字符串即可，但是这种方式用得很少，已经是官方 <strong>不推荐</strong> 的使用方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  回调函数形式的 ref</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(curNode)</span> =&gt;</span> (this.div = curNode)&#125;&gt;Test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  createRef 形式的 ref</li></ul><p>我们可以通过 React.createRef() 创建 Refs，并通过 ref 属性附加到 React 元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">myRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建的 Ref 被传递给 render 中渲染的元素时，我们可以在 Ref 的 current 属性中访问该元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const node = this.myRef.current</span><br></pre></td></tr></table></figure><p>要注意的时，Ref 的值根据节点的类型而有所不同：</p><ul><li>  当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</li><li>  当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li><li>  <strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为他们没有实例。</li></ul><h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><ul><li><p>通过<code>onXxx</code>属性指定事件处理函数（注意大小写）</p><ul><li><p><code>React</code>使用的是自定义（合成）事件，而不是使用的原生<code>DOM</code>事件。</p><ul><li><blockquote><p>为了更好的兼容性</p></blockquote></li></ul></li><li><p><code>React</code>中的事件是通过事件委托方式处理的（委托给组件最外层的元素）</p><ul><li><blockquote><p>为了更加高效</p></blockquote></li></ul></li></ul></li><li><p>通过<code>event.target</code>得到发送事件的<code>DOM</code>元素对象。</p><ul><li><blockquote><p>因此，可以用此方法避免<code>ref</code>的一些使用。</p></blockquote></li></ul></li></ul><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>完整生命周期：</p><p><img src="https://blog.yucohny.vercel.app/images/react/7.png" alt="img"></p><p>常用生命周期：</p><p><img src="https://blog.yucohny.vercel.app/images/react/8.png" alt="img"></p><h2 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h2><ol><li> 渲染 Render 阶段</li></ol><p>在此阶段中，React 会遍历虚拟 DOM，并通过 Diff 算法寻找组件树中变化的部分。当发现组件需要更新时，将会重新渲染该组件。</p><p>该阶段包含的生命周期如下：</p><ul><li>  <code>constructor()</code></li><li>  <code>static getDerivedStateFromProps()</code></li><li>  <code>shouldComponentUpdate()</code></li><li>  <code>render()</code></li></ul><ol start="2"><li>预提交 Pre-Commit 阶段</li></ol><p>此阶段存在一个不常用的生命周期方法，会在提交阶段前调用。</p><p>该阶段包含的生命周期如下：</p><ul><li>  <code>getSnapshotBeforeUpdate()</code></li></ul><ol start="3"><li>提交 Commit 阶段</li></ol><p>根据 React 最终渲染的结果对真实的 DOM 节点进行更新。</p><p>该阶段包含的生命周期如下：</p><ul><li>  <code>componentDidMount()</code></li><li>  <code>componentDidUpdate()</code></li><li>  <code>componentWillUnmount()</code></li></ul><h2 id="三种渲染情况"><a href="#三种渲染情况" class="headerlink" title="三种渲染情况"></a>三种渲染情况</h2><p>React 的渲染有三种情况：挂载、更新与卸载。每种情况都分别对应了上述三个阶段。</p><p>各个情况的各个阶段所对应的生命周期如下：</p><ol><li>挂载</li></ol><ul><li>渲染阶段<ul><li>  <code>constructor()</code></li><li>  <code>static getDerivedStateFromProps()</code></li><li>  <code>render()</code></li></ul></li><li>  预提交阶段</li></ul><p>无。</p><ul><li>提交阶段<ul><li>  <code>componentDidMount()</code></li></ul></li></ul><ol start="2"><li>更新</li></ol><ul><li>渲染阶段<ul><li>  <code>static getDerivedStateFromProps()</code></li><li>  <code>shouldComponentUpdate()</code></li><li>  <code>render()</code></li></ul></li><li>预提交阶段<ul><li>  <code>getSnapshotBeforeUpdate()</code></li></ul></li><li>提交阶段<ul><li>  <code>componentDidUpdate()</code></li></ul></li></ul><p>3 .卸载</p><ul><li>  渲染阶段与提交阶段</li></ul><p>无。</p><ul><li>提交阶段<ul><li>  <code>componentWillUnmount()</code></li></ul></li></ul><p>从中可以看出，尽管各种情况有着各自的生命周期方法，但是也存在部分交集。</p><h2 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h2><p><strong>contructor()</strong></p><p><code>constructor()</code> 方法仅会在挂载时触发。</p><p>与普通的类 Class 一样，React 类组件中的 <code>constructor()</code> 方法为组件的构造函数。</p><p>如果组件定义了构造函数，那么构造函数应该首先调用 <code>super(props)</code>，否则 <code>props</code> 属性可能会出现错误：</p><p>构造函数通常只用于以下两种情况：</p><ul><li>  绑定方法实例</li></ul><p>如果在组件中使用 <code>fucntion</code> 关键字而非箭头函数定义方法，那么该方法并不会绑定在组件实例自身，此时可以在构造函数中通过 <code>bind()</code> 等方法将其绑定至实例自身上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">class LifeCycleDemo extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.name = &#x27;Yucohny&#x27;</span><br><span class="line">        this.getName = this.getName.bind(this) // 在构造函数中绑定实例方法</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                My name is &#123;this.getName()&#125;.</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default LifeCycleDemo</span><br></pre></td></tr></table></figure><ul><li>  初始化 State。</li></ul><p>请直接使用 <code>this.state</code> 初始化 State，不要在构造函数中调用 <code>setState()</code>。</p><p>同时，避免将 <code>props</code> 中的属性赋值给 State。尽管不会出现语法错误，但是容易出现不易察觉的意料之外的错误。构造函数只会在初次挂载时执行，如果因为 <code>props</code> 的更新而引起组件的更新，那么 <code>props</code> 更新后的值将不会影响 State：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">class LifeCycleDemo extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            age: 20</span><br><span class="line">        &#125;</span><br><span class="line">        this.handleClick = this.handleClick.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            age: this.state.age + 1</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Son age=&#123;this.state.age&#125;/&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.handleClick&#125;&gt;Grow Up&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            age: props.age</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                I&#x27;m &#123;this.state.age&#125; years old.</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default LifeCycleDemo</span><br></pre></td></tr></table></figure><p>如上面的例子，当按下按钮时，父组件 State 发生改变，从而影响子组件的 <code>props</code> 属性，但是这并不会影响子组件 State 的值，因此页面展示的内容并不会发生变化。</p><p>由于上述两种使用场景都可以使用其他方式代替，因此 <code>constructor()</code> 方法可以完全不使用。</p><h3 id="static-getDerivedStateFromProps"><a href="#static-getDerivedStateFromProps" class="headerlink" title="static getDerivedStateFromProps()"></a>static getDerivedStateFromProps()</h3><p><code>getDerivedStateFromProps()</code> 方法在挂载与更新中都会执行。该方法返回一个对象用于更新当前组件状态，如果返回 <code>null</code> 将不会更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class LifeCycleDemo extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            age: 20</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static getDerivedStateFromProps() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            age: 21</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                I&#x27;m &#123;this.state.age&#125; years old.</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getDerivedStateFromProps()</code> 方法在挂载过程中接收两个参数，分别代表 <code>props</code> 与 State。在挂载过程中，<code>props</code> 即此时组件所接收的参数，State 即执行构造函数后所初始化的对象，如果没有初始化，那么此时 State 为 <code>null</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">class LifeCycleDemo extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            age: 20</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Son age=&#123;this.state.age&#125;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends React.Component &#123;</span><br><span class="line">    static getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">        console.log(`props: $&#123;props&#125;\nState: $&#123;state&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                I&#x27;m &#123;this.props.age&#125; years old.</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// props: [object Object]</span><br><span class="line">// State: null</span><br><span class="line"></span><br><span class="line">export default LifeCycleDemo</span><br></pre></td></tr></table></figure><p>在更新过程中，State 为更新之前的状态。</p><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate()"></a>shouldComponentUpdate()</h3><p><code>shouldComponentUpdate()</code> 方法仅会在更新时触发。</p><p>在默认情况下，React 组件 <code>props</code> 属性或 State 发生改变时会进行更新。但是，有的时候并不希望 <code>props</code> 属性或者 State 发生某种改变时直接更新组件，此时可以使用 <code>shouldComponentUpdate()</code> 方法。</p><p><code>shouldComponentUpdate()</code> 方法接收三个参数，分别是最新的 <code>props</code> 属性、最新的状态与最新 Context 对象，并返回一个布尔值。该布尔值默认为 <code>true</code>，表示该组件需要更新；如果返回值为 <code>false</code> 则说明该组件此次不更新，从而不会执行 <code>render()</code> 方法与预提交阶段以及提交阶段的钩子。</p><p>如果 <code>shouldComponentUpdate()</code> 方法始终返回 <code>false</code>，那么该组件将永远不会更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class LifeCycleDemo extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            age: 20</span><br><span class="line">        &#125;</span><br><span class="line">        this.handleClick = this.handleClick.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">        return false // 始终返回 false 会导致组件不会更新</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            age: this.state.age + 1</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    I&#x27;m &#123;this.state.age&#125; years old.</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.handleClick&#125;&gt;Grow Up&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果该方法返回 <code>false</code>，状态将不会更新，但是 <code>props</code> 仍然会更新。不过，该方法返回 <code>false</code> 时将不会重新渲染，因此尽管 <code>props</code> 更新了，但是页面是保持不变的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class LifeCycleDemo extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            age: 20</span><br><span class="line">        &#125;</span><br><span class="line">        this.handleClick = this.handleClick.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            age: this.state.age + 1</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Son age=&#123;this.state.age&#125;/&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.handleClick&#125;&gt;Grow Up&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends React.Component &#123;</span><br><span class="line">    shouldComponentUpdate(nextProps, nextState, nextContext) &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                I&#x27;m &#123;this.props.age&#125; years old.</span><br><span class="line">                &#123;/*this.props.age 更新了，但是因为没有重新渲染，所以页面保持不变*/&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><p><code>render()</code> 方法是类式组件中必须实现的方法，会在挂载与更新阶段中的渲染阶段末执行。</p><p><code>render()</code> 方法的返回类型是如下几种之一：</p><ol><li>React 元素；</li><li>数组或 Fragments；</li><li>Portals；</li><li>字符串或数值类型；</li></ol><p>如果返回类型是字符串或数值类型，React 会将其直接渲染为文本节点</p><ol start="5"><li>布尔值或 <code>null</code>。</li></ol><p>什么都不会渲染。</p><h2 id="预提交阶段-getSnapshotBeforeUpdate"><a href="#预提交阶段-getSnapshotBeforeUpdate" class="headerlink" title="预提交阶段 getSnapshotBeforeUpdate()"></a>预提交阶段 getSnapshotBeforeUpdate()</h2><p>预提交阶段只有 <code>getSnapshotBeforeUpdate()</code> 一个方法，并且只在更新时可能会调用。</p><p>预提交阶段接收两个参数，分别是之前的 <code>props</code> 属性与之前的状态。</p><p>该生命周期钩子能够在组件实际发生更改时获取一些其他信息，如当前的滚动位置。</p><p>该生命周期的任何返回值都将作为参数传递至 <code>componentDidUpdate()</code>。</p><h2 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h2><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h3><p><code>componentDidMount()</code> 会在组件挂载后调用。因此，可以在该方法中执行依赖于 DOM 节点的初始化，如发起请求获取初始数据。</p><p>如果组件实例需要订阅消息，可以在该方法中进行订阅，但是要注意，最好在 <code>componentWillUnmount()</code> 中取消订阅，否则容易造成意料之外的错误或性能问题。</p><p>如果直接在 <code>componentDidMount()</code> 中调用 <code>setState()</code>，那么将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前，从而保证了即使调用两次 <code>render()</code>，用户也不会看到中间状态。但是需要谨慎使用该模式，因为它会容易导致性能问题。</p><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a>componentDidUpdate()</h3><p><code>componentDidUpdate()</code> 方法会在组件更新后会被立即调用，因此首次渲染不会执行此方法。</p><p>该方法接收三个参数：更新前的 <code>props</code> 属性、更新前的状态，与预提交阶段生命周期钩子的返回值。</p><p>当组件更新后，可以在此处对 DOM 进行操作，或者进行额外的网络请求。</p><p>可以在该方法中调用 <code>setState()</code>，但是请将其包裹在条件语句中，否则会导致死循环。同时，请谨慎使用，否则容易影响组件性能。</p><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h3><p><code>componentWillUnmount()</code> 方法将在组件卸载前调用。在此方法中需要执行必要的清理操作，如取消在 <code>componentDidMount()</code> 中创建的订阅。</p><h2 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h2><h3 id="static-getDerivedStateFromError"><a href="#static-getDerivedStateFromError" class="headerlink" title="static getDerivedStateFromError()"></a>static getDerivedStateFromError()</h3><p><code>getDerivedStateFromError()</code> 方法会在<strong>子元素</strong>抛出错误时调用。该方法接收抛出的错误作为参数，并返回一个对象用于更新当前组件的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class LifeCycleDemo extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            hasError: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static getDerivedStateFromError(error) &#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">        // Error: Error!</span><br><span class="line">        return &#123;</span><br><span class="line">            hasError: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    this.state.hasError ? &lt;div&gt;Something is wrong.&lt;/div&gt; : &lt;Son/&gt;</span><br><span class="line">                    // 页面显示 Something is wrong.</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        throw new Error(&#x27;Error!&#x27;)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                My name is Yucohny.</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码，由于子组件抛出了错误，因此父组件调用了 <code>getDerivedStateFromError()</code> 方法，并将状态中的属性 <code>hasError</code> 更新为了 <code>true</code>。</p><p>需要注意，该方法在渲染阶段调用。</p><h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch()"></a>componentDidCatch()</h3><p><code>componentDidCatch()</code> 方法会在子元素抛出错误时调用。该方法接收顺序接收两个参数：</p><ol><li>抛出的错误；</li><li>带有 <code>componentStack</code> 键的对象。</li></ol><p><code>componentDidCatch()</code> 会在提交阶段被调用，而 <code>getDerivedStateFromError()</code> 是在渲染阶段调用，因此如果子元素抛出错误，会先调用 <code>getDerivedStateFromError()</code> 方法，再调用 <code>componentDidCatch()</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">class LifeCycleDemo extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            hasError: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static getDerivedStateFromError(error) &#123;</span><br><span class="line">        console.log(`getDerivedStateFromError()`)</span><br><span class="line">        return &#123;</span><br><span class="line">            hasError: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">        console.log(`componentDidCatch()`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // getDerivedStateFromError()</span><br><span class="line">    // componentDidCatch()</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    this.state.hasError ? &lt;div&gt;Something is wrong.&lt;/div&gt; : &lt;Son/&gt;</span><br><span class="line">                    // 页面显示 Something is wrong.</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        throw new Error(&#x27;Error!&#x27;)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                My name is Yucohny.</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default LifeCycleDemo</span><br></pre></td></tr></table></figure><h2 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="forceUpdate()"></a>forceUpdate()</h2><p>默认情况下，只有当 <code>props</code> 属性与状态发生改变时才会触发组件的重新渲染。但是如果重新渲染同时依赖于其他数据，可以使用 <code>forceUpdate()</code> 方法进行强制重新渲染。</p><p>调用 <code>forceUpdate()</code> 的组件将会跳过 <code>shouldComponentUpdate()</code> 钩子，但是其子组件将会触发正常的生命周期钩子，包括 <code>shouldComponentUpdate()</code>。</p><h1 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h1><h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><p>在 HTML 中，像 input、textarea 这样的表单标签，通常会根据用户的输入来进行更新。即，不同时候使用 value 属性会得到当前状态下用户<strong>直接输入</strong>的值。</p><p>在 React 中，类似的可变状态通常保存在组件的 state 属性中，并且只能通过使用 setState() 来更新。</p><p>将两者结合起来，使 React 的 state 成为「唯一数据源」，这就是“受控组件”。受控组件不仅控制着用户输入过程中表单的事件（比如 input 标签的值修改时触发事件），还控制着取值的表单输入元素。</p><p>我们将原本的 input 标签，与受控组件式的标签进行对比。</p><p>原本的 input 标签形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">&quot;ipt&quot;</span> type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;...&quot;</span>/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>每次我们改变 input 标签中的值，input 标签的 value 属性总是随着用户输入<strong>直接改变</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ipt&#x27;</span>).<span class="property">value</span>) <span class="comment">// 此处每次都会直接获取冰显示 input 标签中的值</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>受控组件式的标签：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">state = &#123;</span><br><span class="line"><span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line"><span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，我们发现，input 标签内的值有任何改变，都会通过给定的触发事件，直接传入 state 属性中。</p><p>button 标签想要打印当前 input 标签的内容，却不是直接从 input 标签中获取数据，而是从 state 属性中获取 input 标签的数据。</p><p>尽管在具体的数据上，打印的数据（即 state 属性）与 input 标签的数据是一样的，但是打印的数据来源却不是直接从 input 标签中获得，而是从 state 属性中获得。</p><p>这就使得 state 属性称为“唯一数据源”。</p><p>在此处，我们使用了 input 标签进行举例，但是其他的一些表单标签（如 textarea、select）也有类似的受控组件的用法，此处不做具体介绍。</p><h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>非受控组件就是通过手动操作 dom 的方式获取文本框的值，文本框的状态不受 react 组件的 state 中的状态控制，直接通过原生 dom 获取输入框的值</p><h1 id="PubSub"><a href="#PubSub" class="headerlink" title="PubSub"></a>PubSub</h1><p>消息订阅-发布机制</p><ul><li>  工具库：<code>PubSubJS</code></li><li>  下载：<code>npm install pubsub-js --save</code></li></ul><h2 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a>订阅消息</h2><p><code>subscribe</code> 方法接受两个参数</p><ul><li>  字符串： 消息名称（自定义）</li><li>  回调函数： 当第一个参数的消息被 <code>publish</code> 时执行</li></ul><p>该回调函数必须接收两个参数<code>message</code>和<code>data</code>，<code>msg</code>参数即该回调函数触发时所对应的消息内容，<code>data</code>即订阅最后得到的消息内容。</p><p>该方法会返回一个<code>token</code>，用于指定特定的订阅。</p><blockquote><p>此处要注意一个点——应该在何处进行订阅。</p><p>我们当然可以设置单独的事件来进行订阅消息，但是如果是一开始就需要订阅某个消息的情况，我们应该在生命周期钩子<code>componentDidMount</code>内订阅消息。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import ...</span><br><span class="line">export default class Tom extends React.Component &#123;</span><br><span class="line">    add = () =&gt; &#123;</span><br><span class="line">        const &#123;value&#125; = this.keyWordEle</span><br><span class="line">        PubSub.publish(&#x27;add&#x27;, value)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;input ref=&#123;c =&gt; this.keyWordEle = c&#125; type=&#x27;text&#x27;/&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.add&#125;&gt;Add&lt;/button&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default class Jerry extends React.Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        list: []</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        PubSub.subscribe(&#x27;add&#x27;, (msg, data) =&gt; &#123;</span><br><span class="line">            const &#123;list&#125; = this.state</span><br><span class="line">            list.push(data)</span><br><span class="line">            this.setState(&#123;list: list&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123;list&#125; = this.state</span><br><span class="line">        return (</span><br><span class="line">            list.map(value =&gt; &#123;</span><br><span class="line">                return &lt;div&gt;value&lt;/div&gt;</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h2><p><code>unsubscribe</code> 方法</p><ul><li>  当参数为一个回调函数时，取消绑定该回调函数的所有订阅。</li><li>  当参数为一个字符串是时，取消绑定该消息的所有订阅。</li><li>  当参数为一个<code>token</code>时，取消该<code>token</code>对应的订阅。</li></ul><p><code>clearAllSubscriptions</code>方法，取消所有订阅。</p><h2 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h2><p><code>publish</code> 方法（异步发送消息）</p><p><code>publishSync</code> （同步发送消息）</p><ul><li>  第一个参数为字符串，信息名称。</li><li>  第二个参数即要发布的消息的数据。</li></ul><h2 id="兄弟组件之间传递数据"><a href="#兄弟组件之间传递数据" class="headerlink" title="兄弟组件之间传递数据"></a>兄弟组件之间传递数据</h2><p>我们当然可以将数据传递给父组件，父组件再传递给另一个兄弟组件，但这样会造成代码大量冗长，而使用<code>PubSubJS</code>工具库就可以让整个实现变得更加清晰。</p><p>假设当前需要在<code>Tom</code>组件中发布消息到<code>Jerry</code>组件中展示，利用<code>PubSub</code>模块可以更加轻松实现。</p><h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><h2 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy"></a>React.lazy</h2><p>React.lazy 可以让我们像渲染常规组件一样处理动态引入。</p><p>使用之前：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Demo from &#x27;./src&#x27;</span><br></pre></td></tr></table></figure><p>使用之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Demo = React.lazy(() =&gt; import(&#x27;./src&#x27;))</span><br></pre></td></tr></table></figure><p>这个代码会在组件首次渲染时，自动导入 Demo 组件。</p><p>React.lazy() 接收一个函数，表面这个函数需要动态调用 import()。它返回一个 Promise 对象，这个 Promise 需要 resolve 一个默认导出 default export 的 React 组件。</p><p>然后我们应该在 Suspense 组件中渲染 lazy 组件，这样可以帮助我们在等待加载 lazy 组件时做优雅降级（如 loading 指示器等等）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Demo</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./src&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于路由的代码分割"><a href="#基于路由的代码分割" class="headerlink" title="基于路由的代码分割"></a>基于路由的代码分割</h2><p>决定在哪引入代码分割需要一些技巧。你需要确保选择的位置能够均匀地分割代码包而不会影响用户体验。</p><p>一个不错的选择是从路由开始。大多数网络用户习惯于页面之间能有个加载切换过程。你也可以选择重新渲染整个页面，这样您的用户就不必在渲染的同时再和页面上的其他元素进行交互。</p><p>下面的例子展示了如何使用 React.lazy 和 React-Router 来配置基于路由的代码分割：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Suspense, lazy &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">const Home = lazy(() =&gt; import(&#x27;./routes/Home&#x27;));</span><br><span class="line">const About = lazy(() =&gt; import(&#x27;./routes/About&#x27;));</span><br><span class="line"></span><br><span class="line">const App = () =&gt; (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="Context-机制"><a href="#Context-机制" class="headerlink" title="Context 机制"></a>Context 机制</h1><p>如果需要将数据从祖先组件传递到子孙组件，通常需要通过 props 层层传递</p><p>Context 提供了一个无需为每层组件手动添加 <code>props</code>，就能在组件之间进行数据传递的方法：</p><p>Context 主要应用场景是 <strong>很多不同层级的组件需要访问同样一些的数据</strong>。由于 Context 的使用会使得组件复用性变差，因此需要谨慎使用。</p><h2 id="Context-对象"><a href="#Context-对象" class="headerlink" title="Context 对象"></a>Context 对象</h2><p><code>React.createContext()</code> 方法可以创建一个 Context 对象。该方法接收一个参数作为 Context 对象默认值，并返回创建的 Context 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">const context = React.createContext(&#x27;light&#x27;)</span><br><span class="line"></span><br><span class="line">class ContextClassDemo extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(context)</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                This is Context Demo.</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default ContextClassDemo</span><br></pre></td></tr></table></figure><p><img src="https://blog.yucohny.vercel.app/images/react/1.png" alt="img"></p><p>打印 Context 对象发现，Context 对象中的属性包含一个 React Provider 组件与一个 React Consumer 组件。</p><h2 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a>Context.Provider</h2><p>Provider 组件接收一个参数 <code>value</code>，并将其传递给消费组件</p><p>一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ContextClassDemo extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;context.Provider value=&#123;&#x27;dark&#x27;&#125;&gt;</span><br><span class="line">                &lt;context.Provider value=&#123;&#x27;medium&#x27;&#125;&gt;</span><br><span class="line">                    &lt;Son/&gt;</span><br><span class="line">                &lt;/context.Provider&gt;</span><br><span class="line">            &lt;/context.Provider&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 显示 The theme is medium.</span><br></pre></td></tr></table></figure><p>如果没有找到合法的 Provider 组件，将会使用 Context 默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ContextClassDemo extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Son/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 显示 The theme is light.</span><br></pre></td></tr></table></figure><p><strong>当 Provider 组件的 <code>value</code> 属性发生变化时，其内部的所有消费组件都会重新渲染。</strong></p><h2 id="class-contextType"><a href="#class-contextType" class="headerlink" title="class.contextType"></a>class.contextType</h2><p>当某个 <strong>类式组件</strong> 想要使用某个 Context 对象时，可以在组件类上中挂载 <code>contextType</code> 属性，并将其指定为对应的 Context 对象后，便能在组件中通过 <code>this.context</code> 访问该 Context 对象在此处的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">const context = React.createContext(&#x27;light&#x27;)</span><br><span class="line"></span><br><span class="line">class ContextClassDemo extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Son/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 显示 The theme is light.</span><br><span class="line"></span><br><span class="line">class Son extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const value = this.context</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                The theme is &#123;value&#125;.</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.contextType = context</span><br><span class="line"></span><br><span class="line">export default ContextClassDemo</span><br></pre></td></tr></table></figure><p>使用实验性的 <a href="https://github.com/tc39/proposal-class-public-fields">Public Class Fields</a> 语法可以更加方便进行初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Son extends React.Component &#123;</span><br><span class="line">    static contextType = context</span><br><span class="line">    render() &#123;</span><br><span class="line">        const value = this.context</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                The theme is &#123;value&#125;.</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>指定 <code>contextType</code> 属性是类式组件使用 Context 对象的方式，如果想要在函数式组件中使用 Context 对象，需要使用 <code>useContext()</code> 钩子。</p><p><code>useContext()</code> 接收一个 Context 对象，返回该 Context 对象在此处的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Son = () =&gt; &#123;</span><br><span class="line">    const value = useContext(context)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            The theme is &#123;value&#125;.</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a>Context.Consumer</h2><p>一个 React 组件可以订阅 context 的变更，此组件可以让你在函数式组件中可以订阅 context。</p><p>Consumer 组件的子元素是一个函数，传递给函数的 <code>value</code> 值等价于组件树上方离这个 context 最近的 Provider 提供的 <code>value</code> 值。如果没有对应的 Provider，<code>value</code> 参数等同于传递给 <code>createContext()</code> 的 <code>defaultValue</code>。该函数最终返回一个 React 组件，即最终渲染的组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class ContextClassDemo extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;context.Provider value=&#123;&#x27;dark&#x27;&#125;&gt;</span><br><span class="line">                &lt;context.Consumer&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        value =&gt; &#123;</span><br><span class="line">                            return (</span><br><span class="line">                             &#123;value&#125;</span><br><span class="line">                            )</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &lt;/context.Consumer&gt;</span><br><span class="line">            &lt;/context.Provider&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-DevTools-中展示"><a href="#在-DevTools-中展示" class="headerlink" title="在 DevTools 中展示"></a>在 DevTools 中展示</h2><p>运行代码后，打开 DevTools 中的 Components，可以看到如下的组件关系：</p><p><img src="https://blog.yucohny.vercel.app/images/react/2.png" alt="img"></p><p>在 Context 对象上挂载 <code>displayName</code> 字符串，该字符串为在 DevTools 中展示的 Context 对象名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const context = React.createContext(&#x27;light&#x27;)</span><br><span class="line"></span><br><span class="line">context.displayName = &#x27;theme&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://blog.yucohny.vercel.app/images/react/3.png" alt="img"></p><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>如果一个函数符合下面<code>2</code>个规范中的任何一个，那么该函数就可以称为高阶函数。</p><ul><li>  若<code>A</code>函数，接受的参数是一个函数，那么<code>A</code>就可以称之为高阶函数。</li><li>  若<code>A</code>函数，返回值依然是一个函数，那么<code>A</code>就可以称之为高阶函数。</li></ul><h2 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a>函数的柯里化</h2><p>通过函数调用继续返回函数的方式，实现多次接受参数最后统一处理的函数编码形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h1 id="Refs-转发"><a href="#Refs-转发" class="headerlink" title="Refs 转发"></a>Refs 转发</h1><h2 id="React-forwardRef"><a href="#React-forwardRef" class="headerlink" title="React.forwardRef()"></a>React.forwardRef()</h2><p>考虑下面 <code>Demo</code> 组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;input/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当其他组件调用 <code>Demo</code> 组件时，通常并不需要能够单独操控 <code>Demo</code> 组件中的 <code>input</code> 元素；但是当需要进行管理焦点等操作时，仍然需要 <strong>能够</strong> 访问 <code>Demo</code> 组件的 <code>input</code> 元素。</p><p>Refs 转发就是将 ref 传递到子组件的技巧。</p><p>如果一个组件可能要接收其父组件传递而来的 ref 对象，那么可以使用 <code>React.forwardRef()</code> 进行包装。</p><p><code>React.forwardRef()</code> 接收一个渲染函数作为参数，并最终返回一个组件。这个渲染函数接收的两个参数分别为 props 和 ref 对象，此时可以将接收到的 ref 对象挂载至子组件上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const Demo = React.forwardRef((props, ref) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;input ref=&#123;ref&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    inputRef = React.createRef()</span><br><span class="line"></span><br><span class="line">    handleClick = () =&gt; &#123;</span><br><span class="line">        console.log(this.inputRef.current.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Demo ref=&#123;this.inputRef&#125;/&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">                    Click me.</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-DevTools-中显示自定义名称"><a href="#在-DevTools-中显示自定义名称" class="headerlink" title="在 DevTools 中显示自定义名称"></a>在 DevTools 中显示自定义名称</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const Demo = React.forwardRef((props, ref) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;input ref=&#123;ref&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    inputRef = React.createRef()</span><br><span class="line"></span><br><span class="line">    handleClick = () =&gt; &#123;</span><br><span class="line">        console.log(this.inputRef.current.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Demo ref=&#123;this.inputRef&#125;/&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">                    Click me.</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们执行上面的代码时，打开 DevTools，可以看到开发者工具中的 ref 名称默认为 <code>ForwardRef</code>：</p><p><img src="https://blog.yucohny.vercel.app/images/react/4.png" alt="img"></p><p>如果命名 <code>React.forwardRef</code> 接收的渲染函数，那将会显示对应的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const DemoRef = (props, ref) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;input ref=&#123;ref&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Demo = React.forwardRef(DemoRef)</span><br></pre></td></tr></table></figure><p><img src="https://blog.yucohny.vercel.app/images/react/5.png" alt="img"></p><p>除此之外，也可以设置渲染函数的 <code>displayName</code> 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const DemoRef = (props, ref) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;input ref=&#123;ref&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DemoRef.displayName = &#x27;myName&#x27;</span><br><span class="line"></span><br><span class="line">const Demo = React.forwardRef(DemoRef)</span><br></pre></td></tr></table></figure><p><img src="https://blog.yucohny.vercel.app/images/react/6.png" alt="img"></p><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>与 <code>React.createRef</code> 类似，<code>useRef</code> 返回一个可变的 ref 对象，它的 <code>current</code> 属性将被初始化为传入 <code>useRef</code> 钩子的参数。不过，<code>React.createRef</code> 生成的 ref 对象不能用于函数式组件，而 <code>useRef</code> 可以。</p><p>我们可以将生成的这个 ref 对象挂载至 DOM 或 React 元素的 <code>ref</code> 属性中，那么此时 ref 对象的 <code>current</code> 属性将被替换为对应的 DOM 或 React 元素。</p><h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><p>React 组件是通过 <code>props</code> 属性将其转化为 UI；高阶组件则是将一个组件转化为另一个组件，因此，可以将高阶组件视为 <strong>传入组件作为参数，并返回一个组件的函数</strong>。</p><p>具体而言，<strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">const HOC = (WrappedComponent) =&gt; (</span><br><span class="line">    class toSize extends React.Component &#123;</span><br><span class="line">        state = &#123;</span><br><span class="line">            xpos: document.documentElement.clientWidth,</span><br><span class="line">            ypos: document.documentElement.clientHeight</span><br><span class="line">        &#125;</span><br><span class="line">        getPos = () =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                xpos: document.documentElement.clientWidth,</span><br><span class="line">                ypos: document.documentElement.clientHeight</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount () &#123;</span><br><span class="line">            window.addEventListener(&#x27;resize&#x27;, this.getPos)</span><br><span class="line">        &#125;</span><br><span class="line">        render () &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;WrappedComponent &#123;...this.state&#125; /&gt;</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const Son = (props) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;button&gt;x: &#123;props.xpos&#125;, y: &#123;props.ypos&#125;&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">const Foo = (props) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;h1&gt;x: &#123;props.xpos&#125;, y: &#123;props.ypos&#125;&lt;/h1&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const SonSize = HOC(Son)</span><br><span class="line">const FooSize = HOC(Foo)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;SonSize /&gt;</span><br><span class="line">                &lt;FooSize /&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default App</span><br></pre></td></tr></table></figure><p>上面这个例子，通过高阶组件 HOC ，返回了一个新的组件 toSize， 在这个组件里面我们定义了 Foo 和 Son 一些共有的特性，最后将 传入的对应组件 通过 toSize 组件渲染</p><h1 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h1><p>通常来讲，当从组件的 <code>render</code> 方法返回一个元素时，该元素将被挂载到离它最近的父节点中。</p><p>但是如果我们想要自定义插入元素位置时，就可以使用 <code>Portal</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.createPortal(child, container)</span><br></pre></td></tr></table></figure><p>第一个参数 child 是任何 <a href="https://react.docschina.org/docs/react-component.html#render">可渲染的 React 子元素</a>，例如一个元素，字符串，甚至是 <code>fragment</code>。</p><p>第二个参数 container 是一个 DOM 元素。</p><p>一个 <code>portal</code> 的典型用例是当父组件有 <code>overflow: hidden</code> 或 <code>z-index</code> 样式时，但你需要子组件能够在视觉上“跳出”其容器。</p><h2 id="通过-Portal-进行事件冒泡"><a href="#通过-Portal-进行事件冒泡" class="headerlink" title="通过 Portal 进行事件冒泡"></a>通过 Portal 进行事件冒泡</h2><p>尽管我们可以将 <code>portal</code> 放置在 DOM 树中的任何地方，但在任何其他方面，其行为和普通的 React 子节点行为一致。由于 <code>portal</code> 仍存在于 React 树， 且与 DOM 树中的位置无关，那么无论其子节点是否是 <code>portal</code>，像 <code>context</code> 这样的功能特性都是不变的。</p><p>这包含事件冒泡。一个从 portal 内部触发的事件会一直冒泡至 React 树的祖先，即便这些元素并不是 DOM 树中的祖先。</p><h1 id="Profiler"><a href="#Profiler" class="headerlink" title="Profiler"></a>Profiler</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Profiler 能添加在 React 树中 的任何地方来测量渲染树中的这部分所需要的开销。</p><p>改组件接收两个属性：</p><ul><li>  id: string</li><li>  onRender: callback()</li></ul><blockquote><p>onRender 是当组件树种的组件「提交」更新时调用的回调函数。</p></blockquote><p>举个例子，我们想要分析 Navigation 组件树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;App&gt;</span><br><span class="line">    &lt;Profiler id=&quot;Navigation&quot; onRender=&#123;callback&#125;&gt;      &lt;Navigation &#123;...props&#125; /&gt;</span><br><span class="line">    &lt;/Profiler&gt;</span><br><span class="line">    &lt;Main &#123;...props&#125; /&gt;</span><br><span class="line">  &lt;/App&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>多个 Profiler 组件能测量应用中的不同部分。</li><li>可以嵌套使用 Profiler 进行检测。</li></ol></blockquote><h2 id="onRender-回调"><a href="#onRender-回调" class="headerlink" title="onRender 回调"></a>onRender 回调</h2><p>该回调函数接收的参数描述了渲染的内容以及所花费的时间：</p><ul><li>  id：发生提交的树（或者说对应节点）的 id</li></ul><blockquote><p>id 可用于分辨是树的哪一部分发生了「提交」。</p></blockquote><ul><li>  phase：如果组件树该加载，则值为 mount；如果组件树重新渲染了，则值为 update。</li></ul><blockquote><p>判断是组件树的第一次装载引起的重渲染，还是由 props、state 或是 hooks 改变引起的重渲染。</p></blockquote><ul><li>  actualDuration：本次更新花费的渲染时间</li></ul><blockquote><p>本次更新在渲染 Profiler 和它的子代上花费的时间。 这个数值表明使用 memoization 之后能表现得多好。理想情况下，由于子代只会因特定的 prop 改变而重渲染，因此这个值应该在第一次装载之后显著下降。</p></blockquote><ul><li>  baseDuration：估计不使用 memoization 的情况下渲染整颗子树需要的时间</li></ul><blockquote><p>在 Profiler 树中最近一次每一个组件 render 的持续时间。 这个值估计了最差的渲染时间。（例如当它是第一次加载或者组件树没有使用 memoization）。</p></blockquote><ul><li>  startTime：本次更新中 React 开始渲染的时间</li></ul><blockquote><p>本次更新中 React 开始渲染的时间戳。</p></blockquote><ul><li>  commitTime：本次更新中 React committed 的时间</li></ul><blockquote><p>本次更新中 React commit 阶段结束的时间戳。 在一次 commit 中这个值在所有的 profiler 之间是共享的，可以将它们按需分组。</p></blockquote><ul><li>  interactions：属于本次更新的 interactions 的集合</li></ul><blockquote><p>该参数为集合类型。当更新被制定时，interactions 的集合会被追踪（例如当 render 或者 setState 被调用时）。</p><p>Interactions 能用来识别更新是由什么引起的。</p></blockquote><h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h1><p>Hooks 的本质：<strong>一套能够使函数组件更强大，更灵活的“钩子”</strong></p><p>可以让函数组件使用 state 以及其他 React 特性。由于 JavaScript 中原本没有 class 的概念，因而 Hook 的存在正促使开发者从类式组件向函数式组件进行转变。</p><p>Hook 是一些可以让你在 <strong>函数组件</strong> 中使用 React state 特性以及生命周期等特性的函数。</p><p>Hook 基本的使用规则如下：</p><ul><li>  只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。</li><li>  只能在 React 的函数组件或者其他 Hook 组件中调用 Hook，而不要在其他的 JS 函数中调用。</li><li>  可以通过开发者工具查看 hooks 状态</li></ul><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>在 Hook 出现之前，由于函数式组件中并不存在 state 特性，因而更多使用类式组件。但是 Hook 的出现使得函数式组件同样可以使用 state 特性，并且在函数式组件中通过 Hook 使用 state 特性，比类式组件中使用 state 特性更加便捷。</p><ul><li>  引入 state</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>  声明 state</li></ul><p><code>useState()</code> 是声明新 state 的钩子，接收一个参数，作为该 state 的初始值；返回一个数组，这个数组的第一个元素是 state 变量，第二个元素是修改该 state 的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">function Demo() &#123;</span><br><span class="line">    const [count, setCount] = useState(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  读取 state</li></ul><p>直接使用声明的 state 变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt; You clicked &#123; count &#125; times.&lt;/p&gt;</span><br></pre></td></tr></table></figure><ul><li>  更新 state</li></ul><p><code>useState()</code> 返回的数组中的第二个元素是更新 state 的方法。这个方法接收一个参数，作为该 state 的新值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">function Demo() &#123;</span><br><span class="line">    const [count, setCount] = useState(0)</span><br><span class="line"></span><br><span class="line">    const click = () =&gt; &#123;</span><br><span class="line">        setCount(count + 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="替换而不是合并"><a href="#替换而不是合并" class="headerlink" title="替换而不是合并"></a>替换而不是合并</h3><p>使用 <code>useState</code> 更新函数式组件中的状态时，如果状态是一个对象，那么新状态将会是新对象，而不是将旧对象与新对象合并。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>可以简单将 <code>useEffect</code> 视为 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个生命周期的组合。</p><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>副作用是相对于主作用来说的，一个函数除了主作用，其他的作用就是副作用。对于 React 组件来说，<strong>主作用就是根据数据（state/props）渲染 UI</strong>，除此之外都是副作用（比如，手动修改 DOM）</p><p><strong>常见的副作用</strong></p><ol><li>数据请求 ajax 发送</li><li>手动修改 dom</li><li>localstorage 操作</li></ol><p>useEffect 函数的作用就是为 react 函数组件提供副作用处理的！</p><ul><li>  引入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useEffect &#125; from &#x27;react&#x27;</span><br></pre></td></tr></table></figure><ul><li>  使用</li></ul><p><code>useEffect</code> 接受两个参数，一个是依赖项触发时的回调函数，一个是依赖项</p><p><strong>不添加依赖项</strong></p><ul><li>  组件首次渲染、以及不管是哪个状态引起组件的更新都会执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;副作用执行了&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>添加空数组</strong></p><ul><li>  只在首次渲染时执行一次</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line"> console.log(&#x27;副作用执行了&#x27;)</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p><strong>添加特定依赖项</strong></p><ul><li>  副作用函数在首次渲染、依赖项发生变化时都会重新执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">    const [count, setCount] = useState(0)</span><br><span class="line">    const [name, setName] = useState(&#x27;zs&#x27;)</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;副作用执行了&#x27;)</span><br><span class="line">    &#125;, [count])</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">         &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;&#123;count&#125;&lt;/button&gt;</span><br><span class="line">         &lt;button onClick=&#123;() =&gt; &#123; setName(&#x27;cp&#x27;) &#125;&#125;&gt;&#123;name&#125;&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清理副作用"><a href="#清理副作用" class="headerlink" title="清理副作用"></a>清理副作用</h3><p>如果想要清理副作用 可以在副作用函数中的末尾 return 一个新的函数，在新的函数中编写清理副作用的逻辑</p><p>注意执行时机为：</p><ol><li>组件卸载时自动执行</li><li>组件更新时，下一个 useEffect 副作用函数执行之前自动执行</li></ol><h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><ul><li>  useEffect 是异步执行的，而 useLayoutEffect 是同步执行的</li><li>  useEffect 在浏览器完成渲染之后执行，而 useLayoutEffect 在浏览器把内容真正渲染到界面之前执行</li><li>  useLayoutEffect 可以用来读取或修改 DOM 的布局，并同步重新渲染</li><li>  useLayoutEffect 会阻塞浏览器的重绘，所以应该尽量避免使用它，除非有特殊需求</li></ul><p>一般来说，你应该优先使用 useEffect，因为它不会影响浏览器的性能和用户体验。只有当你需要在渲染之前读取或修改 DOM 的布局，并且不能用其他方式实现的时候，才考虑使用 useLayoutEffect。例如，如果你需要根据 DOM 的尺寸或位置来调整样式或动画，那么你可能需要用 useLayoutEffect。</p><h2 id="useRef-1"><a href="#useRef-1" class="headerlink" title="useRef"></a>useRef</h2><p>与 <code>React.createRef</code> 类似，<code>useRef</code> 返回一个可变的 ref 对象，它的 <code>current</code> 属性将被初始化为传入 <code>useRef</code> 钩子的参数。不过，<code>React.createRef</code> 生成的 ref 对象不能用于函数式组件，而 <code>useRef</code> 可以。</p><p>我们可以将生成的这个 ref 对象挂载至 DOM 或 React 元素的 <code>ref</code> 属性中，那么此时 ref 对象的 <code>current</code> 属性将被替换为对应的 DOM 或 React 元素。</p><h2 id="useContext-1"><a href="#useContext-1" class="headerlink" title="useContext"></a>useContext</h2><p>指定 <code>contextType</code> 属性是类式组件使用 Context 对象的方式，如果想要在函数式组件中使用 Context 对象，需要使用 <code>useContext()</code> 钩子。</p><p><code>useContext()</code> 接收一个 Context 对象，返回该 Context 对象在此处的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Son = () =&gt; &#123;</span><br><span class="line">    const value = useContext(context)</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            The theme is &#123;value&#125;.</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>useMemo 是一个 React Hook，它可以让你在重新渲染之间缓存一个计算的结果]这样可以避免每次渲染时都进行昂贵的计算。useMemo 接受两个参数：一个是用于计算结果的函数，另一个是依赖数组。当依赖数组中的任何一个值发生变化时，useMemo 会重新执行函数并缓存新的结果</p><p>useMemo 和 useCallback 的区别是，useMemo 返回一个缓存的值，而 useCallback 返回一个缓存的函数</p><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>useCallback 是一个 React Hook，它可以让你在重新渲染之间缓存一个函数的引用。这样可以避免每次渲染时都创建一个新的函数。useCallback 接受两个参数：一个是需要缓存的函数，另一个是依赖数组。当依赖数组中的任何一个值发生变化时，useCallback 会返回一个新的函数引用。</p><p>useCallback 的主要目的是在于配合子组件的 shouldComponentUpdate 或者 React.memo 来减少不必要的渲染。如果你把一个内联函数作为回调传递给子组件，那么每次父组件渲染时，子组件都会认</p><p>useCallback 可以用于优化传递给子组件的函数属性的性能。例如，如果你有一个 handleSubmit 函数，它需要传递给 ShippingForm 组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ProductPage</span>(<span class="params">&#123; productId, referrer, theme &#125;</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleSubmit</span>(<span class="params">address</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;theme&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* ... */&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ShippingForm</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，每次 ProductPage 渲染时，都会创建一个新的 handleSubmit 函数，并且导致 ShippingForm 也重新渲染。但是如果你用 useCallback 缓存了 handleSubmit 函数，并且把 productId 和 referrer 作为依赖数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ProductPage</span>(<span class="params">&#123; productId, referrer, theme &#125;</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> handleSubmit = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(</span><br><span class="line"><span class="function">(<span class="params">address</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br><span class="line">[productId, referrer]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;theme&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* ... */&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ShippingForm</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，只有当 productId 或 referrer 发生变化时，才会创建一个新的 handleSubmit 函数，并且导致 ShippingForm 重新渲染。否则，useCallback 会返回上次缓存的函数引用。</p><h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h1><blockquote><p>基于 React-Router v6</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h3><p>SPA Single Page Application 单页面 Web 应用，整个页面只有一个完整的页面。点击页面中的链接不会刷新页面，只会做页面的局部更新。</p><h3 id="React-Router-1"><a href="#React-Router-1" class="headerlink" title="React Router"></a>React Router</h3><p>React Router 以三个不同的包发布在 npm：</p><ol><li>react-router：路由的核心库，提供了许多的组件与钩子。</li><li>react-router-dom：包含 react-router 的所有内容，并添加了一些专门用于 DOM 的组件，如 <code>&lt;BrowserRouter&gt;</code> 等等。</li><li>react-router-native：包含 react-router 的所有内容，并添加了一些专门用于 ReactNative 的 API，如 <code>&lt;NativeRouter&gt;</code> 等等。</li></ol><p>React Router 这一部分的笔记着重介绍 react-router-dom 的相关知识。</p><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom</span><br></pre></td></tr></table></figure><h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="路由链接"><a href="#路由链接" class="headerlink" title="路由链接"></a>路由链接</h3><p>我们使用 <code>&lt;Link&gt;</code> 或者 <code>&lt;NavLink&gt;</code> 标签实现路由的跳转，其中的 <code>to</code> 属性指向的即为对应的路由连接，其余用法与原本的锚点标签 <code>&lt;a&gt;</code> 相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;Link&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">export default function Demo() &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;Link to=&#x27;/home&#x27;&gt;Home&lt;/Link&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NavLink</strong></p><p>如果想要在 <code>&lt;Link&gt;</code> 标签被选中时具有对应的高亮效果，可以考虑使用 <code>&lt;NavLink&gt;</code> 标签。<code>NavLink</code> 有一个属性 <code>activeClassName</code> ，用来表示当该链接被点击时追加的一个类。基于这个属性，我们便可以实现点击某个路由链接时，该路由链接获得对应的效果。</p><p>当有多个路由链接对应不同组件时，如果使用多个 <code>NavLink</code> 标签，会造成代码的大量冗长重复。因此我们可以考虑自己封装 <code>NavLink</code> 标签，只需要指定 <code>NavLink</code> 标签的不同之处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;NavLink&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">export default function MyNavLink() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;NavLink activeClassName=&quot;active&quot; className=&quot;navlink&quot; &#123;...this.props&#125;&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们只需要像这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;MyNavLink&#125; from &#x27;...&#x27;</span><br><span class="line"></span><br><span class="line">export default function Demo() &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;MyNavLink to=&#x27;/home&#x27;&gt;Home&lt;/MyNavLink&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BrowerRouter"><a href="#BrowerRouter" class="headerlink" title="BrowerRouter"></a><strong>BrowerRouter</strong></h3><p>作用: 包裹整个应用，一个 React 应用只需要使用一次</p><table><thead><tr><th><strong>模式</strong></th><th><strong>实现方式</strong></th><th><strong>路由 url 表现</strong></th></tr></thead><tbody><tr><td>HashRouter</td><td>监听 url hash 值实现</td><td><a href="http://localhost:3000/#/about">http://localhost:3000/#/about</a></td></tr><tr><td>BrowerRouter</td><td>h5 的 history.pushState API 实现</td><td><a href="http://localhost:3000/about">http://localhost:3000/about</a></td></tr></tbody></table><p>编写路由链接和注册路由对应的标签 <code>&lt;Link&gt;</code>、<code>&lt;NavLink&gt;</code> 与 <code>&lt;Route&gt;</code> 都需要在外部包裹一个 <code>&lt;BrowserRouter&gt;</code> 或 <code>&lt;HashRouter&gt;</code> 标签，但是我们不能将其分开包裹，不然会造成路由失效。</p><p>其中的一个解决办法是，我们在渲染整个的大外壳组件 <code>&lt;App/&gt;</code> 时，就直接将其包裹在 <code>&lt;BrowserRouter&gt;</code> 或 <code>&lt;HashRouter&gt;</code> 标签内：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;App/&gt;</span><br><span class="line">    &lt;/BrowserRouter&gt;,</span><br><span class="line">    document.getElementById(&#x27;root&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h3><p>我们使用 <code>&lt;Routes/&gt;</code> 与 <code>&lt;Route&gt;</code> 标签注册路由。</p><p><code>&lt;Route&gt;</code> 标签均置于 <code>&lt;Routes&gt;</code> 标签内部，而 <code>&lt;Route&gt;</code> 标签接收两个属性：</p><ul><li>  <code>path</code> 属性，该属性接收一个路由，表示当前路由为该路由时，渲染 <code>element</code> 属性对应的组件。</li><li>  <code>element</code> 属性，该属性接收一个组件，表示渲染对应的组件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;Routes, Route&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">export default function Demo() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Routes&gt;</span><br><span class="line">            &lt;Route path=&#x27;/home&#x27; element=&#123;&lt;Home/&gt;&#125;/&gt;</span><br><span class="line">            &lt;Route path=&#x27;/school&#x27; element=&#123;&lt;School/&gt;&#125;/&gt;</span><br><span class="line">        &lt;/Routes&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Routes</code> 组件中，当成功匹配到第一个路由后，就不会再继续向下匹配。</p><p><code>Route</code> 组件可以接受一个属性 <code>caseSensitive</code>，用于指定匹配路由时是否区分大小写。默认为 <code>false</code>，即不区分大小写。</p><h3 id="useRoutes"><a href="#useRoutes" class="headerlink" title="useRoutes"></a>useRoutes</h3><p>考虑上面的示例代码，我们发现这些 <code>Route</code> 组件当中有大量重复冗余的内容，因此我们可以考虑使用 <code>useRoutes</code> 钩子来集中管理。</p><p>引入 <code>useRoutes</code> 后，<code>useRoutes</code> 接收一个数组作为参数，返回对应的路由组。参数数组的每个元素为一个对象，每个对象包含的属性即为 <code>Route</code> 组件包含的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;useRoutes&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">export default function Demo() &#123;</span><br><span class="line">    const elements = useRoutes([</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#x27;/home&#x27;,</span><br><span class="line">            element: &lt;Home/&gt;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#x27;/school&#x27;,</span><br><span class="line">            element: &lt;School/&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    ])</span><br><span class="line">    return (</span><br><span class="line">        elements</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个值得注意的地方是，我们的 <code>Demo</code> 组件实际上关心的更多是业务逻辑，路由的跳转并不是主要，因此我们可以考虑建立单独的 <code>route</code> 目录，建立路由表，将路由的管理移交出去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import Home from &#x27;...&#x27;</span><br><span class="line">import School from &#x27;...&#x27;</span><br><span class="line">......</span><br><span class="line">export default [</span><br><span class="line">&#123;</span><br><span class="line">    path: &#x27;/home&#x27;,</span><br><span class="line">        element: &lt;Home/&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &#x27;/school&#x27;,</span><br><span class="line">        element: &lt;School/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;useRoutes&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line">import routes from &#x27;...&#x27;</span><br><span class="line"></span><br><span class="line">export default function Demo() &#123;</span><br><span class="line">    const elements = useRoutes(routes)</span><br><span class="line">    return (</span><br><span class="line">        elements</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>当我们想要使用形如 <code>/home/me</code> 这样的嵌套路由时，可以为路由表中的 <code>children</code> 属性指定数组，表示嵌套路由对应的组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import Home from &#x27;...&#x27;</span><br><span class="line">import School from &#x27;...&#x27;</span><br><span class="line">......</span><br><span class="line">export default [</span><br><span class="line">&#123;</span><br><span class="line">    path: &#x27;/home&#x27;,</span><br><span class="line">        element: &lt;Home/&gt;,</span><br><span class="line">        children: [</span><br><span class="line">            &#123;</span><br><span class="line">                path: &#x27;me&#x27;,</span><br><span class="line">                element: &lt;Me/&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &#x27;/school&#x27;,</span><br><span class="line">        element: &lt;School/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>当我们的路由为 <code>/</code>，或者为我们并未直接指定对应的组件时，我们可以使用重定向来指定此时需要渲染的组件。</p><p>我们引入 <code>Navigate</code> 标签，并在 <code>Routes</code> 组件的最后添加一个 <code>Route</code> 组件，该组件的 <code>element</code> 属性指定为 <code>Navigate</code> 组件。<code>Navigate</code> 组件接收一个属性 <code>to</code>，表示重定向的路由。</p><p>如下列代码，当我们访问路由 <code>/</code> 时，无法在 <code>Routes</code> 组件中匹配到一个对应的组件，那么此时就会重定向至 <code>/home</code> 路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;Routes, Route, Navigate&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">export default function Demo() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Routes&gt;</span><br><span class="line">            &lt;Route path=&#x27;/home&#x27; element=&#123;&lt;Home/&gt;&#125;/&gt;</span><br><span class="line">            &lt;Route path=&#x27;/school&#x27; element=&#123;&lt;School/&gt;&#125;/&gt;</span><br><span class="line">            &lt;Route path=&#x27;/&#x27; element=&#123;&lt;Navigate to=&#x27;/home&#x27;/&gt;&#125;/&gt;</span><br><span class="line">        &lt;/Routes&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h2><h3 id="params"><a href="#params" class="headerlink" title="params"></a>params</h3><p>路由链接携带参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#x27;/demo/tom/18&#x27;&gt;详情&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>注册路由中声明接收参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&#x27;demo/:name/:age&#x27; element=&#123;&lt;Demo/&gt;&#125;/&gt;</span><br></pre></td></tr></table></figure><p>随后我们在对应的路由组件中，使用 <code>useParams</code> 钩子来接收参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;useParams&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">export default function Demo() &#123;</span><br><span class="line">    const params = useParams()</span><br><span class="line">    return (</span><br><span class="line">        ...</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>路由链接携带参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#x27;/demo?name=tom&amp;age=18&#x27;&gt;详情&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>正常注册路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&#x27;/demo&#x27; element=&#123;&lt;Demo/&gt;&#125;/&gt;</span><br></pre></td></tr></table></figure><p>随后我们在对应的路由组件中，使用 <code>useSearchParams</code> 钩子来接收参数。<code>useSearchParams</code> 返回一个数组，数组的第一个元素是 <code>search</code> 对象，我们可以通过 <code>get()</code> 方法来获取对应的参数；数组的第二个元素是一个函数，用于更新对应的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;useSearchParams&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">export default function Demo() &#123;</span><br><span class="line">    const [search, setSearch] = useSearchParams()</span><br><span class="line">    const name = search.get(&#x27;name&#x27;)</span><br><span class="line">    const age = search.get(&#x27;age&#x27;)</span><br><span class="line">    return (</span><br><span class="line">        ...</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="state-1"><a href="#state-1" class="headerlink" title="state"></a>state</h3><p>路由链接携带参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#x27;/demo&#x27; state=&#123;&#123;name: &#x27;tom&#x27;, age: 18&#125;&#125;&gt;详情&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>正常注册路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&#x27;/demo&#x27; element=&#123;&lt;Demo/&gt;&#125;/&gt;</span><br></pre></td></tr></table></figure><p>随后我们在对应的路由组件中，使用 <code>useLocation</code> 钩子来接收参数。<code>useLocation</code> 是一个对象，包含许多属性，其中的 <code>state</code> 属性包含了我们需要的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;useLocation&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">export default function Demo() &#123;</span><br><span class="line">    const &#123;state: &#123;name, age&#125;&#125; = useLocation()</span><br><span class="line">    return (</span><br><span class="line">        ...</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h2><p>在 React Router v6 中，我们借助 <code>useNavigate</code> 这个钩子实现编程式路由导航：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;useNavigate&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">export default function Demo() &#123;</span><br><span class="line">    const navigate = useNavigate()</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">    ...</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>useNavigate</code> 生成的 <code>navigate</code> 接收两个参数，第一个参数为需要跳转的路由，第二个参数为一个对象，这个对象可以接收 <code>replace</code> 与 <code>state</code> 两个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123;useNavigate&#125; from &#x27;react-router-dom&#x27;</span><br><span class="line"></span><br><span class="line">export default function Demo() &#123;</span><br><span class="line">    const navigate = useNavigate()</span><br><span class="line"></span><br><span class="line">    const handleNavigate = (obj) =&gt; &#123;</span><br><span class="line">        navigate(&#x27;/home&#x27;, &#123;</span><br><span class="line">            state: &#123;</span><br><span class="line">                name: obj.name,</span><br><span class="line">                age: obj.age</span><br><span class="line">            &#125;，</span><br><span class="line">            //对应的组件通过useLocation获取</span><br><span class="line">            replace: true //代表在跳转时不添加历史记录</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; &#123;handleNavigate(&#123;name: &#x27;tom&#x27;, age: 18&#125;)&#125;&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要通过 <code>navigate</code> 实现路由的前进与后退，直接使用 <code>navigate(1)</code> 和 <code>navigate(-1)</code> 即可。</p><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>Redux 是基于 Flux 核心思想实现的状态管理库。这篇文章主要介绍 Flux 与 Redux 的基本思想。</p><h2 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h2><p><strong>组成</strong></p><ul><li>  View</li></ul><p>View 表示视图层面，依据 Store 中的数据展示页面，并实时响应 Store 的数据更新</p><ul><li>  Store</li></ul><p>Store 储存数据（状态）的位置，并且可以响应 Action 的消息</p><ul><li>  Action</li></ul><p>Action 用于描述动作，通常包括动作类型与动作描述</p><ul><li>  Dispacher</li></ul><p>Dispacher 用于接收 Action 并将其转发至 store</p><p><strong>单向数据流</strong></p><p>Flux 应用中的数据以单一方向流动：</p><ol><li>用户在视图层面 View 触发 Action；</li><li>Dispacher 接收 Action 并将其转发至 Store；</li><li>Store 响应 Action 并更新数据；</li><li>视图 View 依据 Store 中更新的数据更新页面。</li></ol><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/24/169ad99e277502d0~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>单一方向数据流还具有以下特点：</p><ul><li>  集中化管理数据。常规应用可能会在视图层的任何地方或回调进行数据状态的修改与存储，而在 Flux 架构中，所有数据都只放在 Store 中进行储存与管理。</li><li>  可预测性。在双向绑定或响应式编程中，当一个对象改变时，可能会导致另一个对象发生改变，这样会触发多次级联更新。对于 Flux 架构来讲，一次 Action 触发，只能引起一次数据流循环，这使得数据更加可预测。</li><li>  方便追踪变化。所有引起数据变化的原因都可由 Action 进行描述，而 Action 只是一个纯对象，因此十分易于序列化或查看。</li></ul><h2 id="Redux-1"><a href="#Redux-1" class="headerlink" title="Redux"></a>Redux</h2><p><strong>组成</strong></p><ul><li>  Store</li></ul><p>储存数据（状态）的唯一位置</p><ul><li>  State</li></ul><p>数据</p><ul><li>  Action</li></ul><p>组件通过 Action 将数据传递给 Store</p><ul><li>  Reducer</li></ul><p>Reducer 用于响应 Action，并在执行之后将 State 发送到 Store</p><p><strong>工作流程</strong></p><p>Redux 的工作流程与 Flux 类似，但是也有许多不同之处：</p><ol><li>用户发出动作 Action，并借由 Dispatcher 发送至 Store。</li><li>Store 将接收到的 Action 与之前的状态传递给内部的处理函数 Reducer，</li><li>Reducer 计算出最新数据并将其发送至存储数据的 Store 中</li><li>订阅了 Store 数据的组件重新渲染。</li></ol><p>Redux 有几大原则：</p><ul><li>  单一数据源。整个应用的数据（状态）储存于唯一存在的 Store 中。</li><li>  State 状态是只读的。不应该直接修改 State，而是通过触发 Action 实现。</li><li>  使用纯函数 Reducer 修改状态。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/274425/1659005485363-cb78240a-c99b-4f19-a7d9-35c91ccbb6ea.png?x-oss-process=image/resize,w_937,limit_0" alt="无标题-2022-07-27-1257.png"></p><p><strong>与 Flux 的不同之处</strong></p><ol><li>Redux 的 Store 唯一，而 Flux 可以具有多个 Store。</li><li>Redux 在 Reducer 中执行数据的更新，而 Flux 直接在 Store 中执行数据的更新。</li></ol><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>组件通过 Action 将数据传递给 Store，也是 Store 中数据的唯一来源。</p><p>Action 本质就是一个对象，但是必须具有字符串类型的 <code>type</code> 属性表示将要执行的动作。Action 的其他属性则完全由自己决定：</p><p>同时，也可以以将 Action 的 type 类型存放于同一个文件中，便于维护（小项目大可不必）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// store/mutation-types.js</span><br><span class="line">export const ADD_TODO = &#x27;ADD_TODO&#x27;</span><br><span class="line">export const REMOVE_TODO = &#x27;REMOVE_TODO&#x27;</span><br><span class="line"></span><br><span class="line">// store/actions.js</span><br><span class="line">import * as types from &#x27;./mutation-types.js&#x27;</span><br><span class="line"></span><br><span class="line">export function addItem(item) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: types.ADD_TODO,</span><br><span class="line">    payload: &#123;</span><br><span class="line">        text: &#x27;Do something&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有用于表示错误的 Action：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  payload: <span class="built_in">new</span> Error(),</span><br><span class="line">  <span class="type">error</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Action-Creator"><a href="#Action-Creator" class="headerlink" title="Action Creator"></a>Action Creator</h3><p>许多时候会有同种类型但是不同消息的 Action。此时可以定义一个函数动态生成某种固定类型的 Action：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const addToDo = (payload) =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: &#x27;TODO_ADD&#x27;,</span><br><span class="line">        payload</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const addAction = addToDo(&#x27;Hello&#x27;)</span><br></pre></td></tr></table></figure><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Reducer 用于响应 Action， 并在执行后将 State 发送到 Store</p><p>本质上是一个函数， 将之前的状态与传递的 Action 作为参数，并返回一个新的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const reducer = (initState, action) =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    return newState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们第一次执行 Reducer 时，并没有原状态，因此我们需要通过指定默认值的方式，来初始化状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const defaultState = 0</span><br><span class="line"></span><br><span class="line">const reducer = (initState = defaultState, action) =&gt; &#123;</span><br><span class="line">    if (action.type == &#x27;TODO_ADD&#x27;) &#123;</span><br><span class="line">        return action.payload</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return initState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const state = reducer(0, &#123;</span><br><span class="line">    type: &#x27;TODO_ADD&#x27;,</span><br><span class="line">    payload: &#x27;this is a test&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实际应用中，Reducer 不需要手动调用，<code>dispatch()</code> 方法会自动触发 Reducer 执行。因此，Store 需要在一开始的时候就知道 Reducer 是谁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#x27;redux&#x27;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer)</span><br></pre></td></tr></table></figure><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>是储存数据（状态）的唯一位置，整个应用只能有一个 Store</p><p>Redux 提供 <code>createStore()</code> 函数生成 Store：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#x27;redux&#x27;</span><br><span class="line"></span><br><span class="line">const store = createStore(Reducer)</span><br></pre></td></tr></table></figure><p><code>createStore()</code> 函数接收 Reducer 作为参数，返回新生成的 Store 对象。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>Store 对象包含所有的数据，如果想要得到数据， 通过 <code>getStore()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const state = store.getState()</span><br></pre></td></tr></table></figure><h3 id="dispatch-方法"><a href="#dispatch-方法" class="headerlink" title="dispatch 方法"></a>dispatch 方法</h3><p>如果想要触发 Action，直接通过 <code>store.dispatch()</code> 方法即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(action)</span><br></pre></td></tr></table></figure><p>由于 Store 在最开始创建的时候，就已经指定了 Reducer，因此通过 <code>dispatch()</code> 方法发送 Action 时，就会自动执行指定的 Reducer。</p><h3 id="subscribe-方法"><a href="#subscribe-方法" class="headerlink" title="subscribe 方法"></a>subscribe 方法</h3><p>可以使用 <code>subscribe()</code> 方法设置监听函数，一旦 State 发生变化，该函数就会自动执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#x27;redux&#x27;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer)</span><br><span class="line"></span><br><span class="line">store.subscribe(listener)</span><br></pre></td></tr></table></figure><p><code>subscribe()</code> 方法返回一个函数，调用这个函数就可以解除监听：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const unsubscribe = store.subscribe(() =&gt;</span><br><span class="line">  console.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure><p>通常，当状态 State 发生改变时，我们会重新渲染根组件 <code>App</code>，因此我们只需要在最外层组件进行订阅。</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>Redux 的基本思想是：用户触发 Action，从而触发 Reducer，Reducer 结合 Action 类型计算出新的 State。</p><p>这样的一个顺序显然是同步的，但是如果存在异步操作，就需要用到 <strong>中间件 Middleware</strong>。</p><h3 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h3><p>中间件，就是处理一个功能的中间环节，主要用于处理具有副作用的功能，比如异步操作就是最常见的中间件。</p><p>在一个项目中可以使用多个中间件，可以将其串联组合。</p><p>Redux 中间件用于处理状态的更新。</p><h3 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h3><p>没有中间件的执行顺序：Action → Reducer。</p><p>使用中间件的执行顺序：Action → 中间件 → Reducer。</p><h3 id="applyMiddlewares"><a href="#applyMiddlewares" class="headerlink" title="applyMiddlewares()"></a>applyMiddlewares()</h3><p>Redux 为我们提供了 <code>applyMiddlewares()</code> 方法，用于将所有的中间件组成一个数组依次执行。</p><p>如果想要使用中间件，我们只需要将 <code>applyMiddlewares()</code> 的调用结果作为创建 Store 的方法 <code>createStore()</code> 的第二个参数即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore(</span><br><span class="line">    reducer,</span><br><span class="line">    applyMiddlewares(A, B, C)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h2><p>React-Redux 将所有组件分成两大类：UI 组件和容器组件。</p><p><strong>UI 组件</strong></p><p>UI 组件有以下几个特征。</p><ul><li>  只负责 UI 的呈现，不带有任何业务逻辑</li><li>  没有状态（即不使用 state）</li><li>  所有数据都由参数 props 提供</li><li>  不使用任何 React-Redux 的 API</li></ul><p><strong>容器组件</strong></p><ul><li>  负责管理数据和业务逻辑，不负责 UI 的呈现</li><li>  带有内部状态</li><li>  使用 React-Redux 的 API</li></ul><p>React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p>connect 方法用于从 UI 组件中生成容器组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &#x27;react-redux&#x27;</span><br><span class="line">const ContainerBox = connect()(Box)</span><br></pre></td></tr></table></figure><p>上面的代码中，Box 是 UI 组件，connect 方法得到的 ContainerBox 就是对应的容器组件。</p><p>但是由于这个容器组件没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个简单的包装层而已。</p><p>如果需要定义业务逻辑，需要有下面两个信息：</p><ol><li>输入逻辑：外部的数据（即容器组件的 State），如何传递至内部（即 UI 组件的 props 属性）。</li><li>输出逻辑：用户放出的动作（即 UI 组件的属性）如何变为 Action 对象， 从 UI 组件中传递出去。</li></ol><p>结合上面这两点，可以将 connect 方法的完整 API 归结如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; from &#x27;react-redux&#x27;</span><br><span class="line">const ContainerBox = connect(</span><br><span class="line">mapStateToProps,</span><br><span class="line">    mapPropsToAction</span><br><span class="line">)(Box)</span><br></pre></td></tr></table></figure><h3 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps()"></a>mapStateToProps()</h3><p>mapStateToProps 方法用于将容器组件的 state 映射到 UI 组件的 props。因此，该方法应该返回一个对象，里面的每一个键值对都是一个映射。</p><p>如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function mapStateToProps (state) &#123;</span><br><span class="line">    return &#123; count: state &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapStateToProps 会订阅 Store，每当 State 更新时，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p><p>mapStateToProps 第一个对象是 state，可以接收第二个参数代表容器组件的 props 对象。</p><p>connect 方法可以省略 mapStateToProps 参数，如果这样，UI 组件将不会订阅 Store，即 Store 的更新不会引起 UI 组件的重新渲染。</p><h3 id="mapPropsToAction"><a href="#mapPropsToAction" class="headerlink" title="mapPropsToAction()"></a>mapPropsToAction()</h3><p>mapPropsToAction 是 connect 函数的第二个参数，用来建立 UI 组件的参数到 store.dispatch 方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function mapDispatchToProps (dispatch) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        jia: (data) =&gt; &#123;</span><br><span class="line">            dispatch(addAction(data))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redux-Toolkit"><a href="#Redux-Toolkit" class="headerlink" title="Redux-Toolkit"></a>Redux-Toolkit</h1><h2 id="configureStore"><a href="#configureStore" class="headerlink" title="configureStore"></a>configureStore</h2><p>通常情况下，你可以调用 <code>createStore()</code> 来创建一个 Redux store ，并传入你的 root reducer 函数。Redux 工具包 有一个 <code>configureStore()</code> 函数，其中覆盖了 <code>createStore()</code> 来做同样的事情，同时也设置了一些有用的开发工具给你作为 store 创建过程的一部分。</p><p>我们可以很容易的用 <code>configureStore</code> 替换现有的 <code>createStore</code> 调用。<code>configureStore</code> 接受一个具有指定字段的对象，而不是多个函数参数，因此我们需要将 reducer 函数作为一个名为 <code>reducer</code> 的字段传递：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 之前:</span><br><span class="line">const store = createStore(counter)</span><br><span class="line"></span><br><span class="line">// 之后:</span><br><span class="line">const store = configureStore(&#123;</span><br><span class="line">  reducer: counter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="createAction"><a href="#createAction" class="headerlink" title="createAction"></a>createAction</h2><p><code>createAction</code> 接受一个 action type 字符串作为参数，并返回一个使用该 type 字符串的 action creator 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 原本的实现: 纯手工编写 action type 和 action creator</span><br><span class="line">const INCREMENT = &#x27;INCREMENT&#x27;</span><br><span class="line"></span><br><span class="line">function incrementOriginal() &#123;</span><br><span class="line">  return &#123; type: INCREMENT &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(incrementOriginal())</span><br><span class="line">// &#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line"></span><br><span class="line">// 或者，使用 `createAction` 来生成 action creator:</span><br><span class="line">const incrementNew = createAction(&#x27;INCREMENT&#x27;)</span><br><span class="line"></span><br><span class="line">console.log(incrementNew())</span><br><span class="line">// &#123;type: &quot;INCREMENT&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li>  引用 action type 字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> increment = <span class="title function_">createAction</span>(<span class="string">&#x27;INCREMENT&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过toStirng()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(increment.<span class="title function_">toString</span>())</span><br><span class="line"><span class="comment">// &quot;INCREMENT&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 .type</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(increment.<span class="property">type</span>)</span><br><span class="line"><span class="comment">// &quot;INCREMENT&quot;</span></span><br></pre></td></tr></table></figure><p>如果想要给 action 添加额外的数据，可以在调用 action creator 时传入一个 payload 参数。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addTodo = <span class="title function_">createAction</span>(<span class="string">&#x27;todos/add&#x27;</span>)</span><br><span class="line"><span class="title function_">addTodo</span>(&#123; <span class="attr">text</span>: <span class="string">&#x27;Learn Redux&#x27;</span> &#125;) <span class="comment">// &#123; type: &#x27;todos/add&#x27;, payload: &#123; text: &#x27;Learn Redux&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="createReducer"><a href="#createReducer" class="headerlink" title="createReducer"></a>createReducer</h2><p>接收两个参数，第一个是初始化的值，第二个就是我们定义的响应 action 的部分</p><p>它让使用”查找表”对象的方式编写 reducer，其中对象的每一个 key 都是一个 Redux action type 字符串，value 是 reducer 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const increment = createAction(&#x27;INCREMENT&#x27;)</span><br><span class="line">const decrement = createAction(&#x27;DECREMENT&#x27;)</span><br><span class="line"></span><br><span class="line">const counter = createReducer(0, &#123;</span><br><span class="line">  [increment.type]: state =&gt; state + 1,</span><br><span class="line">  [decrement.type]: state =&gt; state - 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="createSlice"><a href="#createSlice" class="headerlink" title="createSlice"></a>createSlice</h2><p>它允许我们提供一个带有 reducer 函数的对象，并且它将根据我们列出的 reducer 的名称自动生成 action type 字符串和 action creator 函数。</p><p><code>createSlice</code> 返回一个 “切片” 对象，该对象包含被生成的 reducer 函数，其作为一个名为 <code>reducer</code> 的字段，以及被生成的、放置在一个名为 <code>actions</code> 的对象中的所有 action creator 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const counterSlice = createSlice(&#123;</span><br><span class="line">  name: &#x27;counter&#x27;,</span><br><span class="line">  initialState: 0,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    increment: state =&gt; state + 1,</span><br><span class="line">    decrement: state =&gt; state - 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const store = configureStore(&#123;</span><br><span class="line">  reducer: counterSlice.reducer</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">document.getElementById(&#x27;increment&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">  store.dispatch(counterSlice.actions.increment())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意： 如果像上面这样定义，要想对这个 store 进行 dispath， 必须使用它自身提供的 action 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const &#123; increment, decrement &#125; = counterSlice.actions</span><br></pre></td></tr></table></figure><p>包括其他模块在内，必须使用导出的 action， 而不能使用 类似 createAction 返回的内容， 如 <code>dispatch(createAction(&#39;increment&#39;)) </code> 这样的 dispatch 是不会引起上面的 store 的变化的</p><p>如果要使用，只能在 createSlice() 中添加一个 <code>extraReducers</code> 对象，在里面使用类似 <code>createReducer()</code> 的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ADD</span> = <span class="title function_">createAction</span>(<span class="string">&#x27;ADD&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">SUB</span> = <span class="title function_">createAction</span>(<span class="string">&#x27;SUB&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;counter&#x27;</span>,</span><br><span class="line"><span class="attr">initialState</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">reducers</span>: &#123;&#125;,</span><br><span class="line"><span class="attr">extraReducers</span>: &#123;</span><br><span class="line">[<span class="variable constant_">ADD</span>.<span class="property">type</span>]: <span class="function">(<span class="params">state</span>) =&gt;</span> state + <span class="number">1</span>,</span><br><span class="line">[<span class="variable constant_">SUB</span>.<span class="property">type</span>]: <span class="function">(<span class="params">state</span>) =&gt;</span> state - <span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">configureStore</span>(&#123;</span><br><span class="line"><span class="attr">reducer</span>: counterSlice.<span class="property">reducer</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意： 这样在 reducers 中就不能再定义 ADD， SUB 两个 action 了</p><h2 id="HOOKS"><a href="#HOOKS" class="headerlink" title="HOOKS"></a>HOOKS</h2><h3 id="useSelector"><a href="#useSelector" class="headerlink" title="useSelector"></a>useSelector</h3><p><code>const result: any = useSelector(selector: Function, equalityFn?: Function)</code></p><p>允许你使用一个 selector 函数从 Redux store state 中提取数据。</p><p>selector 将以整个 Redux store state 作为唯一的参数被调用。每当函数组件渲染时，selector 就会被运行（除非在组件的前一次渲染后引用没有改变，这样 hooks 就会返回缓存的结果，而不是重新运行 selector）。<code>useSelector()</code> 也会订阅 Redux store，每当有 action 被 dispatched 时就会运行 selector。</p><ul><li><p>  selector 返回的结果可以是任何值，而不仅仅是一个对象。selector 的返回值将被作为 <code>useSelector()</code> hook 的返回值被使用。</p></li><li><p>  当 dispatch 一个 action 时，<code>useSelector()</code> 将对 selector 的前一个结果值和当前的结果值做一个引用比较。如果它们不同，该组件将被强制重新渲染。如果它们相同，组件将不会重新渲染。</p></li></ul><ul><li>  <code>useSelector()</code> 默认使用严格的 <code>===</code> 引用全等检查，而不是浅层全等比较</li></ul><h3 id="useDispatch"><a href="#useDispatch" class="headerlink" title="useDispatch()"></a>useDispatch()</h3><p>这个 hook 返回一个对 Redux store 中的 <code>dispatch</code> 函数的引用。你可以按需使用它来 dispatch action。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123; useDispatch &#125; from &#x27;react-redux&#x27;</span><br><span class="line"></span><br><span class="line">export const CounterComponent = (&#123; value &#125;) =&gt; &#123;</span><br><span class="line">  const dispatch = useDispatch()</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;value&#125;&lt;/span&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;increment-counter&#x27; &#125;)&#125;&gt;</span><br><span class="line">        Increment counter</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useStore"><a href="#useStore" class="headerlink" title="useStore()"></a>useStore()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br></pre></td></tr></table></figure><p>这个 hook 返回一个 Redux store 引用，该 store 与传递给 <code>&lt;Provider&gt;</code> 组件的 store 相同。</p><p>不应该频繁使用这个 hook。宁愿将 <code>useSelector()</code> 作为主要选择。然而，对于少量需要访问 store 的场景而言，例如替换 reducer，这个 hook 很有用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见手写</title>
      <link href="/2023/02/08/%E6%89%8B%E5%86%99/"/>
      <url>/2023/02/08/%E6%89%8B%E5%86%99/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化</title>
      <link href="/2023/02/08/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2023/02/08/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><h3 id="1-什么是模块"><a href="#1-什么是模块" class="headerlink" title="1.什么是模块?"></a>1.什么是模块?</h3><ul><li>  将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li><li>  块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li></ul><h3 id="2-模块化的进化过程"><a href="#2-模块化的进化过程" class="headerlink" title="2.模块化的进化过程"></a>2.模块化的进化过程</h3><ul><li>全局 function 模式 : 将不同的功能封装成不同的全局函数<ul><li>  编码: 将不同的功能封装成不同的全局函数</li><li>  问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li></ul></li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><ul><li>namespace 模式 : 简单对象封装<ul><li>  作用: 减少了全局变量，解决命名冲突</li><li>  问题: 数据不安全(外部可以直接修改模块内部的数据)</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myModule = &#123;</span><br><span class="line"><span class="attr">data</span>: <span class="string">&#x27;www.baidu.com&#x27;</span>,</span><br><span class="line"><span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`foo() <span class="subst">$&#123;<span class="variable language_">this</span>.data&#125;</span>`</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`bar() <span class="subst">$&#123;<span class="variable language_">this</span>.data&#125;</span>`</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">myModule.<span class="property">data</span> = <span class="string">&#x27;other data&#x27;</span> <span class="comment">//能直接修改模块内部的数据</span></span><br><span class="line">myModule.<span class="title function_">foo</span>() <span class="comment">// foo() other data复制代码</span></span><br></pre></td></tr></table></figure><p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。</p><ul><li>IIFE 模式：匿名函数自调用(闭包)<ul><li>  作用: 数据是私有的, 外部只能通过暴露的方法操作</li><li>  编码: 将数据和行为封装到一个函数内部, 通过给 window 添加属性来向外暴露接口</li><li>  问题: 如果当前这个模块依赖另一个模块怎么办?</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    myModule.<span class="title function_">foo</span>()</span></span><br><span class="line"><span class="language-javascript">    myModule.<span class="title function_">bar</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myModule.<span class="property">data</span>) <span class="comment">//undefined 不能访问模块内部数据</span></span></span><br><span class="line"><span class="language-javascript">    myModule.<span class="property">data</span> = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span></span><br><span class="line"><span class="language-javascript">    myModule.<span class="title function_">foo</span>() <span class="comment">//没有改变</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>复制代码</span><br><span class="line">// module.js文件</span><br><span class="line">(function(window) &#123;</span><br><span class="line">  let data = &#x27;www.baidu.com&#x27;</span><br><span class="line">  //操作数据的函数</span><br><span class="line">  function foo() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`foo() $&#123;data&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    //用于暴露有函数</span><br><span class="line">    console.log(`bar() $&#123;data&#125;`)</span><br><span class="line">    otherFun() //内部调用</span><br><span class="line">  &#125;</span><br><span class="line">  function otherFun() &#123;</span><br><span class="line">    //内部私有的函数</span><br><span class="line">    console.log(&#x27;otherFun()&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  //暴露行为</span><br><span class="line">  window.myModule = &#123; foo, bar &#125; //ES6写法</span><br><span class="line">&#125;)(window)复制代码</span><br></pre></td></tr></table></figure><p>最后得到的结果：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/9/16793716ec47b94d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>  <strong>IIFE 模式增强 : 引入依赖</strong></li></ul><p>这就是现代模块实现的基石</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"><span class="variable language_">window</span>, $</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">    <span class="title function_">otherFun</span>() <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">otherFun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;otherFun()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">myModule</span> = &#123; foo, bar &#125;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>, jQuery)复制代码</span><br><span class="line"> <span class="comment">// index.html文件</span></span><br><span class="line">  &lt;!-- 引入的js必须有一定顺序 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    myModule.foo()</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>复制代码</span><br></pre></td></tr></table></figure><p>上例子通过 jquery 方法将页面的背景颜色改成红色，所以必须先引入 jQuery 库，就把这个库当作参数传入。<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</p><p>作者：浪里行舟<br>链接：<a href="https://juejin.cn/post/6844903744518389768">https://juejin.cn/post/6844903744518389768</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><h2 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h4><ul><li>  所有代码都运行在模块作用域，不会污染全局作用域。</li><li>  模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>  模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h4 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="(3)基本语法"></a>(3)基本语法</h4><ul><li>  暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code></li><li>  引入模块：<code>require(xxx)</code>,如果是第三方模块，xxx 为模块名；如果是自定义模块，xxx 为模块文件路径</li></ul><p>此处我们有个疑问：<strong>CommonJS 暴露的模块到底是什么?</strong> CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的 module.exports 属性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="type">var</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">addX</span> <span class="operator">=</span> function (value) &#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span>.x = x;</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span>.addX = addX;复制代码</span><br></pre></td></tr></table></figure><p>上面代码通过 module.exports 输出变量 x 和函数 addX。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = require(<span class="string">&#x27;./example.js&#x27;</span>);<span class="comment">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(example.addX(<span class="number">1</span>)); <span class="comment">// 6复制代码</span></span><br></pre></td></tr></table></figure><p>require 命令用于加载模块文件。<strong>require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错</strong>。</p><h4 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="(4)模块的加载机制"></a>(4)模块的加载机制</h4><p><strong>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。这点与 ES6 模块化有重大差异（下文会介绍），请看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="type">var</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">function <span class="title function_">incCounter</span><span class="params">()</span> &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面代码输出内部变量 counter 和改写这个变量的内部方法 incCounter。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = require(<span class="string">&#x27;./lib&#x27;</span>).counter;</span><br><span class="line"><span class="keyword">var</span> incCounter = require(<span class="string">&#x27;./lib&#x27;</span>).incCounter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(counter);  <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码说明，counter 输出以后，lib.js 模块内部的变化就影响不到 counter 了。<strong>这是因为 counter 是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</strong>。</p><h3 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2.AMD"></a>2.AMD</h3><p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。但是，<strong>如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范</strong>。此外 AMD 规范比 CommonJS 规范在浏览器端实现要来着早。</p><h3 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3.CMD"></a>3.CMD</h3><p>CMD 规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD 规范整合了 CommonJS 和 AMD 规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD 模块定义规范。</p><h3 id="4-ES6-模块化"><a href="#4-ES6-模块化" class="headerlink" title="4.ES6 模块化"></a>4.ES6 模块化</h3><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><h4 id="1-ES6-模块化语法"><a href="#1-ES6-模块化语法" class="headerlink" title="(1)ES6 模块化语法"></a>(1)ES6 模块化语法</h4><p>export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">add</span> = function (a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; basicNum, <span class="keyword">add</span> &#125;;</span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line">import &#123; basicNum, <span class="keyword">add</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="function">function <span class="title">test</span>(<span class="params">ele</span>)</span> &#123;</span><br><span class="line">    ele.textContent = <span class="keyword">add</span>(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;复制代码</span><br></pre></td></tr></table></figure><p>如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 export default 命令，为模块指定默认输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default&#x27;</span></span><br><span class="line"><span class="title function_">customName</span>() <span class="comment">// &#x27;foo&#x27;复制代码</span></span><br></pre></td></tr></table></figure><p>模块默认输出, 其他模块加载该模块时，import 命令可以为该匿名函数指定任意名字。</p><h4 id="2-ES6-模块与-CommonJS-模块的差异"><a href="#2-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="(2)ES6 模块与 CommonJS 模块的差异"></a>(2)ES6 模块与 CommonJS 模块的差异</h4><p>它们有两个重大差异：</p><p><strong>① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</strong>。</p><p><strong>② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong>。</p><p>第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>下面重点解释第一个差异，我们还是举上面那个 CommonJS 模块的加载机制例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">counter++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter) <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter) <span class="comment">// 4复制代码</span></span><br></pre></td></tr></table></figure><p>ES6 模块的运行机制与 CommonJS 不一样。<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack</title>
      <link href="/2023/02/08/webpack/"/>
      <url>/2023/02/08/webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h2><p>开发时，我们会使用一些技术框架（React、Vue 等）、ES6 模块化语法、Less/Sass 等 CSS 预处理器进行开发。这些必须经过编译成浏览器能识别的 JS、CSS 等语法才能最终在浏览器中运行。</p><p>打包工具就可以帮助我们完成这些工作。除此之外，打包工具还可以帮助我们压缩代码、进行兼容性处理，以及提升性能等等。</p><p>常见的打包工具有：Grunt、Gulp、Webpack、Vite 等等。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>Webpack 以一个或多个文件作为入口，将我们整个项目所有文件编译组合为一个或多个文件输出。输出的文件就是编译好的文件，即可以在浏览器运行的文件。我们通常将 Webpack 输出的文件叫做 <code>bundle</code>。</p><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p>一个典型的项目基本目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Code # 根目录（所有指令都必须在这个目录下运行）</span><br><span class="line">|-- public # 静态资源目录</span><br><span class="line">|--src # 源码目录</span><br></pre></td></tr></table></figure><h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><p>首先初始化 npm 环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>初始化后的项目目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Code # 根目录（所有指令都必须在这个目录下运行）</span><br><span class="line">|-- public # 静态资源目录</span><br><span class="line">|--src # 源码目录</span><br><span class="line">|-- package.json</span><br></pre></td></tr></table></figure><p>在开发过程中，我们需要 Webpack 的基本环境，包括 <code>webpack</code> 与 <code>webpack-cli</code> 这两个依赖。由于这两个依赖仅仅是在开发环境中需要，因此我们可以使用 <code>-D</code> 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure><p>下载依赖后的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Code # 根目录（所有指令都必须在这个目录下运行）</span><br><span class="line">|-- node_modules # 依赖</span><br><span class="line">|-- public # 静态资源目录</span><br><span class="line">|--src # 源码目录</span><br><span class="line">|-- package.json</span><br></pre></td></tr></table></figure><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>接下来我们初次尝试 Webpack 的基本操作。创建如下文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Code # 根目录（所有指令都必须在这个目录下运行）</span><br><span class="line">|-- node_modules</span><br><span class="line">|-- public # 静态资源目录</span><br><span class="line">|-- index.html</span><br><span class="line">|--src # 源码目录</span><br><span class="line">|--js # js 文件目录</span><br><span class="line">||-- sum.js</span><br><span class="line">||-- count.js</span><br><span class="line">|-- main.js # 项目主文件</span><br><span class="line">|-- package.json</span><br></pre></td></tr></table></figure><ul><li>  sum.js</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default function sum(...args) &#123;</span><br><span class="line">    return args.reduce((p, c) =&gt; p + c, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  count.js</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default function count(x, y) &#123;</span><br><span class="line">    return x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  main.js</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import sum from &#x27;./js/sum&#x27;</span><br><span class="line">import count from &#x27;./js/count&#x27;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2, 3, 4))</span><br><span class="line">console.log(count(3, 1))</span><br></pre></td></tr></table></figure><ul><li>  index.html</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack Study&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello Webpack&lt;/h1&gt;</span><br><span class="line">    &lt;script src=&quot;src/main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>除了添加上述文件之外，我们还需要编辑一下 <code>package.json</code> 文件，修改 <code>main</code> 字段，将其指向为我们的入口文件：</p><ul><li>  package.json</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  &quot;main&quot;: &quot;./src/main.js&quot;,</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行-Webpack"><a href="#运行-Webpack" class="headerlink" title="运行 Webpack"></a>运行 Webpack</h3><p>在进行上述的编辑之后，如果直接打开 <code>public/index.html</code> 会发现控制台有报错信息。这是因为浏览器无法直接识别 <code>public/index.html</code> 中导入的 JS 文件中的 <code>import</code> 语句，因此我们需要使用打包工具进行编译处理。</p><p>我们在 <strong>项目根目录</strong> 执行下列命令，其中 <code>--mode=developmen</code> 表示当前的环境为开发环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack ./src/main.js --mode=development</span><br></pre></td></tr></table></figure><p>当运行成功后，在我们的根目录下会出现 <code>dist</code> 目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Code # 根目录（所有指令都必须在这个目录下运行）</span><br><span class="line">|-- dist # 输出目录</span><br><span class="line">|-- main.js</span><br><span class="line">|-- node_modules</span><br><span class="line">|-- public # 静态资源目录</span><br><span class="line">|--src # 源码目录</span><br><span class="line">|-- package.json</span><br></pre></td></tr></table></figure><p>随后，我们在 <code>public/index.html</code> 文件中将导入的 JS 文件更改为打包后的 JS 文件即可运行成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack Study&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello Webpack&lt;/h1&gt;</span><br><span class="line">    &lt;script src=&quot;../dist/main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们将执行命令的参数修改为生产环境，重新执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack ./src/main.js --mode=production</span><br></pre></td></tr></table></figure><p>执行结束后，我们发现同样生成了 <code>dist</code> 目录，但是 <code>dist/main.js</code> 中的内容不一样。这是因为在不同的环境中，打包的方式也不一样。</p><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><ul><li>  entry 入口</li></ul><p>指定 Webpack 从哪个文件开始打包</p><ul><li>  output 出口</li></ul><p>指定 Webpack 打包后的文件输出在何处，以及如何命名等</p><ul><li>  loader 加载器</li></ul><p>Webpack 本身只能处理 Js、Json 等资源，需要借助 loader 才能解析其他资源</p><ul><li>  plugins 插件</li></ul><p>用于扩展 Webpack 的功能</p><blockquote><p><code>loader</code> 与 <code>webpack</code> 的区别：</p><ol><li> 作用不同</li></ol><p>Webpack 只能打包 CommonJS 规范下的 JS 文件，而包括 CSS 在内的其他类型文件是无法打包的，此时就需要使用第三方的 <code>loader</code> 帮助打包。<code>loader</code> 的作用就集中在了“转化文件”这一点上，如 <code>css-loader</code> 与 <code>style-loader</code> 可以帮助打包 CSS 文件、<code>babel-loader</code> 与 <code>babel-core</code> 可以帮助将 ES6 的代码转化为 ES5。</p><p><code>plugins</code> 的作用不局限于打包文件、加载资源，它的作用还包括重新定义环境变量、优化性能等等。</p><ol><li> 执行时机不同。</li></ol><p><code>loader</code> 运行在打包文件之前；<code>plugins</code> 则是在整个编译周期都可能会起作用。</p></blockquote><ul><li>  mode 模式</li></ul><p>指定开发模式 development 或者 生产模式 production</p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>前面小节介绍了 Webpack 的基本属性：<code>entry</code>、<code>output</code>、<code>loader</code>、<code>plugin</code> 与 <code>mode</code>。我们需要在项目根目录新建 <code>webpack.config.js</code> 文件，并在其中指定这五大基本属性。</p><p>由于 Webpack 本身基于 Node.js 运行，因此配置文件基于 CommonJS 模块化规范，使用 <code>module.exports</code> 导出。</p><p>接下来我们填入五大基本属性的具体内容：</p><ul><li>  <code>entry</code></li></ul><p>入口文件就是 <code>src/main.js</code>，使用相对路径指定即可：<code>./src/main.js</code>。</p><ul><li>  <code>output</code></li></ul><p>从上一小节中可以发现，当我们没有手动配置输出信息时，会默认输出在根目录的 <code>dist</code> 目录下。此时，借助配置文件的 <code>output</code> 属性，我们可以同时指定输出的路径 <code>path</code> 与输出文件名 <code>filename</code>。</p><p>需要注意的是，输出的路径 <code>path</code> 只能指定绝对路径，因此此处我们需要借助 Node.js 中的 <code>path</code> 模块来指定输出路径。</p><p>而 <code>filename</code> 则可以指定输出文件相对于 <code>path</code> 的目录。如 <code>path</code> 指定为 <code>dist</code>，<code>filename</code> 指定为 <code>js/main.js</code>，那么最终输出文件的路径为 <code>dist/js/main.js</code>。</p><ul><li>  <code>loader</code></li></ul><p>如果有需要指定的加载器 <code>loader</code>，那么我们将其填入 <code>module.rules</code> 中。此时没有需要使用的 <code>loader</code>，因此将 <code>rules</code> 指定为空数组即可。</p><ul><li>  <code>plugins</code></li></ul><p>与 <code>loader</code> 不同，如果有需要指定的插件 <code>plugin</code>，我们直接将其填入 <code>plugins</code> 属性数组中即可。此时没有需要使用的 <code>plugin</code>，因此将 <code>plugins</code> 指定为空数组即可。</p><ul><li>  <code>mode</code></li></ul><p><code>mode</code> 主要有两种模式：开发模式 <code>development</code> 与生产模式 <code>production</code>。此处我们先指定为开发模式。</p><p>基本配置如下</p><p>当我们编辑了 Webpack 配置文件之后，如果需要执行编译命令，就不再需要像上一小节中手动输入对应的参数。只需要直接执行下列命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><h2 id="自动清空输出目录"><a href="#自动清空输出目录" class="headerlink" title="自动清空输出目录"></a>自动清空输出目录</h2><p>在当前配置下，我们每次执行 <code>npx webpack</code> 命令，都会在输出目录下输出文件，而如果原本输出目录下有其他的文件，并不会删除。我们可以在 <code>output</code> 中添加 <code>clean: true</code> 属性实现每次打包前，自动清空输出目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出路径，注意！这里的输出路径是所有文件的输出路径</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// dirname 表示当前文件的绝对路径</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/main.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 自动清空输出路径</span></span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>开发模式即我们书写代码时所用的模式。在开发模式下，我们主要关注以下两点：</p><ol><li>将原本浏览器不能识别的代码编译为浏览器能识别运行的代码。</li></ol><p>开发时我们会使用许多样式资源、字体图标等等，这些都是 Webpack 默认不能直接处理的资源。开发模式下的 Webpack 配置首要任务就是处理这些资源。</p><ol><li>代码质量检查，树立规范代码。</li></ol><p>Webpack 可以帮助我们检查出代码的一些隐患，同时检查代码规范与格式。</p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p>1、读取<code>webpack</code>的配置参数；</p><p>2、启动<code>webpack</code>，创建<code>Compiler</code>对象并开始解析项目；</p><p>3、从入口文件（<code>entry</code>）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；</p><p>4、对不同文件类型的依赖模块文件使用对应的<code>Loader</code>进行编译，最终转为<code>Javascript</code>文件；</p><p>5、整个过程中<code>webpack</code>会通过发布订阅模式，向外抛出一些<code>hooks</code>，而<code>webpack</code>的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。</p><h1 id="处理样式资源"><a href="#处理样式资源" class="headerlink" title="处理样式资源"></a>处理样式资源</h1><p>前面的小节已经提到，Webpack 并不能直接处理包括 CSS、Less 在内的样式资源，此时我们只有借助 <code>loader</code> 才能解析样式资源。</p><p>对应的 <code>loader</code> 都可以去 <a href="https://webpack.js.org/">官方文档</a> 中查看详细的说明。</p><h2 id="处理-CSS-资源"><a href="#处理-CSS-资源" class="headerlink" title="处理 CSS 资源"></a>处理 CSS 资源</h2><p>其中，<code>css-loader</code> 将 CSS 资源编译为 CommonJS 的模块载入 JS 中；<code>style-loader</code> 将编译后的 CSS 模块通过创建 <code>&lt;style&gt;</code> 标签的方式添加至 HTML 文件中。</p><p>首先下载对应的 <code>loader</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader style-loader -D</span><br></pre></td></tr></table></figure><p>随后在配置文件的 <code>module</code> 属性中对 <code>loader</code> 进行配置。<code>rules</code> 数组接收对象作为元素，每个对象至少包含 <code>test</code> 与 <code>use</code> 这两个属性：</p><ul><li>  <code>test</code> 属性通过正则表达式指定检测的文件类型；</li><li>  <code>use</code> 属性是一个数组，<strong>逆序接收</strong> 需要用到的 <code>loader</code> 字符串。</li></ul><blockquote><p>由于执行顺序是从后往前，因此我们需要逆序接收 <code>loader</code> 字符串。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    // 从后往前执行，先执行 css-loader，再执行 style-loader</span><br><span class="line">                    &#x27;style-loader&#x27;,</span><br><span class="line">                    &#x27;css-loader&#x27;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>接下来，在 <code>src</code> 下创建 <code>css</code> 目录与文件，并在入口文件 <code>src/main.js</code> 中引入 CSS 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Code <span class="comment"># 根目录（所有指令都必须在这个目录下运行）</span></span><br><span class="line">|-- node_modules</span><br><span class="line">|-- public <span class="comment"># 静态资源目录</span></span><br><span class="line">|--src <span class="comment"># 源码目录</span></span><br><span class="line">|-- css</span><br><span class="line">|-- index.css</span><br><span class="line">|-- js</span><br><span class="line">|-- package.json</span><br><span class="line">|-- webpack.config.js</span><br></pre></td></tr></table></figure><ul><li>  <code>src/main.js</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">sum</span> from <span class="string">&#x27;./js/sum&#x27;</span></span><br><span class="line">import count from <span class="string">&#x27;./js/count&#x27;</span></span><br><span class="line">import <span class="string">&#x27;./css/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="built_in">sum</span>(1, 2, 3, 4))</span><br><span class="line">console.log(count(3, 1))</span><br></pre></td></tr></table></figure><p>此时，我们执行 <code>npx webpack</code>。执行完毕后，打开 <code>public/index.html</code> 便可以发现 CSS 资源效果已经生效。</p><h2 id="处理-Less-资源"><a href="#处理-Less-资源" class="headerlink" title="处理 Less 资源"></a>处理 Less 资源</h2><p>如果想要处理 Less 资源，我们需要使用 <code>less-loader</code>。<code>less-loader</code> 用于将 Less 资源编译为 CSS 资源，此时我们相当于已经得到了 CSS 资源，接下来就按照处理 CSS 资源的方式进行处理即可。</p><p><code>less-loader</code> 用于将 Less 资源编译为 CSS 资源，但是 <code>less-loader</code> 本身依赖 <code>less</code> 进行编译。因此我们实际上需要 <code>less</code>与 <code>less-loader</code> 这两个依赖才能编译 Less 文件。</p><p>首先，下载对应依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader -D</span><br></pre></td></tr></table></figure><p>对 less 资源进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="comment">// 从后往前执行，先执行 css-loader，再执行 style-loader</span></span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>此时，当我们需要使用 Less 资源时，直接引入即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sum from &#x27;./js/sum&#x27;</span><br><span class="line">import count from &#x27;./js/count&#x27;</span><br><span class="line">import &#x27;./css/index.css&#x27;</span><br><span class="line">import &#x27;./less/index.less&#x27;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2, 3, 4))</span><br><span class="line">console.log(count(3, 1))</span><br></pre></td></tr></table></figure><h2 id="处理-Sass-Scss-资源"><a href="#处理-Sass-Scss-资源" class="headerlink" title="处理 Sass/ Scss 资源"></a>处理 Sass/ Scss 资源</h2><p>类似于 less , 我们下载 <code>sass</code> 与 <code>sass-loader</code> 对 Sass/Scss 资源进行编译：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sass sass-loader -D</span><br></pre></td></tr></table></figure><p>对 Sass/Scss 资源进行 <code>loader</code> 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line"><span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>],</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="处理图片资源"><a href="#处理图片资源" class="headerlink" title="处理图片资源"></a>处理图片资源</h1><p>在 Webpack5 以前，需要 <code>file-loader</code> 与 <code>url-loader</code> 才能处理图片资源。而现在 Webpack5 已经将这两个 <code>loader</code> 内置在了 Webpack 中，因此不再需要单独下载。</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>与前面处理 CSS 资源类似，我们也需要在 <code>module.rules</code> 对图片资源的处理进行配置，但是略有不同。</p><p>我们仍然使用 <code>test</code> 对文件类型进行检测，但是不再使用 <code>use</code> 指定 <code>loader</code>，而是使用 <code>type</code> 属性，将这些文件类型指定为 <code>asset</code>。</p><p>如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们就可以正常使用图片资源了。（比如在 CSS 中指定背景图片等）</p><p>实际上，我们如果不做上面这些配置，依然能打包成功，图片会输出到 dist 中</p><p>我们导入图片资源后，再执行 <code>npx webpack</code> 命令后会发现，输出目录 <code>dist</code> 下多了我们导入的那几张图片。</p><p>那么为什么之前的样式资源没有单独输出为文件呢？因为处理样式资源所使用的 <code>style-loader</code> 将最终的 CSS 资源嵌入到了输出文件 <code>dist/main.js</code> 中。</p><h2 id="图片资源的优化"><a href="#图片资源的优化" class="headerlink" title="图片资源的优化"></a>图片资源的优化</h2><p>有的时候，我们可能希望图片资源并不单独作为文件请求，而是转化为 Base64 格式嵌入代码文件中。</p><p>我们可以在 <code>rules</code> 中添加 <code>parser.dataUrlCondition.maxSize</code> 属性，用于表示当图片资源的大小小于这个值时，将其转化为 Base64 嵌入代码文件中；否则，作为单独的图片资源使用。</p><p>如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line"><span class="attr">parser</span>: &#123;</span><br><span class="line"><span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line"><span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于 10 kb 的图片将会被转化为 Base64</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片资源的打包路径"><a href="#图片资源的打包路径" class="headerlink" title="图片资源的打包路径"></a>图片资源的打包路径</h2><p>我们可以在 <code>generator.filename</code> 中指定图片资源的打包路径，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;imgs/[hash][ext][query]&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>  imgs 就是输出的路径</li><li>  hash 就是根据文件内容生产的一个唯一的 ID</li><li>  ext 就是文件的扩展名，之前的是什么就是什么</li><li>  query 就是查询参数，如果之前在写 url 地址带了一些查询参数就会携带上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line"><span class="attr">parser</span>: &#123;</span><br><span class="line"><span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line"><span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于 10 kb 的图片将会被转化为 Base64</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">generator</span>: &#123;</span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;imgs/[hash:8][ext]&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>[hash:8]</code> 表示打包资源的哈希值取 8 位；<code>[ext]</code> 表示资源打包之前的扩展名。</p><h1 id="处理音视频等资源"><a href="#处理音视频等资源" class="headerlink" title="处理音视频等资源"></a>处理音视频等资源</h1><p>与处理图片资源类似，我们使用 <code>type</code> 属性而非 <code>use</code> 属性指定处理包括字体图标、音乐、视频资源的方式。</p><p>字体图标可以在<a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a> 等网站中下载</p><p>但是与处理图片资源不一样的地方是，我们需要将这些资源的 <code>type</code> 属性指定为 <code>asset/resource</code>，而非 <code>asset</code>。不过，我们同样可以在 <code>generator.filename</code> 属性中指定输出路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?|map4|map3|avi)$/</span>,</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;asset./resource&#x27;</span>,</span><br><span class="line"><span class="attr">generator</span>: &#123;</span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;media/[hash:8][ext]&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  asset 在小于某个文件大小会转换成 base 64</li><li>  而字体图标等不需要转换，只需要原封不动输出，即使用 asset/resource</li></ul><h1 id="处理-JS-资源"><a href="#处理-JS-资源" class="headerlink" title="处理 JS 资源"></a>处理 JS 资源</h1><p>Webpack 对 JS 的处理十分有限，有许多语法不能进行编译，Webpack 可以帮助做一些兼容性处理。</p><p>除此之外，开发团队对代码格式可能会有一定的要求，但是我们并不能总是用肉眼与检查代码格式，应该使用专业的工具来检测。</p><p>针对以上两点，可以在 Webpack 中分别引入 Babel 与 ESLint 来进行处理。</p><p>在实际的开发中，我们首先使用 ESLint 来检测代码格式，再通过 Babel 做代码的兼容性处理。</p><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p>ESLint 可以帮助我们检测 JS 和 JSX 语法，并配置各项功能。使用 ESLint 的核心在于书写 ESLint 配置文件，向其中添加各种规则进行约束，这样当我们运行 ESLint 时就会根据我们指定的规则对代码进行检测。</p><h3 id="ESLint-配置文件"><a href="#ESLint-配置文件" class="headerlink" title="ESLint 配置文件"></a>ESLint 配置文件</h3><p>ESLint 的配置文件有很多写法：</p><ol><li><p><code>.eslintrc.*</code> 类型：在项目根目录新建这种类型的文件，可以使用下面三种：</p><ul><li><p><code>.eslintrc</code></p></li><li><p><code>.eslintrc.js</code></p></li><li><p><code>.eslintrc.json</code></p></li></ul></li></ol><p>这三种的区别在于配置的书写格式不一样。</p><ol><li>在 <code>package.json</code> 中配置 <code>eslintConfig</code></li></ol><p>当我们运行时，ESLint 会查找并自动读取它们，因此上面的这些配置文件只需要存在一个。</p><h3 id="ESLint-基本配置"><a href="#ESLint-基本配置" class="headerlink" title="ESLint 基本配置"></a>ESLint 基本配置</h3><p>以编写 <code>.eslintrc.js</code> 配置文件为例。</p><p>基本的 ESLint 规则包括解析选项 <code>parserOptions</code>、检查规则 <code>rules</code>、继承规则 <code>extends</code>、环境变量 <code>env</code>，其他规则详见 <a href="https://eslint.org/docs/latest/user-guide/configuring">官方文档</a>。</p><p>如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">parserOptions</span>: &#123;&#125;,</span><br><span class="line"><span class="attr">rules</span>: &#123;&#125;,</span><br><span class="line"><span class="attr">extends</span>: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parserOptions"><a href="#parserOptions" class="headerlink" title="parserOptions"></a>parserOptions</h4><p>基本的解析选项包括指定 ES 语法版本 <code>ecmaVersion</code>、ES 模块化类型 <code>sourceType</code>、ES 其他特性 <code>ecmaFeatures</code>（比如是否使用 jsx）。</p><p>如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">ecmaVersion</span>: <span class="number">6</span>,  <span class="comment">//ES 语法版本</span></span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>,  <span class="variable constant_">ES</span> 模块化</span><br><span class="line">        <span class="attr">ecmaFeatures</span>: &#123; 其他特性</span><br><span class="line">            <span class="attr">jsx</span>: <span class="literal">true</span> 如果是 react项目，需要开启 jsx 语法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h4><p>对于具体规则 <code>rules</code>，我们需要着重关注规则的开启程度：</p><ol><li><code>off</code> 或 <code>0</code>：表示关闭此条规则；</li><li><code>warn</code> 或 <code>1</code>：表示开启此条规则，但是使用警告提醒，这不会导致程序中断退出。</li><li><code>error</code> 或 <code>2</code>：表示开启此条规则，但是使用错误提醒，当此条规则触发时，程序将会中断退出。</li></ol><p>具体规则 <code>rules</code> 包含的内容很多，可以参见 <a href="https://eslint.org/docs/latest/rules/">官方文档</a>，此处列举几例：</p><ul><li>  使用分号 <code>semi</code>；</li><li>  禁止与 <code>-0</code> 进行比较 <code>no-compare-neg-zero</code>。</li></ul><p>如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line"><span class="attr">semi</span>: <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;no-compare-neg-zero&#x27;</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><p>在实际开发中，一条一条指定 <code>rules</code> 效率很低，所以通常会选择继承现有的规则。如 React Cli 官方的规则：<code>react-app</code>。</p><p>如下代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    extends: [&#x27;react-app&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>我们主要需要指定项目代码中是否可以使用 Node 以及浏览器中的全局变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    env: &#123;</span><br><span class="line">        node: true,</span><br><span class="line">        browser: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-Webpack-中使用-ESLint"><a href="#在-Webpack-中使用-ESLint" class="headerlink" title="在 Webpack 中使用 ESLint"></a>在 Webpack 中使用 ESLint</h3><p>首先，下载依赖 <code>eslint</code> 与 <code>eslint-webpack-plugin</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint eslint-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>然后，在项目根目录新建配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Code # 根目录（所有指令都必须在这个目录下运行）</span><br><span class="line">|-- node_modules</span><br><span class="line">|-- public # 静态资源目录</span><br><span class="line">|--src # 源码目录</span><br><span class="line">|-- package.json</span><br><span class="line">|-- webpack.config.js</span><br><span class="line">|-- .eslintrc.js</span><br></pre></td></tr></table></figure><p>再编写简单的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    extends: [&#x27;eslint:recommended&#x27;],</span><br><span class="line">    env: &#123;</span><br><span class="line">        node: true,</span><br><span class="line">        browser: true</span><br><span class="line">    &#125;,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        ecmaVersion: 6,</span><br><span class="line">        sourceType: &#x27;module&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    rules: &#123;</span><br><span class="line">        &#x27;semi&#x27;: &#x27;warn&#x27;,</span><br><span class="line">        &#x27;no-var&#x27;: &#x27;error&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们在 Webpack 配置文件中指定 ESLint 插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new ESLintWebpackPlugin(options)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>options</code> 是规范的具体选项，包括指定需要检查的根目录 <code>context</code>、需要检查的文件类型 <code>extension</code> 等等。详细内容可以参见 <a href="https://webpack.js.org/plugins/eslint-webpack-plugin/#root">官网</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">const options = &#123;</span><br><span class="line">//检查哪些文件</span><br><span class="line">    context: path.resolve(__dirname, &#x27;src&#x27;),</span><br><span class="line">    extensions: &#x27;jsx&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new ESLintWebpackPlugin(options)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们进行上述的配置后，运行命令 <code>npx webpack</code> 时，就会根据编辑的 ESLint 配置，对代码进行规范检查了。要注意因为配置了<code>extensions: &#39;jsx&#39;</code>，所以只会检查 src 下面的 jsx 文件</p><h3 id="不进行-ESLint-检查"><a href="#不进行-ESLint-检查" class="headerlink" title="不进行 ESLint 检查"></a>不进行 ESLint 检查</h3><p>如果有些文件不需要通过 ESLint 检查，那么我们只需要在根目录添加 <code>.eslintignore</code> 即可，<code>.eslintignore</code> 的语法格式与 <code>.gitignore</code> 一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Code # 根目录（所有指令都必须在这个目录下运行）</span><br><span class="line">|-- node_modules</span><br><span class="line">|-- public # 静态资源目录</span><br><span class="line">|--src # 源码目录</span><br><span class="line">|-- package.json</span><br><span class="line">|-- webpack.config.js</span><br><span class="line">|-- .eslintignore</span><br><span class="line">|-- .eslintrc.js</span><br></pre></td></tr></table></figure><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Babel 是 JavaScript 编译器，主要用于将使用 ES6 语法编写的语法转换为向后兼容的 JavaScript 语法</p><h3 id="Babel-的配置文件"><a href="#Babel-的配置文件" class="headerlink" title="Babel 的配置文件"></a>Babel 的配置文件</h3><p>Babel 的配置文件有很多写法：</p><ol><li><p><code>babel.config.*</code> 类型：在项目根目录新建这种类型的文件，可以使用下面两种：</p><ul><li><p><code>babel.config.js</code></p></li><li><p><code>babel.config.json</code></p></li></ul></li><li><p><code>.babelrc.*</code> 类型：在项目根目录新建这种类型的文件，可以使用下面三种：</p><ul><li><p><code>.babelrc</code></p></li><li><p><code>.babelrc.js</code></p></li><li><p><code>.babelrc.json</code></p></li></ul></li><li><p>在 <code>package.json</code> 中配置 <code>babel</code></p></li></ol><p>当我们运行时，Babel 会查找并自动读取它们，因此上面的这些配置文件只需要存在一个。</p><h3 id="在-Webpack-中使用"><a href="#在-Webpack-中使用" class="headerlink" title="在 Webpack 中使用"></a>在 Webpack 中使用</h3><p>以编写 <code>babel.config.js</code> 配置文件为例。</p><p>首先，下载依赖 <code>babel</code>、<code>babel-loader</code>、<code>@babel/core</code>、<code>@babel/preset-env</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader @babel/core @babel/preset-env -D</span><br></pre></td></tr></table></figure><p>然后，在项目根目录创建 <code>bable.config.js</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Code # 根目录（所有指令都必须在这个目录下运行）</span><br><span class="line">|-- node_modules</span><br><span class="line">|-- public # 静态资源目录</span><br><span class="line">|--src # 源码目录</span><br><span class="line">|-- package.json</span><br><span class="line">|-- webpack.config.js</span><br><span class="line">|-- babel.config.js</span><br><span class="line">|-- .eslintrc.js</span><br></pre></td></tr></table></figure><p>Babel 配置文件的一个基本属性是预设 <code>presets</code>。<code>presets</code> 可以理解为 Babel 的插件，用于扩展 Babel 功能。常见的预设主要有下面三个：</p><ul><li>  <code>@babel/preset-env</code>：智能预设，允许使用最新的 JavaScript。</li><li>  <code>@babel/preset-react</code>：编译 React JSX 语法。</li><li>  <code>@babel/preset-typescript</code>：编译 TypeScript 语法。</li></ul><p>此处我们直接指定 <code>@babel/preset-env</code> 即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    presets: [&#x27;@babel/preset-env&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在 Webpack 配置文件中使用 <code>babel-loader</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.js$/,</span><br><span class="line">                exclude: /node_modules/, // node_modules 目录中的文件不进行处理,</span><br><span class="line">                loader: &#x27;babel-loader&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="处理-HTML-资源"><a href="#处理-HTML-资源" class="headerlink" title="处理 HTML 资源"></a>处理 HTML 资源</h1><p>处理 HTML 资源的一个基本需求在于——如果我们不处理 HTML 文件，那么我们每次都需要手动引入打包后的 JS 以及其他资源；而如果连同 HTML 文件一起处理，那么将会自动载入打包后的其他资源，而不用我们再来手动引入。</p><p>我们使用 <code>html-webpack-plugin</code> 插件来处理 HTML 资源。</p><p>首先，下载依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>然后，我们在 Webpack 的配置文件中的 <code>plugins</code> 属性中使用插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: path.resolve(__dirname, &#x27;public/index.html&#x27;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>template</code> 属性表示的是以某个 HTML 文件作为模板进行打包。打包后的 HTML 文件具有以下两个特点：</p><ol><li>内容与模板的 HTML 文件。</li><li>自动引入打包后的 JS 等资源。</li></ol><p>最后，我们需要删除原本 HTML 文件中手动导入的打包后的资源。</p><h1 id="搭建-dev-server"><a href="#搭建-dev-server" class="headerlink" title="搭建 dev-server"></a>搭建 dev-server</h1><p>每次修改完代码，我们都需要重新执行命令 <code>npx webpack</code>。使用 <code>dev-server</code> 可以帮助我们在运行状态下自动重新打包。</p><h2 id="下载依赖-1"><a href="#下载依赖-1" class="headerlink" title="下载依赖"></a>下载依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server -D</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: &#x27;localhost&#x27;, // 启动服务器的域名,</span><br><span class="line">        port: &#x27;3000&#x27;, // 启动服务器的端口号,</span><br><span class="line">        open: true // 自动打开浏览器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>之后我们不再需要使用 <code>npx webpack</code> 来单次运行服务器了，直接使用 <code>npx webpack serve</code> 即可。</p><p>要注意的是，我们使用 <code>dev-server</code> 开发者服务器，并不会实际将打包后的资源输出出来，而是直接在内存中编译打包。</p><h1 id="生产模式介绍"><a href="#生产模式介绍" class="headerlink" title="生产模式介绍"></a>生产模式介绍</h1><p>生产模式指的是当代码开发完成后，需要部署上线的环境。对于生产模式，我们主要考虑对打包后的代码进行优化，提升性能。</p><p>优化主要从两个角度出发：</p><ol><li>优化代码运行性能；</li><li>优化代码打包速度。</li></ol><h2 id="配置拆分"><a href="#配置拆分" class="headerlink" title="配置拆分"></a>配置拆分</h2><p>原本我们仅有 <code>webpack.config.js</code> 这一个 Webpack 配置文件，但是我们需要对开发环境与生产环境做出不同的 Webpack 配置。我们可以考虑将开发环境与生产环境的 Webpack 配置文件进行拆分，得到 <code>webpack.dev.js</code> 与 <code>webpack.prod.js</code> 这两个配置文件，然后我们重新定义脚本：当运行开发环境时，我们就调用 <code>config/webpack.dev.js</code> 配置文件；当运行生产环境时，我们就调用 <code>config/webpack.prod.js</code> 配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Code # 根目录（所有指令都必须在这个目录下运行）</span><br><span class="line">|-- config</span><br><span class="line">|-- webpack.dev.js</span><br><span class="line">|-- webpack.prod.js</span><br><span class="line">|-- node_modules</span><br><span class="line">|-- public</span><br><span class="line">|--src</span><br><span class="line">|-- package.json</span><br><span class="line">|-- babel.config.js</span><br><span class="line">|-- .eslintignore</span><br><span class="line">|-- .eslintrc.js</span><br></pre></td></tr></table></figure><h2 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h2><ul><li>  <code>webpack.dev.js</code></li></ul><p>拆分配置文件后，生产模式下的配置主要有以下几点需要调整：</p><ol><li>由于配置文件被拆分放入了 <code>config</code> 目录，因此我们需要对开发环境的配置文件当中出现的目录层次进行更改；</li><li>由于开发环境不需要输出文件，因此可以将 <code>output</code> 置为空。</li></ol><ul><li>  <code>webpack.prod.js</code></li></ul><p>同样，生产环境的配置也有一些地方需要修改：</p><ol><li>调整目录层次；</li><li>不再需要开发服务器 <code>dev-server</code>；</li><li>将 <code>mode</code> 属性更改为 <code>production</code>。</li></ol><h1 id="处理-CSS-资源-1"><a href="#处理-CSS-资源-1" class="headerlink" title="处理 CSS 资源"></a>处理 CSS 资源</h1><p>在前面的小节中，我们处理了样式资源，但是这只是将样式资源能够成功进行打包。而在生产环境中，我们则需要额外关注项目性能等等方面，因此需要在生产环境下，单独对 CSS 资源进行处理。</p><p>对 CSS 资源的处理主要包括三点：</p><ol><li>将 CSS 资源提取为单独文件；</li></ol><p>在前面的小节中，我们通过 <code>style-loader</code> 这个 <code>loader</code> 将处理好的样式资源直接导入 JS 输出文件中。当 JS 文件加载时，会创建 <code>&lt;style&gt;</code> 标签生成样式。</p><p>但是对于网站而言，这样的处理方式容易出现闪屏现象，用户体验下降。如果想要优化这一点，可以将 CSS 资源提取为单独的文件，最后通过 <code>&lt;link&gt;</code> 标签加载。</p><ol start="2"><li>对 CSS 资源进行兼容性处理；</li></ol><p>因为许多浏览器版本与兼容的原因，很多时候我们需要将 CSS 资源进行兼容性处理。</p><ol start="3"><li>压缩 CSS 资源。</li></ol><p>生产环境需要将最后打包生成的文件投入真正的使用中，如果文件太大，容易造成网络堵塞等等情况。压缩 CSS 资源则可以减小打包得到 CSS 资源体积，从而提升性能。</p><h2 id="将-CSS-资源提取为单独文件"><a href="#将-CSS-资源提取为单独文件" class="headerlink" title="将 CSS 资源提取为单独文件"></a>将 CSS 资源提取为单独文件</h2><p>原本我们通过 <code>style-loader</code> 对 CSS 资源进行处理，现在我们需要另外一个 <code>loader</code>。但是这个 <code>loader</code> 与 <code>style-loader</code> 不同，并不是直接下载，而是需要下载 <code>mini-css-extract-plugin</code> 这个插件，然后从这个插件中导入 <code>loader</code>。当然，我们也需要在 <code>plugins</code> 中对这个插件进行配置。</p><p>首先，我们下载插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><p>然后，我们修改配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    &#x27;css-loader&#x27;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    &#x27;css-loader&#x27;,</span><br><span class="line">                    &#x27;less-loader&#x27;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.s[ac]ss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    &#x27;css-loader&#x27;,</span><br><span class="line">                    &#x27;sass-loader&#x27;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: &#x27;css/index.css&#x27;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    mode: &#x27;production&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们将 CSS 资源提取为了单独的文件，因此我们同样可以传入选项参数指定输出路径。</p><h2 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h2><p>我们使用 <code>postcss-loader</code> 这个依赖处理 CSS 兼容性问题。但是除此之外，我们需要使用 <code>loader</code> 中的一个插件 <code>postcss-preset-env</code> 来协助处理。同时，<code>postcss-loader</code> 依赖 <code>postcss</code>，因此我们一共需要下载三个依赖才能处理 CSS 兼容性问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader postcss postcss-preset-env -D</span><br></pre></td></tr></table></figure><p>接下来，修改配置文件：</p><blockquote><p>值得注意的是，当我们将其他资源转化为 CSS 资源后，我们才对 CSS 资源进行兼容性处理，而不是直接对其他资源如 Less 资源进行兼容性处理。因此，<code>use</code> 属性中各个元素的排列顺序很重要。即，我们在 需要写在 css-loader 的后面（因为是逆序，所以实际上顺序是前面）, 但是需要写在 less-loader 的前面</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    &#x27;css-loader&#x27;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &#x27;postcss-loader&#x27;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            postcssOptions: &#123;</span><br><span class="line">                                plugins: [</span><br><span class="line">                                    &#x27;postcss-preset-env&#x27;</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    &#x27;css-loader&#x27;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &#x27;postcss-loader&#x27;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            postcssOptions: &#123;</span><br><span class="line">                                plugins: [</span><br><span class="line">                                    &#x27;postcss-preset-env&#x27;</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#x27;less-loader&#x27;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.s[ac]ss$/,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    &#x27;css-loader&#x27;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &#x27;postcss-loader&#x27;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            postcssOptions: &#123;</span><br><span class="line">                                plugins: [</span><br><span class="line">                                    &#x27;postcss-preset-env&#x27;</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#x27;sass-loader&#x27;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>postcss-loader</code> 可以处理大部分的兼容性问题，但是我们也可以在 <code>package.json</code> 中指定配置使用的浏览器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;browserslist&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;last 2 version&quot;</span>, <span class="comment">//代表所有浏览器</span></span><br><span class="line">        <span class="string">&quot;&gt; 1%&quot;</span>,  覆盖 <span class="number">99</span>% 的浏览器</span><br><span class="line">        <span class="string">&quot;not dead&quot;</span>  有些浏览器版本已经死了就不要了</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">上面的是取交集</span><br></pre></td></tr></table></figure><p>详细的 <code>browserslist</code> 说明可以参见 <a href="https://github.com/browserslist/browserslist">官方文档</a>。</p><h2 id="封装-loader"><a href="#封装-loader" class="headerlink" title="封装 loader"></a>封装 loader</h2><p>此时已经可以发现，处理 CSS 资源的 <code>rules</code> 出现了大量的重复内容。为了让代码可读性更强、更容易复用，我们可以将公共的这部分封装为一个方法，将差异性的内容作为参数传递进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">const getStyleLoader = (para) =&gt; &#123;</span><br><span class="line">    return [</span><br><span class="line">        MiniCssExtractPlugin.loader,</span><br><span class="line">        &#x27;css-loader&#x27;,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: &#x27;postcss-loader&#x27;,</span><br><span class="line">            options: &#123;</span><br><span class="line">                postcssOptions: &#123;</span><br><span class="line">                    plugins: [</span><br><span class="line">                        &#x27;postcss-preset-env&#x27;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        para</span><br><span class="line">    ].filter(Boolean) //传入 boolean 会把 undefined 的值过滤掉</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: getStyleLoader()</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                use: getStyleLoader(&#x27;less-loader&#x27;)</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.s[ac]ss$/,</span><br><span class="line">                use: getStyleLoader(&#x27;sass-loader&#x27;)</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS-压缩"><a href="#CSS-压缩" class="headerlink" title="CSS 压缩"></a>CSS 压缩</h2><p>我们使用 <code>css-minimizer-webpack-plugin</code> 这个插件进行 CSS 压缩。</p><p>首先下载依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-minimizer-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>然后我们进行插件的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const CssMinimizerWebpackPlugin = require(&#x27;css-minimizer-webpack-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new CssMinimizerWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>显然，JS 与 HTML 资源在生产模式下也需要压缩，只是在生产模式下这两种类型的文件会自动压缩，因此不需要进行额外的配置。</p></blockquote><h1 id="生产模式总结"><a href="#生产模式总结" class="headerlink" title="生产模式总结"></a>生产模式总结</h1><p>此时，基本的生产模式配置已经实现，参考如下：</p><ul><li>  <code>config.webpack.prod.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ESLintWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;eslint-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line"><span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src&#x27;</span>), <span class="comment">//检查哪里的代码</span></span><br><span class="line"><span class="attr">extensions</span>: <span class="string">&#x27;js&#x27;</span>, <span class="comment">//检查什么类型的文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getStyleLoader</span> = (<span class="params">para</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line"><span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line"><span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line"><span class="attr">options</span>: &#123;</span><br><span class="line"><span class="attr">postcssOptions</span>: &#123;</span><br><span class="line"><span class="attr">plugins</span>: [<span class="string">&#x27;postcss-preset-env&#x27;</span>],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">para,</span><br><span class="line">].<span class="title function_">filter</span>(<span class="title class_">Boolean</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>, <span class="comment">//从哪开始</span></span><br><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line"><span class="comment">//输出到哪</span></span><br><span class="line"><span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>), <span class="comment">//输出路径</span></span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;js/index.js&#x27;</span>, <span class="comment">//指定输出文件相对于 `path` 的目录</span></span><br><span class="line"><span class="attr">clean</span>: <span class="literal">true</span>, <span class="comment">//是否清除上次打包的文件</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line"><span class="attr">use</span>: <span class="title function_">getStyleLoader</span>(),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line"><span class="attr">use</span>: <span class="title function_">getStyleLoader</span>(<span class="string">&#x27;less-loader&#x27;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line"><span class="attr">use</span>: <span class="title function_">getStyleLoader</span>(<span class="string">&#x27;sass-loader&#x27;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line"><span class="attr">parser</span>: &#123;</span><br><span class="line"><span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line"><span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">generator</span>: &#123;</span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;imgs/[hash:8][ext]&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line"><span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line"><span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(options), <span class="comment">//配置 ESLint</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line"><span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../public/index.html&#x27;</span>),</span><br><span class="line">&#125;), <span class="comment">//配置 html, 让他自动载入打包后的其他资源</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;css/index.css&#x27;</span>,</span><br><span class="line">&#125;), <span class="comment">//将css单独提出出来</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">CssMinimizerWebpackPlugin</span>(), <span class="comment">//压缩css</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>package.json</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...,</span><br><span class="line">    <span class="string">&quot;browserslist&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;last 2 version&quot;</span>,  <span class="comment">//全部的浏览器</span></span><br><span class="line">        <span class="string">&quot;&gt; 1%&quot;</span>,   <span class="comment">//覆盖 99%</span></span><br><span class="line">        <span class="string">&quot;not dead&quot;</span>  <span class="comment">//已经过时的浏览器就不要了</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="提升开发体验"><a href="#提升开发体验" class="headerlink" title="提升开发体验"></a>提升开发体验</h1><h2 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h2><h3 id="SourceMap"><a href="#SourceMap" class="headerlink" title="SourceMap"></a>SourceMap</h3><p>SourceMap（源代码映射）是一个用来生成源代码与构建后代码一一映射的文件的方案。</p><p>它会生成 map 文件，里面包含源代码和构建后代码每一行、每一列的映射关系。当构建后代码出错了，会通过这个 map 文件，从构建后代码出错位置找到映射后源代码出错位置，从而让浏览器提示源代码文件出错位置，帮助我们更快的找到错误根源。</p><p>SourceMap 的值有许多，但实际开发时我们只需要关注两种情况：</p><ul><li>开发模式：<code>cheap-module-source-map</code><ul><li>  优点：打包编译速度快，只包含行映射</li><li>  缺点：没有列映射</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &#x27;development&#x27;,</span><br><span class="line">    devtool: &#x27;cheap-module-source-map&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>生产模式：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source-map</span><br></pre></td></tr></table></figure><ul><li>  优点：包含行/列映射</li><li>  缺点：打包编译速度更慢</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &#x27;production&#x27;,</span><br><span class="line">    devtool: &#x27;source-map&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="提升打包构建速度"><a href="#提升打包构建速度" class="headerlink" title="提升打包构建速度"></a>提升打包构建速度</h1><h2 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h2><p>开发过程中，可能只修改了一部分代码，但是 Webpack 默认会将所有模块全部重新打包编译，导致效率降低；如果能实现当修改某个模块代码时，就只有这个模块代码需要重新打包编译，其他模块不变，这样效率就会变高。</p><p>Hot Module Replacement（HMR/热模块替换）可以实现在程序运行中，替换、添加或删除模块，而无需重新加载整个页面。默认就是开启的</p><ul><li>  <code>webpack.dev.js</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: &#x27;localhost&#x27;, // 启动服务器的域名,</span><br><span class="line">        port: &#x27;3000&#x27;, // 启动服务器的端口号,</span><br><span class="line">        open: true, // 自动打开浏览器</span><br><span class="line">        hot: true // 开启 HMR，默认值就为 true</span><br><span class="line">    &#125;,</span><br><span class="line">    // 模式</span><br><span class="line">    mode: &#x27;development&#x27;,</span><br><span class="line">    devtool: &#x27;cheap-module-source-map&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，CSS 经过 <code>style-loader</code> 处理，已经具备 HMR 功能。但是此时 JS 资源并不具备 HMR 功能。</p><p>如果想要在 JS 中实现 HMR 功能，需要手动进行判断是否支持：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import sum from &#x27;./js/sum&#x27;</span><br><span class="line">import count from &#x27;./js/count&#x27;</span><br><span class="line">import &#x27;./css/index.css&#x27;</span><br><span class="line">import &#x27;./less/index.less&#x27;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2, 3, 4))</span><br><span class="line">console.log(count(3, 1))</span><br><span class="line"></span><br><span class="line">if (module.hot) &#123; // 判断是否支持 HMR 功能</span><br><span class="line">    module.hot.accept(&#x27;./js/sum&#x27;)</span><br><span class="line">    module.hot.accept(&#x27;./js/count&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在实际开发中，像上面这样手动指定会非常麻烦，因此实际开发我们会使用其他 loader 来解决，如 <a href="https://github.com/gaearon/react-hot-loader">react-hot-loader</a>。</p><h2 id="OneOf"><a href="#OneOf" class="headerlink" title="OneOf"></a>OneOf</h2><p><code>OneOf</code> 是规则数组，用于表示当规则匹配时，只使用第一个匹配规则：</p><ul><li>  <code>webpack.dev.js</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                // 每个文件只能被其中一个 loader 处理</span><br><span class="line">                oneOf: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.css$/,</span><br><span class="line">                        use: [</span><br><span class="line">                            // 从后往前执行，先执行 css-loader，再执行 style-loader</span><br><span class="line">                            &#x27;style-loader&#x27;,</span><br><span class="line">                            &#x27;css-loader&#x27;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.less$/,</span><br><span class="line">                        use: [</span><br><span class="line">                            &#x27;style-loader&#x27;,</span><br><span class="line">                            &#x27;css-loader&#x27;,</span><br><span class="line">                            &#x27;less-loader&#x27;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.s[ac]ss$/,</span><br><span class="line">                        use: [</span><br><span class="line">                            &#x27;style-loader&#x27;,</span><br><span class="line">                            &#x27;css-loader&#x27;,</span><br><span class="line">                            &#x27;sass-loader&#x27;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.(png|jpe?g|gif|webp)$/,</span><br><span class="line">                        type: &quot;asset&quot;,</span><br><span class="line">                        generator: &#123;</span><br><span class="line">                            filename: &#x27;images/[hash][ext][query]&#x27;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        parser: &#123;</span><br><span class="line">                            dataUrlCondition: &#123;</span><br><span class="line">                                maxSize: 16 * 1024 // 16 kb</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.js$/,</span><br><span class="line">                        exclude: /node_modules/, // node_modules 目录中的文件不进行处理,</span><br><span class="line">                        loader: &#x27;babel-loader&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: &#x27;development&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>webpack.prod.js</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                oneOf: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.css$/,</span><br><span class="line">                        use: getStyleLoader()</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.less$/,</span><br><span class="line">                        use: getStyleLoader(&#x27;less-loader&#x27;)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.s[ac]ss$/,</span><br><span class="line">                        use: getStyleLoader(&#x27;sass-loader&#x27;)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.(png|jpe?g|gif|webp)$/,</span><br><span class="line">                        type: &quot;asset&quot;,</span><br><span class="line">                        generator: &#123;</span><br><span class="line">                            filename: &#x27;images/[hash][ext][query]&#x27;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        parser: &#123;</span><br><span class="line">                            dataUrlCondition: &#123;</span><br><span class="line">                                maxSize: 16 * 1024 // 16 kb</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.js$/,</span><br><span class="line">                        exclude: /node_modules/, // node_modules 目录中的文件不进行处理,</span><br><span class="line">                        loader: &#x27;babel-loader&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    // 模式</span><br><span class="line">    mode: &#x27;production&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InClude-Exclude"><a href="#InClude-Exclude" class="headerlink" title="InClude / Exclude"></a>InClude / Exclude</h2><ul><li>  <code>include</code></li></ul><p><code>include</code> 用于指定该规则包含哪些目录的文件。</p><ul><li>  <code>exclude</code></li></ul><p><code>exclude</code> 用于排除哪些目录。</p><p>要注意的是，对于一个匹配规则，<code>include</code> 关键字与 <code>exclude</code> 关键字只能存在一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                // 每个文件只能被其中一个 loader 处理</span><br><span class="line">                oneOf: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        test: /\.js$/,</span><br><span class="line">                        exclude: /node_modules/,</span><br><span class="line">                        // node_modules 目录中的文件不进行处理, 其他文件都处理</span><br><span class="line">                        // include: path.resolve(__dirname, &#x27;../src&#x27;),</span><br><span class="line">                        // 只处理 src 目录下的文件，其他文件不处理</span><br><span class="line">                        loader: &#x27;babel-loader&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。</p><p>我们可以缓存之前的 Eslint 检查 和 Babel 编译结果，这样第二次打包时速度就会更快了。</p><p>对 Eslint 检查 和 Babel 编译结果进行缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ESLintWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;eslint-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line"><span class="attr">path</span>: <span class="literal">undefined</span>, <span class="comment">// 开发模式没有输出，不需要指定输出目录</span></span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;static/js/main.js&#x27;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line"><span class="comment">// clean: true, // 开发模式没有输出，不需要清空输出结果</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">oneOf</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line"><span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line"><span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line"><span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line"><span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line"><span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;stylus-loader&#x27;</span>],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line"><span class="attr">parser</span>: &#123;</span><br><span class="line"><span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line"><span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">generator</span>: &#123;</span><br><span class="line"><span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line"><span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line"><span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line"><span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line"><span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;static/imgs/[hash:8][ext][query]&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line"><span class="attr">generator</span>: &#123;</span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;static/media/[hash:8][ext][query]&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line"><span class="comment">// exclude: /node_modules/, // 排除node_modules代码不编译</span></span><br><span class="line"><span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src&#x27;</span>), <span class="comment">// 也可以用包含</span></span><br><span class="line"><span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line"><span class="attr">options</span>: &#123;</span><br><span class="line"><span class="attr">cacheDirectory</span>: <span class="literal">true</span>, <span class="comment">// 开启babel编译缓存</span></span><br><span class="line"><span class="attr">cacheCompression</span>: <span class="literal">false</span>, <span class="comment">// 缓存文件不要压缩</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line"><span class="comment">// 指定检查文件的根目录</span></span><br><span class="line"><span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line"><span class="attr">exclude</span>: <span class="string">&#x27;node_modules&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"><span class="attr">cache</span>: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line"><span class="comment">// 缓存目录</span></span><br><span class="line"><span class="attr">cacheLocation</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">__dirname,</span><br><span class="line"><span class="string">&#x27;../node_modules/.cache/.eslintcache&#x27;</span></span><br><span class="line">),</span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line"><span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line"><span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line"><span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../public/index.html&#x27;</span>),</span><br><span class="line">&#125;),</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 开发服务器</span></span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line"><span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>, <span class="comment">// 启动服务器域名</span></span><br><span class="line"><span class="attr">port</span>: <span class="string">&#x27;3000&#x27;</span>, <span class="comment">// 启动服务器端口号</span></span><br><span class="line"><span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 是否自动打开浏览器</span></span><br><span class="line"><span class="attr">hot</span>: <span class="literal">true</span>, <span class="comment">// 开启HMR功能</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line"><span class="attr">devtool</span>: <span class="string">&#x27;cheap-module-source-map&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Thead"><a href="#Thead" class="headerlink" title="Thead"></a>Thead</h2><p>当项目越来越庞大时，打包速度越来越慢，甚至于需要一个下午才能打包出来代码。这个速度是比较慢的。</p><p>我们想要继续提升打包速度，其实就是要提升 js 的打包速度，因为其他文件都比较少。</p><p>而对 js 文件处理主要就是 eslint 、babel、Terser 三个工具，所以我们要提升它们的运行速度。</p><p>我们可以开启多进程同时处理 js 文件，这样速度就比之前的单进程打包更快了。</p><p>多进程打包：开启电脑的多个进程同时干一件事，速度更快。</p><p><strong>需要注意：请仅在特别耗时的操作中使用，因为每个进程启动就有大约为 600ms 左右开销。</strong></p><p>怎么用</p><p>我们启动进程的数量就是我们 CPU 的核数。</p><ol><li>如何获取 CPU 的核数，因为每个电脑都不一样。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs核心模块，直接使用</span></span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"><span class="comment">// cpu核数</span></span><br><span class="line"><span class="keyword">const</span> threads = os.<span class="title function_">cpus</span>().<span class="property">length</span></span><br></pre></td></tr></table></figure><ol start="2"><li>下载包</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i thread-loader -D</span><br></pre></td></tr></table></figure><ol start="3"><li>使用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ESLintWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;eslint-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpu核数</span></span><br><span class="line"><span class="keyword">const</span> threads = os.<span class="title function_">cpus</span>().<span class="property">length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取处理样式的Loaders</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getStyleLoaders</span> = (<span class="params">preProcessor</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line"><span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line"><span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line"><span class="attr">options</span>: &#123;</span><br><span class="line"><span class="attr">postcssOptions</span>: &#123;</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line"><span class="string">&#x27;postcss-preset-env&#x27;</span>, <span class="comment">// 能解决大多数样式兼容性问题</span></span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">preProcessor,</span><br><span class="line">].<span class="title function_">filter</span>(<span class="title class_">Boolean</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line"><span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>), <span class="comment">// 生产模式需要输出</span></span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;static/js/main.js&#x27;</span>, <span class="comment">// 将 js 文件输出到 static/js 目录中</span></span><br><span class="line"><span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">oneOf</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 用来匹配 .css 结尾的文件</span></span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line"><span class="comment">// use 数组里面 Loader 执行顺序是从右到左</span></span><br><span class="line"><span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line"><span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&#x27;less-loader&#x27;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line"><span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&#x27;sass-loader&#x27;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line"><span class="attr">use</span>: <span class="title function_">getStyleLoaders</span>(<span class="string">&#x27;stylus-loader&#x27;</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;asset&#x27;</span>,</span><br><span class="line"><span class="attr">parser</span>: &#123;</span><br><span class="line"><span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line"><span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb的图片会被base64处理</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">generator</span>: &#123;</span><br><span class="line"><span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line"><span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line"><span class="comment">// [hash:8]: hash值取8位</span></span><br><span class="line"><span class="comment">// [ext]: 使用之前的文件扩展名</span></span><br><span class="line"><span class="comment">// [query]: 添加之前的query参数</span></span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;static/imgs/[hash:8][ext][query]&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line"><span class="attr">generator</span>: &#123;</span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;static/media/[hash:8][ext][query]&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line"><span class="comment">// exclude: /node_modules/, // 排除node_modules代码不编译</span></span><br><span class="line"><span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src&#x27;</span>), <span class="comment">// 也可以用包含</span></span><br><span class="line"><span class="attr">use</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">loader</span>: <span class="string">&#x27;thread-loader&#x27;</span>, <span class="comment">// 开启多进程</span></span><br><span class="line"><span class="attr">options</span>: &#123;</span><br><span class="line"><span class="attr">workers</span>: threads, <span class="comment">// 数量</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line"><span class="attr">options</span>: &#123;</span><br><span class="line"><span class="attr">cacheDirectory</span>: <span class="literal">true</span>, <span class="comment">// 开启babel编译缓存</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ESLintWebpackPlugin</span>(&#123;</span><br><span class="line"><span class="comment">// 指定检查文件的根目录</span></span><br><span class="line"><span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line"><span class="attr">exclude</span>: <span class="string">&#x27;node_modules&#x27;</span>, <span class="comment">// 默认值</span></span><br><span class="line"><span class="attr">cache</span>: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line"><span class="comment">// 缓存目录</span></span><br><span class="line"><span class="attr">cacheLocation</span>: path.<span class="title function_">resolve</span>(</span><br><span class="line">__dirname,</span><br><span class="line"><span class="string">&#x27;../node_modules/.cache/.eslintcache&#x27;</span></span><br><span class="line">),</span><br><span class="line">threads, <span class="comment">// 开启多进程</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line"><span class="comment">// 以 public/index.html 为模板创建文件</span></span><br><span class="line"><span class="comment">// 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</span></span><br><span class="line"><span class="attr">template</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../public/index.html&#x27;</span>),</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 提取css成单独文件</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line"><span class="comment">// 定义输出文件名和目录</span></span><br><span class="line"><span class="attr">filename</span>: <span class="string">&#x27;static/css/main.css&#x27;</span>,</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// css压缩</span></span><br><span class="line"><span class="comment">// new CssMinimizerPlugin(),</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line"><span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">minimizer</span>: [</span><br><span class="line"><span class="comment">// css压缩也可以写到optimization.minimizer里面，效果一样的</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>(),</span><br><span class="line"><span class="comment">// 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line"><span class="attr">parallel</span>: threads, <span class="comment">// 开启多进程</span></span><br><span class="line">&#125;),</span><br><span class="line">],</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// devServer: &#123;</span></span><br><span class="line"><span class="comment">//   host: &quot;localhost&quot;, // 启动服务器域名</span></span><br><span class="line"><span class="comment">//   port: &quot;3000&quot;, // 启动服务器端口号</span></span><br><span class="line"><span class="comment">//   open: true, // 是否自动打开浏览器</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"><span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line"><span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="减少代码体积"><a href="#减少代码体积" class="headerlink" title="减少代码体积"></a>减少代码体积</h1><h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><p>开发时我们定义了一些工具函数库，或者引用第三方工具函数库或组件库。</p><p>如果没有特殊处理的话我们打包时会引入整个库，但是实际上可能我们可能只用上极小部分的功能。</p><p>这样将整个库都打包进来，体积就太大了。</p><p><code>Tree Shaking</code> 是一个术语，通常用于描述移除 JavaScript 中的没有使用上的代码。</p><p><strong>注意：它依赖 <code>ES Module</code>。</strong></p><p>Webpack 已经默认开启了这个功能，无需其他配置。</p><h2 id="Babel-1"><a href="#Babel-1" class="headerlink" title="Babel"></a>Babel</h2><p>Babel 为编译的每个文件都插入了辅助代码，使代码体积过大！</p><p>Babel 对一些公共方法使用了非常小的辅助代码，比如 <code>_extend</code>。默认情况下会被添加到每一个需要它的文件中。</p><p>你可以将这些辅助代码作为一个独立模块，来避免重复引入。</p><p><code>@babel/plugin-transform-runtime</code>: 禁用了 Babel 自动对每个文件的 runtime 注入，而是引入 <code>@babel/plugin-transform-runtime</code> 并且使所有辅助代码从这里引用。</p><p>下载包</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel/plugin-transform-runtime -D</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">                loader: &quot;babel-loader&quot;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  cacheDirectory: true, // 开启babel编译缓存</span><br><span class="line">                  cacheCompression: false, // 缓存文件不要压缩</span><br><span class="line">                  plugins: [&quot;@babel/plugin-transform-runtime&quot;], // 减少代码体积</span><br><span class="line">                &#125;,</span><br></pre></td></tr></table></figure><h2 id="Image-Minimizer"><a href="#Image-Minimizer" class="headerlink" title="Image Minimizer"></a>Image Minimizer</h2><p>开发如果项目中引用了较多图片，那么图片体积会比较大，将来请求速度比较慢。</p><p>我们可以对图片进行压缩，减少图片体积。</p><p><strong>注意：如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。</strong></p><p><code>image-minimizer-webpack-plugin</code>: 用来压缩图片的插件</p><ol><li>下载包</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i image-minimizer-webpack-plugin imagemin -D</span><br></pre></td></tr></table></figure><p>还有剩下需要下载，有两种模式：</p><ul><li>  无损压缩</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo -D</span><br></pre></td></tr></table></figure><ul><li>  有损压缩</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install imagemin-gifsicle imagemin-mozjpeg imagemin-pngquant imagemin-svgo -D</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const ImageMinimizerPlugin = require(&quot;image-minimizer-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      // css压缩也可以写到optimization.minimizer里面，效果一样的</span><br><span class="line">      new CssMinimizerPlugin(),</span><br><span class="line">      // 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        parallel: threads, // 开启多进程</span><br><span class="line">      &#125;),</span><br><span class="line">      // 压缩图片</span><br><span class="line">      new ImageMinimizerPlugin(&#123;</span><br><span class="line">        minimizer: &#123;</span><br><span class="line">          implementation: ImageMinimizerPlugin.imageminGenerate,</span><br><span class="line">          options: &#123;</span><br><span class="line">            plugins: [</span><br><span class="line">              [&quot;gifsicle&quot;, &#123; interlaced: true &#125;],</span><br><span class="line">              [&quot;jpegtran&quot;, &#123; progressive: true &#125;],</span><br><span class="line">              [&quot;optipng&quot;, &#123; optimizationLevel: 5 &#125;],</span><br><span class="line">              [</span><br><span class="line">                &quot;svgo&quot;,</span><br><span class="line">                &#123;</span><br><span class="line">                  plugins: [</span><br><span class="line">                    &quot;preset-default&quot;,</span><br><span class="line">                    &quot;prefixIds&quot;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      name: &quot;sortAttrs&quot;,</span><br><span class="line">                      params: &#123;</span><br><span class="line">                        xmlnsOrder: &quot;alphabetical&quot;,</span><br><span class="line">                      &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                  ],</span><br><span class="line">                &#125;,</span><br><span class="line">              ],</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br></pre></td></tr></table></figure><p>打包时会出现报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: Error with &#x27;src\images\1.jpeg&#x27;: &#x27;&quot;C:\Users\86176\Desktop\webpack\webpack_code\node_modules\jpegtran-bin\vendor\jpegtran.exe&quot;&#x27;</span><br><span class="line">Error with &#x27;src\images\3.gif&#x27;: spawn C:\Users\86176\Desktop\webpack\webpack_code\node_modules\optipng-bin\vendor\optipng.exe ENOENT</span><br></pre></td></tr></table></figure><p>我们需要安装两个文件到 node_modules 中才能解决, 文件可以从课件中找到：</p><ul><li>  jpegtran.exe</li></ul><p>需要复制到 <code>node_modules\jpegtran-bin\vendor</code> 下面</p><blockquote><p><a href="http://jpegclub.org/jpegtran/">jpegtran 官网地址 open in new window</a></p></blockquote><ul><li>  optipng.exe</li></ul><p>需要复制到 <code>node_modules\optipng-bin\vendor</code> 下面</p><blockquote><p><a href="http://optipng.sourceforge.net/">OptiPNG 官网地址</a></p></blockquote><h1 id="优化代码运行性能"><a href="#优化代码运行性能" class="headerlink" title="优化代码运行性能"></a>优化代码运行性能</h1><h2 id="Code-Split"><a href="#Code-Split" class="headerlink" title="Code Split"></a>Code Split</h2><p>打包代码时会将所有 js 文件打包到一个文件中，体积太大了。我们如果只要渲染首页，就应该只加载首页的 js 文件，其他文件不应该加载。</p><p>所以我们需要将打包生成的文件进行代码分割，生成多个 js 文件，渲染哪个页面就只加载某个 js 文件，这样加载的资源就少，速度就更快。</p><p>代码分割（Code Split）主要做了两件事：</p><ol><li>分割文件：将打包生成的文件进行分割，生成多个 js 文件。</li><li>按需加载：需要哪个文件就加载哪个文件。</li></ol><p>代码分割实现方式有不同的方式，为了更加方便体现它们之间的差异，我们会分别创建新的文件来演示</p><ol><li>文件目录</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── public</span><br><span class="line">├── src</span><br><span class="line">|   ├── app.js</span><br><span class="line">|   └── main.js</span><br><span class="line">├── package.json</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure><ol start="2"><li>下载包</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli html-webpack-plugin -D</span><br></pre></td></tr></table></figure><ol start="3"><li>新建文件</li></ol><p>内容无关紧要，主要观察打包输出的结果</p><ul><li>  app.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello app&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>  main.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello main&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li>配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 单入口</span><br><span class="line">  // entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">  // 多入口</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &quot;./src/main.js&quot;,</span><br><span class="line">    app: &quot;./src/app.js&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &quot;./dist&quot;),</span><br><span class="line">    // [name]是webpack命名规则，使用chunk的name作为输出的文件名。</span><br><span class="line">    // 什么是chunk？打包的资源就是chunk，输出出去叫bundle。</span><br><span class="line">    // chunk的name是啥呢？ 比如： entry中xxx: &quot;./src/xxx.js&quot;, name就是xxx。注意是前面的xxx，和文件名无关。</span><br><span class="line">    // 为什么需要这样命名呢？如果还是之前写法main.js，那么打包生成两个js文件都会叫做main.js会发生覆盖。(实际上会直接报错的)</span><br><span class="line">    filename: &quot;js/[name].js&quot;,</span><br><span class="line">    clear: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &quot;./public/index.html&quot;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  mode: &quot;production&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行指令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>此时在 dist 目录我们能看到输出了两个 js 文件。</p><p>总结：配置了几个入口，至少输出几个 js 文件。</p><ol start="2"><li>提取重复代码</li></ol><p>如果多入口文件中都引用了同一份代码，我们不希望这份代码被打包到两个文件中，导致代码重复，体积更大。</p><p>我们需要提取多入口的重复代码，只打包生成一个 js 文件，其他文件引用它就好。</p><ol><li>修改文件</li></ol><ul><li>  app.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello app&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><ul><li>  main.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello main&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><ul><li>  math.js</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, c</span>) =&gt;</span> p + c, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 单入口</span><br><span class="line">  // entry: &#x27;./src/main.js&#x27;,</span><br><span class="line">  // 多入口</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &quot;./src/main.js&quot;,</span><br><span class="line">    app: &quot;./src/app.js&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &quot;./dist&quot;),</span><br><span class="line">    // [name]是webpack命名规则，使用chunk的name作为输出的文件名。</span><br><span class="line">    // 什么是chunk？打包的资源就是chunk，输出出去叫bundle。</span><br><span class="line">    // chunk的name是啥呢？ 比如： entry中xxx: &quot;./src/xxx.js&quot;, name就是xxx。注意是前面的xxx，和文件名无关。</span><br><span class="line">    // 为什么需要这样命名呢？如果还是之前写法main.js，那么打包生成两个js文件都会叫做main.js会发生覆盖。(实际上会直接报错的)</span><br><span class="line">    filename: &quot;js/[name].js&quot;,</span><br><span class="line">    clean: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &quot;./public/index.html&quot;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  mode: &quot;production&quot;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    // 代码分割配置</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &quot;all&quot;, // 对所有模块都进行分割</span><br><span class="line">      // 以下是默认值</span><br><span class="line">      // minSize: 20000, // 分割代码最小的大小</span><br><span class="line">      // minRemainingSize: 0, // 类似于minSize，最后确保提取的文件大小不能为0</span><br><span class="line">      // minChunks: 1, // 至少被引用的次数，满足条件才会代码分割</span><br><span class="line">      // maxAsyncRequests: 30, // 按需加载时并行加载的文件的最大数量</span><br><span class="line">      // maxInitialRequests: 30, // 入口js文件最大并行请求数量</span><br><span class="line">      // enforceSizeThreshold: 50000, // 超过50kb一定会单独打包（此时会忽略minRemainingSize、maxAsyncRequests、maxInitialRequests）</span><br><span class="line">      // cacheGroups: &#123; // 组，哪些模块要打包到一个组</span><br><span class="line">      //   defaultVendors: &#123; // 组名</span><br><span class="line">      //     test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块</span><br><span class="line">      //     priority: -10, // 权重（越大越高）</span><br><span class="line">      //     reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块</span><br><span class="line">      //   &#125;,</span><br><span class="line">      //   default: &#123; // 其他没有写的配置会使用上面的默认值</span><br><span class="line">      //     minChunks: 2, // 这里的minChunks权重更大</span><br><span class="line">      //     priority: -20,</span><br><span class="line">      //     reuseExistingChunk: true,</span><br><span class="line">      //   &#125;,</span><br><span class="line">      // &#125;,</span><br><span class="line">      // 修改配置</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        // 组，哪些模块要打包到一个组</span><br><span class="line">        // defaultVendors: &#123; // 组名</span><br><span class="line">        //   test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块</span><br><span class="line">        //   priority: -10, // 权重（越大越高）</span><br><span class="line">        //   reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块</span><br><span class="line">        // &#125;,</span><br><span class="line">        default: &#123;</span><br><span class="line">          // 其他没有写的配置会使用上面的默认值</span><br><span class="line">          minSize: 0, // 我们定义的文件体积太小了，所以要改打包的最小文件体积</span><br><span class="line">          minChunks: 2,</span><br><span class="line">          priority: -20,</span><br><span class="line">          reuseExistingChunk: true,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们从 4 个角度对 webpack 和代码进行了优化：</p><ol><li>提升开发体验</li></ol><ul><li>  使用 <code>Source Map</code> 让开发或上线时代码报错能有更加准确的错误提示。</li></ul><ol start="2"><li>提升 webpack 提升打包构建速度</li></ol><ul><li>  使用 <code>HotModuleReplacement</code> 让开发时只重新编译打包更新变化了的代码，不变的代码使用缓存，从而使更新速度更快。</li><li>  使用 <code>OneOf</code> 让资源文件一旦被某个 loader 处理了，就不会继续遍历了，打包速度更快。</li><li>  使用 <code>Include/Exclude</code> 排除或只检测某些文件，处理的文件更少，速度更快。</li><li>  使用 <code>Cache</code> 对 eslint 和 babel 处理的结果进行缓存，让第二次打包速度更快。</li><li>  使用 <code>Thead</code> 多进程处理 eslint 和 babel 任务，速度更快。（需要注意的是，进程启动通信都有开销的，要在比较多代码处理时使用才有效果）</li></ul><ol start="3"><li>减少代码体积</li></ol><ul><li>  使用 <code>Tree Shaking</code> 剔除了没有使用的多余代码，让代码体积更小。</li><li>  使用 <code>@babel/plugin-transform-runtime</code> 插件对 babel 进行处理，让辅助代码从中引入，而不是每个文件都生成辅助代码，从而体积更小。</li><li>  使用 <code>Image Minimizer</code> 对项目中图片进行压缩，体积更小，请求速度更快。（需要注意的是，如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。）</li></ul><ol start="4"><li>优化代码运行性能</li></ol><ul><li>  使用 <code>Code Split</code> 对代码进行分割成多个 js 文件，从而使单个文件体积更小，并行加载 js 速度更快。并通过 import 动态导入语法进行按需加载，从而达到需要使用时才加载该资源，不用时不加载资源。</li><li>  使用 <code>Preload / Prefetch</code> 对代码进行提前加载，等未来需要使用时就能直接使用，从而用户体验更好。</li><li>  使用 <code>Network Cache</code> 能对输出资源文件进行更好的命名，将来好做缓存，从而用户体验更好。</li><li>  使用 <code>Core-js</code> 对 js 进行兼容性处理，让我们代码能运行在低版本浏览器。</li><li>  使用 <code>PWA</code> 能让代码离线也能访问，从而提升用户体验。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP 协议全称为 Hyper Text Transfer Protocol，即超文本传输协议。HTTP 协议主要用于客户端与服务端之间的通信，浏览器就是最常见的 HTTP 客户端。</p><h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><p>客户端向服务器发送的信息称为 请求报文，结构从上到下包括 请求行、请求头、请求体</p><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>用于说明需要做什么， 包含三个部分–方法、资源路径、HTTP 版本</p><ul><li>  方法： 通过方法指定对请求资源进行怎样的操作做什么样的操作（比如查询、修改等）。常见的方法有：<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 与 <code>HEAD</code>。</li><li>  资源路径： 指定请求资源在服务器中的位置。比如 <code>/index.html</code> 表示访问服务器根目录下名字为 <code>index</code> 的 <code>html</code> 文件</li><li>  <strong>HTTP 版本</strong>：指定所使用的 HTTP 版本。</li></ul><p>最常用的两个方法是 <code>GET</code> 和 <code>POST</code></p><ul><li>  <code>GET</code> 请求参数存放在 URL 中，而 <code>POST</code> 请求参数存储在请求体中。</li></ul><p>参数放在 URL 中可以直接被看到，则 <code>GET</code> 请求相对 <code>POST</code> 请求更不安全。</p><p>各个浏览器对 URL 长度做了限制，比如 IE 浏览器限制 URL 的长度最大为 2KB，这就使得了 <code>GET</code> 请求传输的数据长度有了限制，而 <code>POST</code> 请求传输数据长度无限制。</p><ul><li>  一般 <code>GET</code> 请求用于获取数据，<code>POST</code> 请求用于新增数据。</li></ul><p><code>GET</code> 请求用于获取资源，不会对系统资源进行改变。<code>POST</code> 请求用于新增资源，这意味着多次请求将创建多个资源。基于这个特点，<code>GET</code> 请求可被缓存、可保留在浏览器历史记录中、浏览器回退不会产生副作用，而 <code>POST</code> 请求反之。</p><p>GET 和 POST 的区别。</p><ul><li>  从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li><li>  从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li><li>  从<strong>幂等性</strong>的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)</li><li>  从 <strong>TCP</strong> 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</li></ul><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>用于向服务器传递一些额外的重要信息，由字段名与字段值组成。常见的请求头包括：</p><table><thead><tr><th align="center">请求头</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>Host</code></td><td align="center">接收请求的域名</td></tr><tr><td align="center"><code>User-Agent</code></td><td align="center">客户端软件的名称和版本号等相关信息</td></tr><tr><td align="center"><code>Connection</code></td><td align="center">设置发送响应之后 TCP 连接是否继续保持的通信选项</td></tr><tr><td align="center"><code>Cache-Control</code></td><td align="center">控制缓存的相关信息</td></tr><tr><td align="center"><code>Referer</code></td><td align="center">记录请求的来源（当通过点击超级链接进入下一个页面时，会记录上一个页面的 URL）</td></tr><tr><td align="center"><code>Accept</code></td><td align="center">客户端可支持的数据类型， 以 MIME 类型来表示</td></tr><tr><td align="center"><code>Accept-Encoding</code></td><td align="center">客户端可支持的编码格式</td></tr><tr><td align="center"><code>Accept-Language</code></td><td align="center">客户端可支持的语言</td></tr><tr><td align="center"><code>If-Modified-Since</code></td><td align="center">用于判断资源的缓存是否有效（客户端通知服务器，本地缓存的最后变更时间）</td></tr><tr><td align="center"><code>If-None-Match</code></td><td align="center">用于判断资源的缓存是否有效</td></tr><tr><td align="center"><code>Range</code></td><td align="center">用于断点续传，指定第一个字节的位置和最后一个字节的位置。</td></tr><tr><td align="center"><code>Cookie</code></td><td align="center">表示请求者的身份，用于保存状态信息</td></tr></tbody></table><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>用于传送客户端要发给服务器的数据，比如请求参数。</p><p>请求体与请求行和请求头不同，请求行和请求体的数据都是文本形式且格式化的，而请求体可以包含任意的二进制数据，比如文本、图片、视频等等。</p><h2 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h2><p>服务端向客户端发送的信息称为 响应报文，结构从上到下包括 响应行、响应头、响应体</p><h3 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h3><p>用于说明对请求的处理情况，包括三个部分– HTTP 版本、状态码、消息短语</p><ul><li>  HTTP 版本</li><li>  状态码： 以三位数字形式描述服务器对请求的处理结果， 如 200 表示成功</li><li>  消息短语： 以文本呢的形式描述服务器对请求的处理结果，如 OK 表示成功</li></ul><p>状态码：</p><table><thead><tr><th align="center">状态码</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>1XX</code></td><td align="center">提示信息，表示请求已被成功接收，继续处理</td></tr><tr><td align="center"><code>2XX</code></td><td align="center">成功，表示请求被正常处理完毕</td></tr><tr><td align="center"><code>3XX</code></td><td align="center">重定向，资源位置发生变化，表示请求需要附加操作才能完成</td></tr><tr><td align="center"><code>4XX</code></td><td align="center">客户端错误，表示服务器无法处理请求</td></tr><tr><td align="center"><code>5XX</code></td><td align="center">服务器错误，表示服务器处理请求出错</td></tr></tbody></table><p>一些具体的状态码及含义如下：</p><ul><li>  <code>200 OK</code>：表示请求被正常处理。</li><li>  <code>204 No Content</code>：表示请求被正常处理，但在返回的响应报文中不含响应体内容。</li><li>  <code>301 Moved Permanently</code>：永久重定向，表示请求的资源已经被永久转移了，新的 URL 会在响应报文的 <strong>Location</strong> 字段中返回，浏览器将自动获取新的 URL 并发出新的请求。</li><li>  <code>302 Found</code>：临时重定向，以后还可能有变化，表示请求的资源已被临时分配了新的 URL，新的 URL 会在响应报文中的 <strong>Location</strong> 字段中返回，浏览器将会自动使用新的 URL 并发出新的请求。</li><li>  <code>304 Not Modified</code>：代表之前的缓存可以继续使用。</li><li>  <code>400 Bad Request</code>：一个通用差错状态码，表示请求报文中存在语法错误，客户端发生的错误。</li><li>  <code>401 Unauthorized</code>：用户未认证。</li><li>  <code>403 Forbidden</code>：表示服务器虽然收到了请求，但是拒绝提供服务，常见的原因是为没有访问权限（即用户未授权）。</li><li>  <code>404 Not Found</code>：表示请求资源不存在。</li><li>  <code>500 Internal Server Error</code>：表示服务器出现错误。</li><li>  <code>502 Bad Gateway</code>：通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>  <code>503 Service Unavailable</code>：表示服务器暂时处于超负载或者正在进行停机维护，暂时无法处理请求，可以稍后再试。</li></ul><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>响用于向客户端传递一些额外的重要信息，由字段名与字段值组成。常见的响应头包括：</p><table><thead><tr><th align="center">响应头</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>Date</code></td><td align="center">日期时间信息，表示服务器产生并发送响应报文的日期和时间。</td></tr><tr><td align="center"><code>Server</code></td><td align="center">表示 HTTP 服务器应用程序的信息，类似于请求报文中的 <code>User-Agent</code></td></tr><tr><td align="center"><code>Location</code></td><td align="center">此字段会配合重定向使用，用于提供重定向后新的 URL。</td></tr><tr><td align="center"><code>Connection</code></td><td align="center">设置发送响应之后 TCP 连接是否继续保持的通信选项</td></tr><tr><td align="center"><code>Cache-Control</code></td><td align="center">控制缓存的相关信息</td></tr><tr><td align="center"><code>Content-Type</code></td><td align="center">服务器返回的响应类型</td></tr><tr><td align="center"><code>Content-Length</code></td><td align="center">服务器返回的响应长度</td></tr><tr><td align="center"><code>Content-Encoding</code></td><td align="center">服务器返回的响应编码</td></tr><tr><td align="center"><code>Content-Language</code></td><td align="center">服务器返回的响应语言</td></tr><tr><td align="center"><code>Last-Modified</code></td><td align="center">指定响应内容最后的修改时间</td></tr><tr><td align="center"><code>Expires</code></td><td align="center">表示资源失效的时间，浏览器会在指定过期时间内使用本地缓存</td></tr><tr><td align="center"><code>Etag</code></td><td align="center">用于协商缓存，返回一个摘要值</td></tr><tr><td align="center"><code>Accept-Ranges</code></td><td align="center">用于断点续传，指定服务器所支持的内容范围</td></tr><tr><td align="center"><code>Set-Cookie</code></td><td align="center">设置状态信息</td></tr></tbody></table><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>响应体用于传送服务器要发给浏览器的正文。与请求报文的请求体一样，响应体可包含任意的二进制数据。</p><h2 id="持久链接"><a href="#持久链接" class="headerlink" title="持久链接"></a>持久链接</h2><p>客户端需要发送许多请求给服务器，如果客户端与服务器的每次请求与想要都经过一个单独的 TCP 连接发送，那么就称为 <strong>非持续连接/短连接</strong>；如果经过相同的 TCP 连接发送，则称为 <strong>持续连接/长连接</strong>。</p><p><strong>非持续连接</strong>有以下几个缺点：</p><ul><li>  每次建立连接都需要单独经历三次握手过程，容易导致总的请求响应时间变长。即使使用并行连接，也容易加重 Web 服务器的负担。</li><li>  建立维护多个 TCP 连接容易使得服务器存在严重负担。</li></ul><p>HTTP/1.1 及之后的版本默认采用持续连接的方式，也可以配置为非持续连接。具体的，可以在请求头的 <code>Connection</code> 字段设置是否使用持久连接：</p><ul><li>  如果设置为 <code>Connection: Keep-Alive</code> 则表明此连接为持久连接（HTTP/1.1 及之后的版本默认开启）。</li><li>  如果设置为 <code>Connection: Close</code> 则表明此连接为非持久连接，每当 TCP 连接成功发送响应数据后，就关闭连接。</li></ul><p>需要注意，持久连接并不是永久连接，如果在一个可配置的时间间隔后，此连接仍未被使用，那么服务器将会关闭该连接。</p><h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h2><p>对于一些短时间内不会产生变化的资源，客户端可以在请求后将服务器响应的数据资源 <strong>缓存</strong> 于客户端本地。当之后想要再次获取这些资源时，可以直接读取本地缓存的数据，不必再重新发送请求。</p><p>缓存的目的是 <strong>加快响应速度</strong>。HTTP 缓存的实现依赖于请求头于响应头的一些字段，主要分为 <strong>强缓存</strong> 与 <strong>持久（协商）缓存</strong>。</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p><strong>强缓存</strong> 指的是在缓存数据未失效的情况下，将直接使用浏览器的缓存数据，不会再向服务器发送请求。</p><p>强缓存主要通过 <code>Cache-Control</code> 与 <code>Expires</code> 字段实现。</p><p><code>Cache-Control</code> 是一个相对时间，即多长时间之后过期；<code>Expires</code> 是一个绝对时间，即在某个时间点过期。如果两个字段同时存在，前者的优先级更高。</p><p>由于服务器端时间和客户端时间可能存在偏差，因此使用 <code>Expires</code> 可能会存在时间误差，因此一般更推荐使用 <code>Cache-Control</code> 来实现强缓存。</p><p>以 <code>Cache-Control</code> 为例，强缓存的具体实现流程如下：</p><ol><li>当客户端第一次请求服务器资源时，服务器会在响应头中添加 <code>Cache-Control</code> 字段。<code>Cache-Control</code> 可以设置以下内容：</li></ol><p>（1）<code>max-age=s</code>：表示缓存将于指定秒值后过期。如 <code>max-age=31536000</code> 表示缓存将于 31536000 秒（即 365 天）后过期；</p><p>（2）<code>no-store</code>：表示该数据不允许缓存，此字段同时适用于强缓存与协商缓存；</p><p>（3）<code>no-cache</code>：表示该数据不允许使用强缓存，只能使用协商缓存。</p><p>（4）<code>must-revalidate</code>：表示如果缓存未过期，可以使用缓存；如果缓存已过期，那么需要向服务器验证该缓存是否有效。</p><ol start="2"><li>客户端再次向服务器请求重复资源时，根据请求资源的时间与 <code>Cache-Control</code> 中设置的过期时间大小，计算出该资源是否过期。</li></ol><p>如果没有过期，并且可以使用缓存，那么就使用缓存，否则重新请求服务器。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><strong>协商缓存</strong> 指的是当第一次请求后，服务器响应头 <code>Cache-Control</code> 字段设置为 <code>no-cache</code> 或者当缓存过期后，客户端再次向服务器请求判断缓存资源是否有效。</p><ul><li>  如果资源没有更新，那么服务器将会返回 <code>304 Not Modified</code> 表明缓存仍然可用，就不再需要重新发送资源，同时更新缓存有效时间。</li><li>  如果资源已更新，那么服务器将会返回 <code>200 OK</code>，并将更新后的资源放在响应体中。</li></ul><p>协商缓存在 HTTP/1.0 与 HTTP/1.1 的实现方式有所不同。</p><ol><li> HTTP/1.0 规范</li></ol><p>在 HTTP/1.0 中，协商缓存主要通过请求头中的 <code>If-Modified-Since</code> 与响应头中的 <code>Last-Modified</code> 字段实现。</p><p><code>Last-Modified</code> 字段表示响应资源的最后修改时间，客户端第一次请求资源后，服务器将在响应头中携带此字段。</p><p><code>If-Modified-Since</code> 字段是当缓存资源过期时，客户端再次发起请求并将之前接收到的 <code>Last-Modified</code> 值放在请求头 <code>If-Modified-Since</code> 中，服务器接收后，将此时间与被请求资源的实际最后修改时间进行对比：</p><ul><li>  如果最后修改时间不一致，说明资源已更新，那么服务器返回 <code>200 OK</code> 与已更新的资源；</li><li>  如果最后修改时间一致，说明资源未更新，返回 <code>304 Not Modified</code>。</li></ul><p>HTTP/1.0 规范下的协商缓存存在以下问题：</p><ul><li>  实现方式基于时间，但是容易因为时间误差而不可靠；</li><li>  如果某些文件内容并未修改，只是修改了最后修改时间，那么实际上应该使用缓存但是却无法使用缓存。</li></ul><ol start="2"><li>HTTP/1.1 规范</li></ol><p>在 HTTP/1.1 中，协商缓存主要通过请求头中的 <code>If-None-Match</code> 与响应头中的 <code>ETag</code> 字段实现。</p><p><code>ETag</code> 字段表示相应资源的唯一标识，是一个哈希值，客户端第一次请求资源后，服务器将在响应头中携带此字段。</p><p><code>If-None-Match</code> 字段是当缓存资源过期时，客户端再次发起请求并将之前接收到的 <code>ETag</code> 值放在请求头 <code>If-None-Match</code> 中，服务器接收后，将此哈希值与被请求资源的当前哈希值进行对比：</p><ul><li>  如果两者不等，说明资源已更新，那么服务器返回 <code>200 OK</code> 与已更新的资源；</li><li>  如果两者相等，说明资源未更新，返回 <code>304 Not Modified</code>。</li></ul><p>HTTP/1.1 规范下的协商缓存存在的问题是，服务器计算 <code>ETag</code> 哈希值会消耗系统性能。</p><p>如果 HTTP 响应头同时存在 <code>ETag</code> 与 <code>Last-Modified</code> 字段，前者优先级更高。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b74c746d1459403382fd0bbc1d96aeca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="图片 5.png"></p><h3 id="三种刷新操作对-http-缓存的影响"><a href="#三种刷新操作对-http-缓存的影响" class="headerlink" title="三种刷新操作对 http 缓存的影响"></a>三种刷新操作对 http 缓存的影响</h3><ul><li>  正常操作：地址栏输入 url，跳转链接，前进后退等。</li><li>  手动刷新：f5，点击刷新按钮，右键菜单刷新。</li><li>  强制刷新：ctrl + f5，shift+command+r。</li></ul><p><strong>正常操作：强制缓存有效，协商缓存有效。</strong> <strong>手动刷新：强制缓存失效，协商缓存有效。</strong> <strong>强制刷新：强制缓存失效，协商缓存失效。</strong></p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>一些前提知识：</p><ul><li>  会话</li></ul><p>会话，指用户登录网站后的一系列动作，比如浏览商品添加到购物车并购买。</p><ul><li>  无状态的 HTTP 协议</li></ul><p>在早期，HTTP 协议是无状态的协议。每个 HTTP 请求都要求打开一个 TCP 连接，一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。</p><ul><li>  会话跟踪</li></ul><p>会话跟踪是 Web 程序中常用的技术，用于跟踪用户的整个会话。常用的会话跟踪技术有 Cookie 与 Session。Cookie 通过在客户端记录信息确定用户身份，而 Session 通过在服务器端记录信息确定用户身份。</p><h3 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h3><p>由于 HTTP 是一种无状态的协议，因此服务器直接从网络连接了解客户端的身份。Cookie 的工作原理就是为客户端们颁发一个通行证，每个客户端都有一个独一无二的通行证（也就是 Cookie）无论哪一个客户端想要访问服务端，都必须携带属于自己的 Cookie，这样服务器就可以通过 Cookie 获知客户端的身份了。</p><p>Cookie 本质上是一小段的文本信息。当客户端向服务器发送请求时，如果服务端需要记录该用户的状态，那么在发送响应数据时就可以发送一个属于这个客户端的 Cookie。当客户端接收到响应数据后，会将 Cookie 保存起来；当客户端再次请求该服务器时，会将之前保存下的 Cookie 一同提交给服务器，服务器就可以通过 Cookie 辨认客户端状态用户状态。</p><h3 id="查看-Cookie"><a href="#查看-Cookie" class="headerlink" title="查看 Cookie"></a>查看 Cookie</h3><p>我们可以在浏览器的开发者工具中的控制台输入 <code>alert(document.cookie)</code>，以查看该网站的 Cookie。如查看 <code>www.google.com</code> 的 Cookie：</p><p><img src="https://blog.yucohny.vercel.app/images/ComputerNetwork/4.png" alt="img"></p><p>在弹出的 Cookie 内容中，有一段字段为 <code>SID</code>，就保存了当前客户端的 Google 账号 ID。当客户端将 Cookie 协同其他数据一起发送给服务器时，服务器就可以通过 Cookie 的内容识别出当前客户端的身份。</p><h3 id="不可跨域"><a href="#不可跨域" class="headerlink" title="不可跨域"></a>不可跨域</h3><p>许多网站都会使用 Cookie。例如，Google 会向客户端发送 Cookie，Baidu 也会向客户端发送 Cookie。那客户端访问 Google 时会不会也携带上 Baidu 颁发的 Cookie 呢？或者 Google 能不能修改 Baidu 颁发的 Cookie 呢？</p><p>答案是否定的。</p><p>Cookie 具有不可跨域名性。根据 Cookie 规范，浏览器访问 Google 只会携带 Google 发送的 Cookie，而不会携带 Baidu 发送的 Cookie。同理，Google 也只能操作 Google 发送的 Cookie，而不能操作 Baidu 的 Cookie。</p><p>Cookie 由客户端进行管理。客户端保证 Google 只会操作 Google 发送的 Cookie 而不会操作 Baidu 发送的 Cookie，从而保证用户的隐私安全。</p><p>客户端通过域名判断一个网站是否能操作另一个网站的 Cookie。Google 与 Baidu 的域名不一样，因此 Google 不能操作 Baidu 的 Cookie。</p><p>需要注意的是，即使是同一根域名下的不同二级域名，也无法操作彼此的 Cookie。</p><h3 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h3><p>Cookie 的 <code>maxAge</code> 属性决定了 <code>Cookie</code>的有效期，单位为秒。</p><p>如果 <code>maxAge</code> 属性为正数，则表示该 Cookie 会在 <code>maxAge</code> 秒之后自动失效。浏览器会将 <code>maxAge</code> 为正数的 Cookie 写入对应的 Cookie 文件中。无论浏览器或者甚至是电脑是否关闭，只要还在 <code>maxAge</code> 秒之前，重新访问服务器时该 Cookie 仍然有效。</p><p>如果 <code>maxAge</code> 为负数，则表示该 Cookie 仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该 Cookie 即失效。<code>maxAge</code> 为负数的 Cookie，为临时性 Cookie，不会被写到 Cookie 文件中。<code>maxAge</code> 为负数的 Cookie 信息直接保存在浏览器内存中，因此关闭浏览器该 Cookie 将会消失。Cookie 默认的 <code>maxAge</code> 为 –1。</p><p>如果 <code>maxAge</code> 为 0，则表示删除该 Cookie。Cookie 机制没有提供删除 Cookie 的方法，因此通过设置该 Cookie 即时失效实现删除 Cookie 的效果。失效的 Cookie 会被浏览器从 Cookie 文件或者内存中删除。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>HTTP 协议不仅是无状态的，而且是不安全的。</p><p>使用 HTTP 协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。如果不希望 Cookie 在 HTTP 等非安全协议中传输，可以设置 Cookie 的 <code>secure</code> 属性为 <code>true</code>，此时客户端只会在 HTTPS 和 SSL 等安全协议中传输此类 Cookie。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 是服务端记录客户端状态的机制。Cookie 保存在客户端中，Session 保存在服务端中。</p><p>Session 的核心是，当客户端访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上；客户端再次访问时服务器时，服务器只需要直接从该 Session 中查找客户端的状态即可。</p><p>当客户端第一次访问服务器时，服务器会自动创建 Session；在 Session 生成后，只要客户端继续访问，服务器就会更新 Session 的最后访问时间，并维护该 Session。</p><h3 id="有效期-1"><a href="#有效期-1" class="headerlink" title="有效期"></a>有效期</h3><p>如果过多的 Session 存储在服务器内存中，那么会对服务器造成压力。为防止内存溢出，服务器会把长时间内没有活跃的 Session 从内存删除。这个时间就是 Session 的超时时间。如果超过了超时时间没访问过服务器，Session 就自动失效了。</p><h3 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h3><p>最常见使用 Session 的做法是，客户端在向服务器发送网络请求时，通过 Cookie 携带服务器分配的 SessionID。当服务器处理完对应的内容后，将数据返回给 SessionID 所对应的客户端。</p><h3 id="禁用-Cookie-时"><a href="#禁用-Cookie-时" class="headerlink" title="禁用 Cookie 时"></a>禁用 Cookie 时</h3><p>当客户端禁用 Cookie 时，我们便无法继续使用上述方法传递 Session 相关信息。通常有两种不借用 Cookie 的方式传递 Session 相关信息：</p><ol><li>重写 URL；</li><li>隐藏表单字段。</li></ol><p>重写 URL</p><p>重写 URL 的方式是将 Session 相关信息，如 SessionID，直接以参数的形式附加在 URL 上，像这样 <code>www.domain.com/v1/api?sessionID=SESSIONID</code>。</p><p>隐藏表单字段</p><p>直接将 SessionID 附加在 URL 上存在严重的安全问题，这与直接将私密的 SessionID 暴露在网络中无疑。</p><p>隐藏表单字段的方式是通过，将 SessionID 的字段，隐藏在表单的 <code>hidden</code> 子项中，当发起网络请求时，作为参数的一部分一同发送。像下列示例一样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">name</span>=<span class="string">&quot;sessionID&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">value</span>=<span class="string">&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line">/&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;handleClick()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Cookie-与-Session-区别"><a href="#Cookie-与-Session-区别" class="headerlink" title="Cookie 与 Session 区别"></a>Cookie 与 Session 区别</h3><ol><li>数据存放上</li></ol><p>Cookie 数据存放于客户端中，Session 数据存放于服务器中。</p><ol start="2"><li>安全性</li></ol><p>由于私密信息直接通过 Cookie 保存在客户端本地，因此别人可以通过分析存放于本地的 Cookie 来获取隐私信息。</p><ol start="3"><li>数据大小</li></ol><p>单个 Cookie 保存的数据不能超过 4KB，许多浏览器都限制一个站点最多保存 20 个 Cookie，因此存储的数据容易收到许多限制；而 Session 没有对存储的数据量的限制，并且可以保存更为复杂的数据类型。</p><ol start="4"><li>性能问题</li></ol><p>Session 在一定时间内保存于服务器，当访问服务器的客户端增多时，大量的 Session 数据会占用服务器的诸多内存；当需要考虑减轻服务器性能压力时，应当考虑使用 Cookie。</p><h1 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP/1"></a>HTTP/1</h1><p>主要介绍了 HTTP/1.1 的发展史，然后将介绍发展过程中遇到的各种困难以及最终的解决办法。</p><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>HTTP/0.9 于 1991 年提出，最初主要用于学术交流，并且需求也较为简单：用于在网络之间传递 HTML 超文本的内容，因为成为超文本传输协议。</p><p>HTTP/0.9 的实现方式也比较简单，采用了基于请求响应的模式：客户端发出请求，服务端返回数据。</p><p>HTTP/0.9 的完整请求流程如下：</p><ol><li>HTTP 协议基于 TCP 协议，因此客户端需要根据 IP 地址、端口号与服务器建立 TCP 链接。</li><li>建立连接后，客户端将发送一个 GET 请求行信息。</li></ol><blockquote><p>HTTP/0.9 没有请求头与请求体，请求行也较为简单：<code>GET /index.html</code>。</p></blockquote><ol><li>服务器接收到请求信息后，将会读取对应的数据，并将这些数据以 ASCII 字符流的方式返回给客户端。</li><li>HTML 文档传输完成后，连接断开。</li></ol><p>当时的需求较为简单，主要是用于传输体积较小的 HTML 文件，因此 HTTP/0.9 的实现具有以下三个特点：</p><ol><li>因此此时的需求较为简单，因此只需要请求行就可以完整表达客户端的需求，所以没有 HTTP 请求头与请求体。</li><li>同样，由于需求简单，服务器也没有响应头，只有响应体，也就响应的数据。</li><li>由于传输的数据都是 HTML 格式的文件，因此以 ASCII 字符流传输比较合适。</li></ol><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>为了能让客户端与服务器更深入地交流，HTTP/1.0 引入了请求头与响应头。</p><p>请求头与响应头都是以键值对的形式保存，在发送 HTTP 请求时，会携带上请求头的信息；同样，服务器在响应数据时，也会返回响应头信息。</p><h3 id="请求头与响应头"><a href="#请求头与响应头" class="headerlink" title="请求头与响应头"></a>请求头与响应头</h3><p>HTTP/1.0 的方案是通过请求头与响应头来进行协商。客户端发起 HTTP 请求时，会通过请求头告知服务器它期待返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件，以及文件的具体编码方式。</p><p>因而最终发出的请求头内容形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accept: text/html</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-Charset: ISO-8859-1, utf-8</span><br><span class="line">accept-language: zh-CN, zh</span><br></pre></td></tr></table></figure><p><code>accept</code> 表示期望服务器返回 HTML 类型的文件。</p><p><code>accept-encoding</code> 表示期望服务器使用 <code>gzip</code>、<code>deflate</code> 或者 <code>br</code> 中的一种方式进行压缩。</p><p><code>accept-Charset</code> 表示期望服务器使用的文件编码方式是 <code>ISO-8859-1</code> 或 <code>UTF-8</code> 中的一种。</p><p><code>accept-language</code> 表示期望服务器返回的内容优先语言是中文。</p><p>​ 服务器在接收到客户端发送的请求头信息后，会根据请求头信息来准备响应数据。但是可能存在一些意外情况，比如客户端请求的压缩类型是 <code>gzip</code>，但是服务器并不支持 <code>gzip</code>，仅支持通过 <code>br</code> 方式压缩。那么服务器就会通过响应头的 <code>content-encoding</code> 字段告诉浏览器最终的压缩类型。因此，客户端最终需要根据响应头的信息来处理数据，下面是一段响应头的示例数据信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content-encoding: br</span><br><span class="line">content-type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><p>有了响应头的信息后，浏览器就会使用 <code>br</code> 方式来解压文件，再按照 <code>UTF-8</code> 的编码格式来处理响应数据，最终按照 HTML 的方式解析文件。</p><p>HTTP/1.0 除了对多文件类型提供良好的支持外，还依据当时实际的需求引入了许多其他特性，这些特性都是通过请求头与响应头实现的：</p><ul><li>  有的请求服务器可能无法处理，或者处理出错，那么就需要告诉客户端处理该请求的最终情况。这就引入了 <strong>状态码</strong>。状态码就是通过响应行的方式来告知浏览器的。</li><li>  为了减轻服务器的压力，HTTP/1.0 提供了 <strong>缓存 Cache 机制</strong>，用来缓存已经下载过的数据。</li><li>  由于服务器需要统计客户端的基础信息，比如 Windows 与 macOS 的用户数量，因此 HTTP/1.0 的请求头还添加了 <strong>用户代理</strong> 的字段。</li></ul><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>HTTP/1.1 在 HTTP/1.0 的基础上继续做了大量的更新。同样，我们来看 HTTP/1.0 遇到了哪些问题，以及 HTTP/1.1 的改进方案。</p><h3 id="改进持久连接"><a href="#改进持久连接" class="headerlink" title="改进持久连接"></a>改进持久连接</h3><p>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、通过 HTTP 传输数据、断开 TCP 连接三个阶段。</p><p>在当时，由于通信的文件比较小，并且每个页面的引用的资源也不算多，因此这种传输形式并不存在大问题。但是随着浏览器的普及，每个页面中的图片文件越来越多，有时候一个页面可能需要包含成百上千个外部引用的资源文件。如果下载每个文件的时候，都需要建立 TCP 连接、传输数据、断开连接这样的步骤，无疑会增加大量无谓的开销。</p><p>为了解决这个问题，HTTP/1.1 增加了持久连接的方法：在一个 TCP 连接上可以传输多个 HTTP 请求。只要客户端或者浏览器没有明确断开连接，那么这个 TCP 连接就会一直保持。</p><p>HTTP/1.1 持久连接可以有效减少 TCP 建立连接与断开连接的次数，从而减小了客户端与服务端双方的负担，提升了整体 HTTP 请求的有效时长。</p><p>持久连接在 HTTP/1.1 中是默认开启的，因此我们不需要专门为了持久连接取 HTTP 请求头设置信息。如果不想要使用持久连接，那么可以在 HTTP 请求头中添加 <code>Connection: close</code>。</p><h3 id="提供虚拟主机的支持"><a href="#提供虚拟主机的支持" class="headerlink" title="提供虚拟主机的支持"></a>提供虚拟主机的支持</h3><p>在 HTTP/1.0 中，每个域名绑定了唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，并且要求每个虚拟主机都有自己的单独的域名，而这些单独的域名都公用同一个 IP 地址。</p><p>因此，HTTP/1.1 的请求头中增加了 <code>Host</code> 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 <code>Host</code> 字段做不同的处理。</p><h3 id="支持动态生成的内容"><a href="#支持动态生成的内容" class="headerlink" title="支持动态生成的内容"></a>支持动态生成的内容</h3><p>在 HTTP/1.0 中，服务器需要在响应头中设置完整的数据大小，如 <code>Content-Length: 1000</code>，这样客户端就可以根据设置的数据大小来接收数据。但是随着技术的不断发展，许多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了客户端并不知道何时会接收完所有的文件数据。</p><p>HTTP/1.1 中引入了 Chunk transfer 机制来解决这个问题：服务器会将数据分割为若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p><h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><p>HTTP/1.1 为网络效率做了大量优化，最核心的有以下三点：</p><ol><li>增加了持久连接。</li><li>浏览器为每个域名最多同时维护了 6 个 TCP 持久连接。</li><li>使用 CDN 实现域名分片机制。</li></ol><p>尽管 HTTP/1.1 采取了许多优化资源加载速度的策略，也取得了一定更多成果，但是 HTTP/1.1 对于带宽的利用率并不理想，这也是 HTTP/1.1 的一个核心问题。</p><p>带宽是每秒最大能发送或接收的字节数。每秒能发送的最大字节数称为上行带宽，每秒能接收的最大字节数称为下行带宽。</p><p>HTTP/1.1 对带宽利用率不理想，主要是由以下三个问题导致的：</p><ol><li>TCP 慢启动</li></ol><p>一旦一个 TCP 连接建立之后，就进入了数据发送数据阶段。在最开始的时候 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</p><p>慢启动本身是 TCP 为了减少网络拥塞的一种策略，是我们没有办法改变的。</p><ol start="2"><li>同时开启多条 TCP 连接，这些连接会竞争固定的带宽</li></ol><p>如果系统同时建立了多条 TCP 连接，当带宽充足时，每条连接的发送或者接收速度会慢慢向上增加；当带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。</p><p>这样就会出现一个问题，有的 TCP 连接下载的是一些关键资源，如 CSS、JS 文件；而又的 TCP 连接下载的是图片、视频等普通资源文件。但是多条 TCP 连接之间并不能协商让哪些关键资源优先下载，这样就可能会影响关键资源的下载速度。</p><ol start="3"><li>HTTP/1.1 队头阻塞</li></ol><p>当 HTTP/1.1 建立持久连接时，虽然只能共用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前请求没有结束之前，其他的请求只能处于阻塞状态中。这导致我们不能随意在一个管道中发送请求和接受内容。</p><p>但是阻塞请求的因素有很多，并且许多都是一些不确定的因素。一旦某一个请求被阻塞，那么后续请求在等待过程中，带宽以及 CPU 都会被白白浪费。</p><p>浏览器处理生成页面过程中，是希望能尽早接收到数据，这样就可以对这些数据做出预处理操作。但是队头阻塞使得这些数据并不能并行请求。</p><h2 id="HTTP-2-的多路复用"><a href="#HTTP-2-的多路复用" class="headerlink" title="HTTP/2 的多路复用"></a>HTTP/2 的多路复用</h2><p>慢启动与 TCP 连接之间的相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 本身的机制导致的。</p><p>虽然 TCP 本身「有问题」，但是我们并不能直接替换 TCP，只是我们依然要想办法规避 TCP 的慢启动与竞争问题。</p><p>HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样在整个页面资源的下载过程中只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p><p>队头阻塞的原因是，HTTP/1.1 中需要在等待请求完成后才能去请求下一个资源，而 HTTP/2 要实现的目标就是实现资源的并行请求。</p><p>所以 HTTP/2 的解决方法可以总结为：一个域名只使用一个 TCP 长连接，并实现资源的并行请求。</p><p>更加具体的则是，HTTP/2 通过最核心最重要的多路复用机制来解决上述问题。多路复用机制可以见下图作为示例：</p><p><img src="https://blog.yucohny.vercel.app/images/ComputerNetwork/1.png" alt="img"></p><p>每一个具体的请求都有一个对应的 ID，如 stream1 对应了 data.js 的请求，stream2 对应了 index.css 的请求。</p><p>服务器在接收到这些请求后，会根据具体的情况来决定优先返回哪些内容。比如服务器可能之前已经缓存好了 index.css 的响应头信息，那么在接收到请求的时候就可以立即把 index.css 的响应头信息返回给浏览器，然后再将 index.css 的响应体数据返回给浏览器。而现在之所以可以随意发送，是因为每份数据都有对应的 ID；浏览器在接收到之后，会筛选出相同 ID 的内容，再将这些 ID 相同的内容拼接为完整的 HTTP 响应数据。</p><p>HTTP/2 使用了多路复用技术，可以将请求分成⼀帧⼀帧的数据去传输，这样带来了⼀个额外的好处，就是当收到⼀个优先级⾼的请求时，比如接收到 JS 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</p><h2 id="多路复用的实现"><a href="#多路复用的实现" class="headerlink" title="多路复用的实现"></a>多路复用的实现</h2><p>上一小节介绍了 HTTP/2 采取了多路复用的机制来解决 HTTP/1.1 中存在的问题，这一小节来介绍 HTTP/2 是如何实现多路复用的。</p><p>我们首先来看看 HTTP/2 的协议栈：</p><p><img src="https://blog.yucohny.vercel.app/images/ComputerNetwork/2.png" alt="img"></p><p>从图中可以看出，HTTP/2 添加了二进制分帧层。接下来我们通过梳理 HTTP/2 的请求与接收过程，来分析 HTTP/2 的多路复用是如何实现的。</p><ol><li>浏览器准备好请求数据，包括请求行、请求头等信息。</li><li>这些数据经过二进制分帧层处理后，会被转换为一个个带有请求 ID 编号的帧，随后通过协议栈将这些帧发送给服务器。</li><li>服务器接受完所有帧之后，会将相同 ID 的帧合并为一条完整的请求信息。</li><li>随后服务器处理完整的请求信息，并将处理好的响应行、响应头和响应体分别发送至二进制分帧层。</li><li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li><li>浏览器接收到响应帧后，会根据 ID 编号将帧的数据提交给对应的请求。</li></ol><h2 id="HTTP-2-的其他特性"><a href="#HTTP-2-的其他特性" class="headerlink" title="HTTP/2 的其他特性"></a>HTTP/2 的其他特性</h2><p>上面几个小节介绍了 HTTP/2 通过多路复用实现了资源的并行传输。而基于⼆进制分帧层，HTTP/2 还附带实现了许多其他功能。</p><h3 id="设置请求的优先级"><a href="#设置请求的优先级" class="headerlink" title="设置请求的优先级"></a>设置请求的优先级</h3><p>浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请 求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对用户体验来说非常不友好。为了解决这个问题，HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样⼀个场景，当用户请求⼀个 HTML 页面后，服务器如果已经知道该 HTML 页面会引用几个重要的 JS 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将可能要使用的 CSS 文件和 JS ⽂件⼀并发送给浏览器，这样当浏览器解析完 HTML 文件后，就能直接拿到需要的 CSS 文件和 JS 文件，这对首次打开页面的速度起到了至关重要的作用。</p><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>⽆论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语⾔。HTTP/2 对请求头和响应头进行了压缩。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>浏览器安全主要划分为三大块内容：页面安全，系统安全与网络安全，HTTPS 就属于网络安全的范畴。</p><p>最开始设计 HTTP 协议的目的比较简单，仅仅是为了传输超文本文件，因此在当时并没有太强加密传输数据的需求，HTTP 从而一直保持着明文传输数据的特征，但是明文传输会导致在传输过程中的每一个环节，数据都有可能被窃取或者篡改。</p><p>具体来说，HTTP 将数据提交给 TCP 后，数据将会经过用户电脑、WiFi 路由器、运营商，以及目标服务器等等，在这中间的每一个环节数据都有可能被窃取或者篡改。假如用户电脑被装上了恶意软件，那么恶意软件或许就有机会抓住并篡改所发出的 HTTP 请求的内容。</p><p>HTTPS 并非一个新的协议，它的原理是在 HTTP 与 TCP 两个层面中间添加了一层 <strong>安全层 SSL/TLS</strong>：当 HTTP 向 TCP 发送数据时，会首先经过 SSL/TLS 加密；当 TCP 接收到另外一方传过来的数据时，数据会经过 SSL/TLS 解密，再传输到 HTTP。</p><p>如下图：</p><p><img src="https://blog.yucohny.vercel.app/images/ComputerNetwork/3.png" alt="img"></p><p>简单来说，安全层主要有两个职责：</p><ol><li>对发起 HTTP 请求的数据进行加密操作。</li><li>对接收到 HTTP 的内容进行解密操作。</li></ol><p>因此，我们需要了解 HTTPS 中的安全层，是如何实现加密与解密操作的。</p><h2 id="使用对称加密"><a href="#使用对称加密" class="headerlink" title="使用对称加密"></a>使用对称加密</h2><p>最简单的加密方式是使用对称加密。<strong>对称加密指加密与解密都使用相同密钥。</strong></p><p>如果我们需要在客户端与服务端中加密解密同一个文件，那么我们需要提前了解加密解密的方式与对应的密钥。因此在 HTTPS 发送请求之前，浏览器和服务器之间需要协商加密的方式与密钥。</p><p>对称加密的具体方法如下：</p><ol><li>浏览器发送它所支持的加密套件列表和一个随机数 Client Random（<strong>加密套件指的是加密的方法</strong>，加密套件列表指的是浏览器能支持的加密方法列表）。</li><li>服务器从收到的加密套件列表中选取一个加密套件，并生成一个随机数 Service Random，然后将 Service Random 与选择的加密套件返回至浏览器。</li><li>浏览器和服务器分别返回确认消息。</li></ol><p>通过上面这个步骤，服务器端与浏览器端都有了相同的 Client Random 与 Service Random，然后他们再使用相同的方法将两者混合起来生成一个密钥 Master Secret，有了密钥 Master Secret 和加密套件后，双方就可以进行数据的加密传输了。</p><p>通过这种方式，我们实现了在安全层上应用对称加密。尽管这种方式可以很好的进行工作，但是客户端与服务端所传输的 Client Random 与 Service Random 仍然是明文传输。因此理论上黑客可以得到协商好的加密套件与双方的随机数，而通过随机数合成密钥的算法是公开的，因此黑客拿到随机数之后仍然可以合成密钥，这种方式依然可以被破解。</p><h2 id="使用非对称加密"><a href="#使用非对称加密" class="headerlink" title="使用非对称加密"></a>使用非对称加密</h2><p>使用非对称加密可以解决上面的这个问题。<strong>非对称加密指的是有 A、B 两把密钥，如果使用密钥 A 进行加密，那么我们只能使用密钥 B 进行解密；同样，如果我们使用密钥 B 进行加密，那么只能使用密钥 A 进行解密</strong>。</p><p>在 HTTPS 中服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为 <strong>公钥</strong>，服务器自己留下的那个密钥叫做 <strong>私钥</strong>。公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。</p><p>使用非对称加密的请求流程如下：</p><ol><li>浏览器发送加密套件列表给服务器。</li><li>服务器选择一个加密套件，然后将加密套件与服务器选择好的公钥返回给浏览器。</li><li>浏览器和服务器返回确认消息。</li></ol><p>通过这种方式，浏览器端获得了服务器的公钥，那么当浏览器向服务器发送数据时，便可以使用公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即使黑客获取了数据与公钥，也无法使用公钥来解密数据。</p><p>采用非对称加密已经可以保证浏览器发送给服务器的数据是安全的，但是这种方式仍然存在两个严重的问题：</p><ol><li>非对称加密的效率太低，这会影响到加解密数据的速度，进而影响用户打开页面的速度。</li><li>无法保证服务器发送给浏览器的数据安全。虽然浏览器端可以使用公钥进行加密，但是服务器端只能使用私钥加密。私钥加密只有公钥能解密，但黑客也是可以获取到公钥的，因此不能保证服务器端的数据安全。</li></ol><h2 id="混合加密：对称加密和非对称加密搭配使用"><a href="#混合加密：对称加密和非对称加密搭配使用" class="headerlink" title="混合加密：对称加密和非对称加密搭配使用"></a>混合加密：对称加密和非对称加密搭配使用</h2><p>基于以上原因，我们最终选择了一个更加完美的方案：传输数据阶段依然使用对称加密，但是对称加密的密钥我们提前采用非对称加密进行传输。</p><p>混合加密的具体流程如下：</p><ol><li>浏览器端手握一组密钥 与 ，服务器端手握非对称加密的公钥 和私钥 。</li><li>浏览器端向服务器端发送加密套件列表、非对称加密套件列表。</li><li>服务器端选择一个加密套件与非加密套件，并结合自己的公钥 一起返回给浏览器。</li><li>浏览器使用服务器的公钥 对自己的密钥 进行加密，记加密后的密钥为 。</li><li>服务器收到加密后的密钥 ，并使用自己的私钥 进行解密，得到浏览器端的密钥 。</li></ol><p>通过这种方式浏览器端与服务器端在加密状态下，获得了浏览器端的密钥。因此在接下来传输数据的过程当中，只需要让浏览器端使用一个密钥进行加密，服务器端再使用另外一个密钥要进行解密即可。</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>通过这种方式已经实现了数据的加密传输，但是这种方式仍然存在一个问题：假如黑客通过 DNS 劫持了目的地址的 IP 地址，并将其替换为了黑客的 IP 地址，那么我们访问的就是黑客的服务器。黑客就可以在自己的服务器上实现公钥和私钥，但是对于浏览器而言，并不知道实际上访问的是黑客的服务器。</p><p>因此服务器需要向浏览器提供证明：我就是你想访问的真正的目的地址。为了达到这一目的，服务器可以向客户端与服务端都信赖的第三方机构 <strong>Certificate Authority CA</strong> 申请 <strong>数字证书 Digital Certificate</strong>。</p><p>数字证书由数字签名与服务器的公钥组成。因此对于浏览器而言，数字证书有两个作用：</p><ol><li>通过数字证书向浏览器证明服务器的身份。</li><li>数字证书包含了服务器的公钥。</li></ol><p>具体而言，混合加密与数字证书结合在一起的流程如下：</p><ol><li>浏览器端手握一组密钥 与 ，服务器端手握非对称加密的公钥 和私钥 ，CA 自己本身持有根公钥 与根私钥 ，其中根公钥 已经提前置于浏览器或操作系统。</li><li>服务器向 CA 申请注册数字证书时提供自己的公钥 。CA 通过服务器的相关信息与自己的根私钥 生成数字签名，同时将服务器自己的公钥 结合在一起生成了服务器的数字证书。</li><li>浏览器端想要发起请求时，首先向服务器端发送加密套件列表、非对称加密套件列表。</li><li>服务器端选择一个加密套件与非加密套件，并将自己的数字证书一起返回给浏览器。</li><li>浏览器端根据提前置于浏览器或者操作系统的 CA 根公钥 对数字证书进行解码，验证响应来源是对应的服务器，并获得服务器的公钥 。然后浏览器使用服务器的公钥 对自己的密钥 进行加密，记加密后的密钥为 。</li><li>服务器收到加密后的密钥 ，并使用自己的私钥 进行解密，得到浏览器端的密钥 。</li></ol><p>此时，浏览器与服务器已经各自持有了一组密钥，并且浏览器也已经验证了响应的数据来源是我们期待的那一个服务器，此时再数据进行加密传输即可。</p><p>通过混合加密与数字证书结合的这种方式，最终实现了数据的安全传输。</p><h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>在没有安全保障的 Web 网页中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据安全。</p><p>而页面中最基础、最核心的安全策略就是 <strong>同源策略 Same Origin Policy</strong>。</p><h2 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h2><p>如果两个 URL 的协议、域名和端口号都相同，我们就称这两个 URL 同源。</p><p>浏览器默认两个同源站点可以互相访问资源并且操作 DOM 的，而两个不同源站点如果想要相互访问资源或者操作 DOM，那么就需要有一套基础的安全策略的制约，即同源策略。</p><p>同源策略主要表现在 DOM、Web 数据和网络三个层面。</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读写的操作。</p><p>比如我们打开网页 A，并从网页 A 跳转进入网页 B：</p><ol><li>如果网页 B 与网页 A 同源，那么在网页 B 可以操控网页 A 的 DOM。</li><li>如果网页 B 与网页 A 不同源，那么在网页 B 无法操控网页 A 的 DOM。</li></ol><h2 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h2><p>同源策略限制了不同源站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据，因此无法从不同源的站点中读取其他源站点的 Cookie、IndexDB、LocalStorage 等数据。</p><h2 id="网络层面"><a href="#网络层面" class="headerlink" title="网络层面"></a>网络层面</h2><p>同源策略还限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送到不同源的站点。</p><h2 id="安全性与便利性的权衡"><a href="#安全性与便利性的权衡" class="headerlink" title="安全性与便利性的权衡"></a>安全性与便利性的权衡</h2><p>安全性与便利性是相互对立的：直接隔离不同源站点，肯定是最安全的措施，但这也会让 Web 项目变得难以开发与使用。因此，同源策略需要在这两者之间做出权衡，即出让一部分安全性来满足便利性。</p><p>但是出让安全性又会导致许多安全问题，最典型的就是 <strong>跨站脚本攻击 Cross Site Scripting XSS</strong> 与 <strong>跨站请求伪造 Cross Size Request Forgery CSRF</strong>。</p><h2 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a>内容安全策略</h2><p>如果同源策略限制一个页面的所有资源都来自同源，那么自然存在许多限制。因此浏览器支持引用不同源站点资源文件，但是这也导致了许多安全问题。</p><p>如果引入了恶意脚本，这些脚本就能够将页面的敏感数据比如 Cookie、IndexDB、LocalStorage 等等通过 XSS 的手段发送到指定服务器。</p><p>为了解决 XSS 攻击，浏览器中引入了 <strong>内容安全策略 Content Safe Policy CSP</strong>。<strong>CSP 的核心思想是让服务器决定浏览器的脚本能够加载哪些资源，以及让服务器决定浏览器是否能够执行内联 JavaScript 代码</strong>。</p><h2 id="跨域资源共享和跨文档消息机制"><a href="#跨域资源共享和跨文档消息机制" class="headerlink" title="跨域资源共享和跨文档消息机制"></a>跨域资源共享和跨文档消息机制</h2><p>默认情况下，如果打开某一个网站页面，那么该网站页面可能会通过 <code>XMLHttpRequest</code> 或者 <code>Fetch</code> 来请求其他服务器的资源。但是同源策略会阻止其向其他服务器发出请求，但是这样会很大程度制约我们的生产力。</p><blockquote><p>注意：有三个标签是可以直接进行跨域请求的：</p><ul><li>  <code>&lt;img src=xxx/&gt;</code></li><li>  <code>&lt;link href=xxx/&gt;</code></li><li>  <code>&lt;script src=xxx/&gt;</code></li></ul></blockquote><p>为了解决这个问题，便引入了 <strong>跨域资源共享 Cross Origin Resource Sharing CORS</strong>。CORS 可以帮助进行跨域访问控制，并且使得跨域数据传输在安全中进行。</p><p>前面提到，如果两个页面不是同源的，那么无法相互操纵 DOM。不过在实际应用中，不同源的 DOM 往往需要进行通信，因此浏览器又引入了 <strong>跨文档消息机制</strong>，即通过 <code>window.postMessage()</code>方法与 JavaScript 接口实现不同源之间的 DOM 通信。</p><h1 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h1><p>同源策略可以隔离不同源站点的 DOM 交互、页面数据以及网络通信。严格的同源策略会更加保证安全，但是也束缚了 Web 开发。因此需要在安全性与便捷性之间找到一个平衡点，如果浏览器默认可以引用任意第三方资源，那么就存在 XSS 风险，于是浏览器又通过 CSP 策略来加以限制。</p><h2 id="什么是-XSS-攻击"><a href="#什么是-XSS-攻击" class="headerlink" title="什么是 XSS 攻击"></a>什么是 XSS 攻击</h2><p><strong>跨站脚本攻击 Cross Site Scripting</strong> 是指黑客向 HTML 文件或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。跨站脚本攻击的简称为了与 CSS 进行区分，所以对齐简称为 XSS。</p><p>在早期，XSS 主要通过跨域实现，所以叫做跨域脚本。但是时至今日，向 HTML 或者 DOM 中注入恶意代码的方式越来越多，并不局限于跨域注入脚本，只是 XSS 这个名字沿用至今。</p><p>当页面被注入了恶意脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限，因此恶意脚本可以进行下列这些操作：</p><ul><li>  窃取 Cookie 信息；</li><li>  监听用户行为；</li><li>  修改 DOM；</li><li>  在页面中生成浮窗广告；</li><li>  ……</li></ul><h2 id="恶意脚本是如何注入的"><a href="#恶意脚本是如何注入的" class="headerlink" title="恶意脚本是如何注入的"></a>恶意脚本是如何注入的</h2><p>通常有三种方式注入恶意脚本：</p><ol><li>存储型 XSS 攻击。</li><li>反射型 XSS 攻击。</li><li>基于 DOM 的 XSS 攻击。</li></ol><h3 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h3><p>存储型 XSS 攻击大致需要经过下列三个步骤：</p><ol><li>黑客利用服务器漏洞将恶意脚本提交至网站服务器；</li><li>用户访问了包含恶意脚本的网站；</li><li>当用户浏览网站时，恶意脚本就会将用户的 Cookie 等数据上传到黑客服务器。</li></ol><h3 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h3><p>反射型 XSS 攻击与存储型 XSS 攻击类似，不同的地方在于，存储型 XSS 攻击是利用服务器将恶意脚本存储值服务器，随后返回至浏览器；而反射型 XSS 攻击是用户将恶意脚本发送至服务器，随后服务器将接收到的恶意脚本发送到网站。具体的过程如下：</p><ol><li>黑客利用网站漏洞将恶意脚本提交给服务器；</li><li>服务器将恶意脚本返回至网站；</li><li>恶意脚本成功在网站运行，将用户的 Cookie 等数据上传到黑客服务器。</li></ol><h3 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h3><p>基于 DOM 的 XSS 攻击并不涉及页面的 Web 服务器。具体而言，黑客通过各种⼿段将恶意脚本注入用户页面，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容。劫持类型很多，可以通过 WiFi 路由器劫持，可以通过本地恶意软件劫持……它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</p><h2 id="如何阻止-XSS-攻击"><a href="#如何阻止-XSS-攻击" class="headerlink" title="如何阻止 XSS 攻击"></a>如何阻止 XSS 攻击</h2><p>前面讲过，存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。</p><p>基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。</p><p>但无论是何种类型的 XSS 攻击，它们都有⼀个共同点，那就是首先向浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</p><p>所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p><p>主要有以下几种方式可以实现。</p><h3 id="对输入脚本进行过滤或转码"><a href="#对输入脚本进行过滤或转码" class="headerlink" title="对输入脚本进行过滤或转码"></a>对输入脚本进行过滤或转码</h3><p>我们可以在客户端或者服务器端对关键字符进行转码，比如如果出现了脚本标签 <code>&lt;script&gt;</code>，那么就将其过滤掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code:&lt;script&gt;alert(&#x27;你被 xss 攻击了&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>过滤后只留下了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br></pre></td></tr></table></figure><h3 id="充分利用内容安全策略-CSP"><a href="#充分利用内容安全策略-CSP" class="headerlink" title="充分利用内容安全策略 CSP"></a>充分利用内容安全策略 CSP</h3><p>CSP 大致有如下几个功能：</p><ul><li>  限制加载非同源资源文件，从而即使黑客插入了恶意脚本，该脚本也无法被加载；</li><li>  禁止向第三方提交数据，从而数据不会外泄；</li><li>  进制执行内联脚本与未授权的脚本；</li><li>  提供上报机制，可以帮我们尽快发现存在哪些 XSS 攻击，以便尽快修复问题。</li></ul><h3 id="使用-HttpOnly-属性"><a href="#使用-HttpOnly-属性" class="headerlink" title="使用 HttpOnly 属性"></a>使用 HttpOnly 属性</h3><p>许多的 XSS 攻击都是为了盗用 Cookie，因此可以通过 <code>HttpOnly</code> 属性来保护 Cookie 的安全。</p><p>服务器可以在 HTTP 响应头中的 <code>Set-Cookie</code> 字段中使用 <code>HttpOnly</code> 标记 Cookie，这样被标记的 Cookie 只能使用在 HTTP 请求中，无法通过脚本代码来读取这段 Cookie：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&quot;Set-Cookie&quot;,</span><br><span class="line">&quot;CookieName=value;Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly&quot;);</span><br></pre></td></tr></table></figure><h1 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h1><p><strong>跨站请求伪造 Cross Site Request Forgery CSRF</strong>，指引诱用户利用用户的登录状态发起跨站请求。CSRF 即利用了用户的登录状态，并通过第三方站点来进行其他操作。</p><p>攻击者可以通过一些技术手段欺骗用户的浏览器访问一个曾经认证过的网站并运行一些操作。由于浏览器曾经认证过，被访问的网站会认为是真正的用户在操作而去执行。这就是 CSRF 漏洞产生的原因：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><p>​</p><p>假设某家银行转账的 URL 形式如下：<code>http://domain/withdraw?account=NAME&amp;amount=AMOUNT&amp;to=PAYEENAME</code>，那么攻击者可以在另外一个网站放置这样的代码：<code>&lt;img src=&#39;http://domain/withdraw?account=PETER&amp;amount=100&amp;to=JOHN&#39;&gt;</code>。当账户名为 Peter 的用户点击了该图片，并且此时浏览器仍然保存了 Peter 的登陆信息，那么将会自动将 100 资金转移至攻击者 John 的账户中。</p><p>类似的攻击形式有很多，并且可以藏身于许多地方。任何用户可以生成内容的地方都可能存在这种潜在的危机。因此，如果服务器没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p><p>与 XSS 攻击不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞与用户登录状态实施攻击，并且黑客无法通过 CSRF 获取用户的页面数据。因此，XSS 攻击利用的是用户对指定网站的信任，而 CSRF 利用的是网站对用户浏览器的信任。</p><h2 id="防范-CSRF-攻击"><a href="#防范-CSRF-攻击" class="headerlink" title="防范 CSRF 攻击"></a>防范 CSRF 攻击</h2><p>服务器防范 CSRF 攻击，通常有以下几种途径。</p><h3 id="充分利用-Cookie-的-SameSite-属性"><a href="#充分利用-Cookie-的-SameSite-属性" class="headerlink" title="充分利用 Cookie 的 SameSite 属性"></a>充分利用 Cookie 的 SameSite 属性</h3><p>黑客主要利用用户的登陆状态进行 CSRF 攻击，而 Cookie 就是浏览器与服务器维护登陆状态的关揵数据。</p><p>CSRF 攻击通常在第三方站点发起，那么要防止 CSRF 攻击，最好能够实现 <strong>从第三方站点发送请求时禁止 Cookie 的发送</strong>。</p><p>即：</p><ul><li>  如果 HTTP 请求是同一站点发起的请求，那么就需要保证 Cookie 数据正常发送。</li><li>  如果是从第三方站点发起请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器。</li></ul><p>Cookie 中的 <code>SameSite</code> 属性可以解决这个问题：在 HTTP 响应头中，通过 <code>Set-Cookie</code> 字段设置 Cookie 时，可以添加 <code>SameSite</code> 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&quot;Set-Cookie&quot;, &quot;CookieName=value;Path=/;Domain=domainvalue;SameSite=Strict&quot;);</span><br></pre></td></tr></table></figure><p><code>SameSite</code> 属性通常有 <code>Strict</code>、<code>Lax</code> 和 <code>None</code> 三个选项：</p><ul><li>  <code>Strict</code>：最为严格。浏览器会完全禁止第三方 Cookie；</li><li>  <code>Lax</code>：相对宽松。在跨站点的情况下，从第三方站点发送请求或者从第三方站点提交 <code>GET</code> 表单都会携带 Cookie。但是如果在第三方站点使用 <code>POST</code> 方法，或者通过 <code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code> 等标签加载 URL 都不会携带 Cookie；</li><li>  <code>None</code>：宽松。对于发送 Cookie 没有任何限制。</li></ul><h3 id="验证请求的来源站点"><a href="#验证请求的来源站点" class="headerlink" title="验证请求的来源站点"></a>验证请求的来源站点</h3><p>服务器通过请求头的 <code>Referer</code> 与 <code>Origin</code> 字段判断来源站点。</p><p><code>Referer</code> 记录了该 HTTP 请求的来源地址。虽然可以通过 <code>Referer</code> 字段告诉服务器 HTTP 请求的来源，但是有一些场景并不适合将来源 URL 暴露给服务器。因此可以不用上传 <code>Referer</code> 字段。</p><p><code>Origin</code> 记录了该 HTTP 请求的源信息（协议、域名与端口号），并不包括完整的 URL 路径。</p><p>服务器的策略是优先判断 <code>Origin</code> 属性，如果请求头中没有包含 <code>Origin</code> 属性，那么再根据实际情况来判断是否使用 <code>Referer</code> 值。</p><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>另外一种方式是，服务器与浏览器约定一个独立于登陆状态以外的隐藏值作为 Token。当网站向服务器发起请求时，服务器生成一个 CSRF Token 返回至网站站点并进行隐藏；当该网站站点再次向服务器发起请求时，需要携带本站点中隐藏的 CSRF Token 值。</p><h1 id="跨域的解决方案"><a href="#跨域的解决方案" class="headerlink" title="跨域的解决方案"></a>跨域的解决方案</h1><p><strong>跨域资源共享 Cross Origin Resource Sharing CORS</strong> 是浏览器引入的解决跨域的一个方案。CORS 可以帮助我们进行跨域访问控制，并使得我们的跨域数据传输在安全中进行。</p><p>要注意的一个细节是：我们的请求跨域了，那么我们的请求到底有没有发出去？</p><p>答案是：跨域并不是请求发不出去，而是请求正常发送，服务端收到请求返回正常结果，只是结果被浏览器拦截了。</p><p>CORS 允许浏览器向跨源服务器发送 <code>XMLHttpRequest</code> 请求，从而克服了 AJAX 只能同源使用的限制。但是 CORS 需要浏览器和服务器同时支持，浏览器一旦发现跨域请求，就会添加一些附加的头信息。</p><p>浏览器将 CORS 请求分为两类：简单请求与复杂请求。</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>简单请求不会触发预检。请求如果满足下列几个条件，都属于简单请求，否则属于非简单请求：</p><ul><li>请求方法是以下三种方法之一：<ul><li>  <code>HEAD</code></li><li>  <code>GET</code></li><li>  <code>POST</code></li></ul></li><li>没有人为设置以下几种字段外的请求头：<ul><li>  <code>Accept</code></li><li>  <code>Accept-Language</code></li><li>  <code>Content-Language</code></li><li>  <code>Content-Type</code> 只限于三个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>。</li><li>  <code>DPR</code></li><li>  <code>Downlink</code></li><li>  <code>Save-Data</code></li><li>  <code>Viewport-Width</code></li><li>  <code>Width</code></li></ul></li><li>  请求中的 <code>XMLHttpRequestUpload</code> 对象没有注册事件监听器。</li><li>  请求中没有使用 <code>ReadableStream</code> 对象。</li></ul><p>浏览器会为简单请求的请求头添加 <code>Origin</code> 字段，描述请求来源的源信息：协议、域名与端口号。</p><p>请求发送至服务器后，服务器如果认为该请求可接收，会在响应头 <code>Access-Control-Allow-Origin</code> 字段中指定相同的源信息或者使用 <code>*</code> 表示所有域名。</p><p>除此之外，响应头中可能包括 <code>Access-Control-Expose-Headers</code> 字段。由于 <code>XMLHttpRequest</code> 对象方法只能够拿到响应头的这六个字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code> 与 <code>Pragma</code>。如果 <code>XMLHttpRequest</code> 对象想要获取其他字段，服务器可以将其他字段填入 <code>Access-Control-Expose-Headers</code> 字段。</p><h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><p>在 CORS 策略下，复杂请求会在正式通信之前进行一次 <strong>预检</strong> 请求。</p><p>浏览器会先询问服务器，当前网页所在的域名是否可以请求该服务器，以及可以使用哪些 HTTP 请求头，只有得到了肯定的答复之后，才会进行正式的请求。</p><p><strong>预检</strong> 请求的方法是 <code>OPTIONS</code>，表示该请求用于询问。</p><p>服务器在收到预检请求并检查 <code>Origin</code>、<code>Access-Control-Request-Method</code> 与 <code>Access-Control-Request-Headers</code> 字段后，将对其做出响应。</p><ul><li>  如果服务器拒绝了本次预检请求，那么在返回正常 HTTP 响应报文中，HTTP 响应头将不会含有任何与 CORS 相关的头信息。</li><li>  如果服务器同意了本次预检请求，就会在 HTTP 响应头中添加 <code>Access-Control-Allow-Origin</code> 等字段。同时浏览器在确定服务器同意预检后，将会发出正式的 HTTP 跨域请求。</li></ul><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p><strong>JSONP JSON with Padding</strong> 实现跨域的原理是 <strong>利用脚本标签 <code>&lt;script&gt;</code> 不受跨域限制的漏洞，使得网页可以从其他来源中接收 JSON 数据</strong>。</p><p>尽管都是客户端像浏览器发送请求获取数据，但是 AJAX 受同源策略的影响，而 JSONP 不受影响，可以发起跨域请求。</p><p>JSONP 的优点是简单兼容性好，但是缺点也十分明显：仅支持 <code>GET</code> 方法，并且容易遭受 XSS 攻击。</p><h2 id="具体实现流程"><a href="#具体实现流程" class="headerlink" title="具体实现流程"></a>具体实现流程</h2><ol><li>定义一个辅助函数，接收请求的接口地址、参数，与一个方法名如 <code>work</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function jsonp(&#123;url, params, callback&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure><ol><li>辅助函数返回 <code>Promise</code> 实例对象，并将接口与参数整合为请求的 URL，并在 DOM 中添加 <code>script</code> 节点，指定该 URL 为 <code>script</code> 节点的 <code>src</code> 属性：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> arrs = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">arrs.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">arrs.<span class="title function_">push</span>(<span class="string">`callback=<span class="subst">$&#123;callback&#125;</span>`</span>)</span><br><span class="line">script.<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在全局对象（浏览器中为 <code>window</code>）定义传入的方法名，将其作为最后执行的方法。在这个方法中，首先要通过 <code>resolve()</code> 改变 <code>Promise</code> 实例的状态，还需要移除已经执行结束的脚本：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line"><span class="variable language_">window</span>[callback] = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line"><span class="title function_">resolve</span>(data)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arrs = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">arrs.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">arrs.<span class="title function_">push</span>(<span class="string">`callback=<span class="subst">$&#123;callback&#125;</span>`</span>)</span><br><span class="line">script.<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">jsonp</span>(&#123;</span><br><span class="line"><span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/api&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>: &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;Yucohny&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">callback</span>: <span class="string">&#x27;work&#x27;</span>,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>在服务器代码中，将该接口的对应的属性值取出，并将其作为字符串形式函数调用的方法名，如 <code>work(age=20)</code>。当字符串形式的函数调用返回至浏览器后，浏览器将自动识别并查找 <code>window</code> 中是否有对应的方法名，如果有就调用：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> callback = url.<span class="title function_">parse</span>(req.<span class="property">url</span>, <span class="literal">true</span>).<span class="property">query</span>.<span class="property">callback</span></span><br><span class="line">res.<span class="title function_">write</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(age=20)`</span>)</span><br><span class="line">res.<span class="title function_">end</span>()</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h2 id="Window-postMessage"><a href="#Window-postMessage" class="headerlink" title="Window.postMessage()"></a>Window.postMessage()</h2><p><code>window.postMessage()</code> 方法可以安全地实现跨域通信。<code>window.postMessage()</code> 方法提供了一种机制来规避同源策略的限制：</p><p>如果满足下列三者中的一种，那么可以通过 <code>window.postMessage()</code> 方法实现跨域通信：</p><p>1.页面与其打开的新窗口的数据传递；</p><p>2.多窗口之间数据传递；</p><p>3.页面与嵌套的 iframe 消息传递。</p><p>方法参数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer])</span><br></pre></td></tr></table></figure><ul><li>  <code>otherWindow</code>：其他窗口的引用，比如 <code>iframe</code> 的 <code>contentWindow</code> 属性；</li><li>  <code>message</code>：发送的数据；</li><li>  <code>targetOrigin</code>：目标地址，指定哪些窗口能接收到数据；</li><li>  <code>transfer</code>：可选参数，一串与数据同时传递的 <code>Transferable</code> 对象。这些对象的所有权将被转移至消息的接收方，发送方不再具有所有权。</li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><strong>WebSocket</strong> 实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 与 HTTP 都是应用层协议，也都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立持久连接之后，服务器与客户端都能主动向对方发送或接收数据。</p><h2 id="nginx-反向代理"><a href="#nginx-反向代理" class="headerlink" title="nginx 反向代理"></a>nginx 反向代理</h2><p>nginx 是常见的 Web 服务器，可以作为中间件转发请求。</p><p>nginx 可以通过反向代理实现跨域，只需要进行简单的配置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
